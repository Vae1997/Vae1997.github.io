<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>C++11特性总结记录 | 许嵩的博客</title><meta name="description" content="记录C++11中相关特性"><meta name="keywords" content="C++"><meta name="author" content="Vae,vae.xusong.cn@gmail.com"><meta name="copyright" content="Vae"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="shortcut icon" href="/img/Vae.jpg"><link rel="canonical" href="https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="C++11特性总结记录"><meta property="og:url" content="https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"><meta property="og:site_name" content="许嵩的博客"><meta property="og:description" content="记录C++11中相关特性"><meta property="og:image" content="https://vae1997.github.io/images/common/2.png"><meta property="article:published_time" content="2020-09-24T11:36:34.760Z"><meta property="article:modified_time" content="2020-09-25T06:43:21.177Z"><meta name="twitter:card" content="summary"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><script>var GLOBAL_CONFIG = { 
  root: '/',
  hexoversion: '5.2.0',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime: '天',
  date_suffix: {"one_hour":"刚刚","hours":"小时前","day":"天前"},
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
    },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-25 14:43:21'
}</script><noscript><style type="text/css">
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
  }
}

var autoChangeMode = '1'
var t = saveToLocal.get('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (saveToLocal.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/myicon.css"><link rel="stylesheet" href="/css/iconcard.css"><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="许嵩的博客" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/Vae.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">6</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">6</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">auto</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">&#x3D;default &amp; &#x3D;delete</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.1.</span> <span class="toc-text">&#x3D;default</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">2.2.</span> <span class="toc-text">&#x3D;delete</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">decltype</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">initialization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">4.1.</span> <span class="toc-text">initializer_list</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">lambda</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">rvalue references</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.1.</span> <span class="toc-text">lvalue &amp; rvalue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.2.</span> <span class="toc-text">lvalue references &amp; rvalue references</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.3.</span> <span class="toc-text">Move Sementics</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.4.</span> <span class="toc-text">std::move</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.5.</span> <span class="toc-text">universal reference</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">6.6.</span> <span class="toc-text">Perfect Forwarding</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">smart pointer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.1.</span> <span class="toc-text">auto_ptr（C11弃用）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.2.</span> <span class="toc-text">unique_ptr（代替auto_ptr）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.3.</span> <span class="toc-text">shared_ptr（基于引用计数实现）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">7.4.</span> <span class="toc-text">weak_ptr（解决循环引用问题）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">面试补充</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">8.1.</span> <span class="toc-text">shared_ptr初始化unique_ptr?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">8.2.</span> <span class="toc-text">手撕智能指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">8.2.1.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">8.2.2.</span> <span class="toc-text">shared_ptr</span></a></li></ol></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(/../images/common/2.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">许嵩的博客</a></span><span id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><span class="close" id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">C++11特性总结记录</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-24T11:36:34.760Z" title="发表于 2020-09-24 19:36:34">2020-09-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-25T06:43:21.177Z" title="更新于 2020-09-25 14:43:21">2020-09-25</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">4.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>17分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>📺<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1p4411v7Dh?from=search&amp;seid=11158986983875788976">B站侯捷C++11</a></p>
<h1>auto</h1>
<p>通过编译器自动获取变量类型，⚠️常在类型长/复杂(lambda)的情况下使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin();<span class="comment">//迭代器类型vector&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;···&#125;;<span class="comment">//获取lambda的返回类型</span></span><br></pre></td></tr></table></figure>
<h1>=default &amp; =delete</h1>
<p>📖<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html">https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html</a></p>
<p>简单理解为：</p>
<ul>
<li>=default：需要用编译器默认生成的（Big-Three）特殊成员函数</li>
<li>=delete：禁止使用当前修饰的函数</li>
</ul>
<h2>=default</h2>
<ul>
<li>类中的特殊成员函数（构造、析构、拷贝、赋值）显式定义后，编译器默认生成的将失效</li>
<li>若仍需使用默认的函数，则必须显式定义，<code>增加编码工作量</code></li>
<li>此外，显式定义的函数<code>效率低于</code>编译器自动生成的</li>
<li>⚠️可在类外定义，但只能修饰类的特殊成员函数，且该函数没有默认参数</li>
</ul>
<h2>=delete</h2>
<ul>
<li>为禁止类对象之间的拷贝、赋值，或禁用不期望的转换和操作符</li>
<li>⚠️适用于普通函数，若修饰成员函数则只能在类中定义</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//inline default</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;<span class="comment">//delete只能在类中定义</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>=<span class="keyword">delete</span>;<span class="comment">//普通函数也可delete</span></span><br><span class="line">    <span class="keyword">virtual</span> ~A();</span><br><span class="line">&#125;;</span><br><span class="line">A::~A()=<span class="keyword">default</span>;<span class="comment">//Out-of-line default</span></span><br></pre></td></tr></table></figure>
<h1>decltype</h1>
<p>简单理解为：用于获取对象类型</p>
<ul>
<li>用于说明返回类型：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// decltype(x+y)add(T1 x, T2 y); add函数返回类型为x+y的返回类型</span></span><br><span class="line"><span class="comment">//但是x+y先于声明，编译无法通过，因此使用如下方法</span></span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x+y);//使用-&gt;，指定add函数的返回类型</span><br></pre></td></tr></table></figure>
<ul>
<li>用于模板中：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj为容器，则获取类型后可以进一步获取相关属性</span></span><br><span class="line"><span class="keyword">decltype</span>(obj)::iterator</span><br></pre></td></tr></table></figure>
<ul>
<li>获取lambda表达式的类型：</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义用于对象比较的lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp=[](<span class="keyword">const</span> Obj&amp; obj1, <span class="keyword">const</span> Obj&amp; obj2)&#123;<span class="keyword">return</span> ···&#125;;</span><br><span class="line"><span class="comment">//在set中根据cmp比较对象大小</span></span><br><span class="line">std::set&lt;Obj, decltype(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure>
<h1>initialization</h1>
<p>C++11之前初始化可以使用（）、{ }、=，C11提出一致使用{ }进行初始化</p>
<p>⚠️编译器看到{ }，实际生成的是initializer_list<T>，即<code>初始化列表</code></T></p>
<p>⚠️初始化列表背后关联<code>array&lt;T,n&gt;</code>容器（仅包含array的头部指针），并将容器中的值挨个传递到<code>构造函数</code></p>
<p>⚠️如果构造函数的参数本身就是initializer_list<T>，则整体直接传递，不再进行拆解</T></p>
<h2>initializer_list</h2>
<p>使用{ }设置默认初值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;<span class="comment">//j为int，默认0</span></span><br><span class="line"><span class="keyword">int</span>* p;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;;<span class="comment">//q为int*，默认nullptr</span></span><br><span class="line"><span class="keyword">char</span> c&#123;<span class="number">99999</span>&#125;;<span class="comment">//原则上不可以，根据编译器而定error/warning</span></span><br></pre></td></tr></table></figure>
<p>initializer_list<T>作为函数参数，接收任意个T类型的参数</T></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span>;</span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);<span class="comment">//必须使用&#123; &#125;传参</span></span><br></pre></td></tr></table></figure>
<h1>lambda</h1>
<p>可以简单当作是inline函数，格式如下：</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ⅰ] (Ⅱ) <span class="keyword">mutable</span> <span class="keyword">throw</span> -&gt; retType &#123;Ⅲ&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>[]：导入器，捕获外部变量，传值(默认)/传引用</p>
</li>
<li>
<p>()：参数，当需要传参，或指定mutable、throw、retType之一时，则必须有</p>
</li>
<li>
<p>mutable：决定[]中的值是否可以进行修改，可选</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [id]()<span class="keyword">mutable</span>&#123;<span class="comment">//id为值传递，指定mutable则内部可以修改id值</span></span><br><span class="line">    <span class="comment">//但注意此时，id作为0传递进来</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;;</span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line">f1();<span class="comment">//调用lambda，值传递传入的id为0，但不影响外面的id值42</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;id]()<span class="keyword">mutable</span>&#123;···&#125;;<span class="comment">//传引用，则lambda内部的id和外部“共享”</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=,&amp;id]&#123;···&#125;;<span class="comment">//除id外的其余变量均为默认的值传递，没有mutable不能进行修改</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>throw：抛出异常，可选</p>
</li>
<li>
<p>retType：返回类型，可选</p>
</li>
</ul>
<p>⚠️默认情况下，<code>lambda函数总是一个const函数</code>，mutable可以取消其常量性</p>
<h1>rvalue references</h1>
<p>📖<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qicosmos/p/3369940.html">https://www.cnblogs.com/qicosmos/p/3369940.html</a></p>
<p>📖<a target="_blank" rel="noopener" href="https://www.cnblogs.com/qicosmos/p/3376241.html">https://www.cnblogs.com/qicosmos/p/3376241.html</a></p>
<p>📖<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html">https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html</a></p>
<p>📖<a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016041544">https://segmentfault.com/a/1190000016041544</a> (<strong>更为详细全面</strong>)</p>
<ul>
<li>
<p>减少不必要的对象拷贝；使泛函定义更简洁</p>
</li>
<li>
<p>实现移动语义（Move Sementics）和完美转发（Perfect Forwarding）</p>
</li>
</ul>
<h2>lvalue &amp; rvalue</h2>
<ul>
<li>
<p>左值：表达式结束后依然存在的<code>持久化对象</code></p>
</li>
<li>
<p>右值：常表现为<code>临时对象</code>，只在当前语句中有效</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = get_a();<span class="comment">//a为左值，非引用返回的get_a()返回的临时变量为右值（纯右值）</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">std</span>::move(a);<span class="comment">//通过move返回的右值（将亡值）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>区分方法：若可对表达式<code>用 &amp; 符取址</code>，则为左值，否则为右值</p>
</li>
<li>
<p>右值也可以被修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T()生成临时对象（右值），并将对象内部的变量通过set方法进行修改</span></span><br><span class="line">T().<span class="built_in">set</span>().get();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2>lvalue references &amp; rvalue references</h2>
<ul>
<li>
<p>左值赋值左值引用（变量别名），右值赋值右值引用（临时变量的别名，生命周期延长）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; refa = a;<span class="comment">//左值引用refa，只能被左值a赋值，refa为左值</span></span><br><span class="line"><span class="comment">//！int&amp; b = 1; 左值引用b不能被右值1赋值</span></span><br><span class="line"><span class="comment">//！int&amp;&amp; b = a; 右值引用b不能被左值a赋值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; b = <span class="number">1</span>;<span class="comment">//右值引用b，只能被右值1赋值，但注意此时b本身为左值</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>const lvalue references</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span>;<span class="comment">//const左值引用可以接收右值</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2>Move Sementics</h2>
<ul>
<li>
<p>对于右值的拷贝和赋值会调用<code>移动构造函数</code>和<code>移动赋值操作符</code></p>
</li>
<li>
<p>若没有定义，则<code>拷贝构造函数</code>和<code>拷贝赋值操作符</code>会被调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造，若没有移动构造，当参数使用move或传递右值时，由于拷贝构造参数为const T&amp;，因此才会接受右值进行调用</span></span><br><span class="line">MyString(<span class="keyword">const</span> MyString&amp; str): _len(str._len) &#123;</span><br><span class="line">    _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">   	_data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动构造，当vector/deque扩容时，移动构造使用noexcept确保成功扩容</span></span><br><span class="line"><span class="comment">//str需要修改，因此不加const，但需要noexcept（表明一定不会发生异常）</span></span><br><span class="line">MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span> : _len(str._len) &#123;</span><br><span class="line">    _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">    str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">    str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">        str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">        str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>普通的函数和操作符也可以利用右值引用操作符实现转移语义</p>
</li>
</ul>
<h2>std::move</h2>
<ul>
<li>希望将左值转为右值：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">	fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">	fun(<span class="built_in">std</span>::move(a));<span class="comment">//右值，调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用move后，原对象并非立即析构</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> b=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> c = <span class="built_in">std</span>::move(b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//B: 0x61fe10，move后b对象依旧在，只是内容为空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br><span class="line"><span class="built_in">std</span>::move(c);<span class="comment">//只是调用move而不进行移动构造或移动赋值，则原对象没有影响</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br></pre></td></tr></table></figure>
<h2>universal reference</h2>
<p>通用引用T&amp;&amp;不一定为右值引用，取决于<code>初始化</code>，以及是否发生<code>类型推导</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;<span class="comment">//T类型需要推导，T&amp;&amp;为通用引用</span></span><br><span class="line">fun(<span class="number">10</span>);<span class="comment">//param被右值10初始化</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">fun(x);<span class="comment">//param被左值x初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//const T&amp;&amp;不需要推导，为右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure>
<p>引用折叠：只有右值引用推导为右值引用时，得到的还是右值引用；否则将变为左值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ra=a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; aa = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//a,ra,aa均为左值，传入f()，T&amp;&amp;则为左值引用</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">f(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br><span class="line">f(<span class="built_in">std</span>::move(str));<span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br></pre></td></tr></table></figure>
<h2>Perfect Forwarding</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;fun(i);&#125;<span class="comment">//经过传递，临时对象i成为命名对象，内部调用①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;<span class="comment">//int&amp;&amp;类型确定，因此只能传递右值</span></span><br><span class="line">    fun(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));<span class="comment">//std::forward实现右值的完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">	fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">	fun(<span class="number">1</span>);<span class="comment">//右值，调用②</span></span><br><span class="line">	forward(<span class="number">2</span>);<span class="comment">//2传入forward内部后调用①，不完美的转发！</span></span><br><span class="line">	forward_value(<span class="number">3</span>);<span class="comment">//3传入内部后，std::forward确保调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述情况虽然使用forward可以将右值进行完美传递，但类型还是有局限性</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用引用+forward进行完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入右值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const右值时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfect_forward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T&gt;(t));<span class="comment">//使用forward但此时T类型不确定，则f()接收的是通用引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1>smart pointer</h1>
<p>侯捷的C++11视频缺失，但在<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14s411E772?p=17">📺</a> 中有所提及<br>
📖<a target="_blank" rel="noopener" href="https://simonfang1.github.io/blog/2018/08/23/smart-pointer/">https://simonfang1.github.io/blog/2018/08/23/smart-pointer/</a><br>
📖<a target="_blank" rel="noopener" href="http://www.cplusplus.com/reference/memory/auto_ptr/">http://www.cplusplus.com/reference/memory/auto_ptr/</a><br>
📖<a target="_blank" rel="noopener" href="https://interview.huihut.com/#/?id=%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">https://interview.huihut.com/#/?id=智能指针</a><br>
📖<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e4919f1c3a28">https://www.jianshu.com/p/e4919f1c3a28</a></p>
<h2>auto_ptr（C11弃用）</h2>
<ul>
<li>
<p>auto_ptr对象间赋值拷贝后所有权将被转移，且原来的指针将被<code>置空</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//auto_ptr以值传递方式作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;T&gt; tp)</span></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;T&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> T)</span></span>; </span><br><span class="line">	Fun(p);<span class="comment">//p传入时发生拷贝，此时p已经为nullptr</span></span><br><span class="line">	<span class="comment">//! p-&gt;xxx;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li>
<p>auto_ptr对象<code>仅使用delete</code>析构，无法管理数组</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! std::auto_ptr&lt;T&gt; p(new T[5]);</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>不能和标准容器一起使用</p>
</li>
</ul>
<h2>unique_ptr（代替auto_ptr）</h2>
<ul>
<li>
<p>不支持赋值拷贝，但可以使用<code>move</code>显式转移所有权</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line"><span class="comment">//! std::unique_ptr&lt;T&gt; p2 = p1;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>析构时可以delete，也可delete[]，因此可以管理数组</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">// delete p1</span></span><br><span class="line">std::unique_ptr&lt;T[]&gt; p2(new T[5]);//delete[] p2</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>release()</code>仅释放所有权，而<code>reset()</code>同时会释放资源</p>
</li>
</ul>
<h2>shared_ptr（基于<code>引用计数</code>实现）</h2>
<ul>
<li>
<p>多个shared_ptr指向同一对象时，共享一个引用计数器并记录shared_ptr实例数量</p>
</li>
<li>
<p>当最后一个指向对象的shared_ptr销毁时，会自动销毁其所指对象</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;<span class="comment">//直接创建</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);<span class="comment">//make_shared高效创建</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>use_count()</code>方法得到强引用计数值</p>
</li>
<li>
<p>默认使用delete析构，析构数组需显式指定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式指定delete[]析构</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T[<span class="number">5</span>],[](T* p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>避免不同的share_ptr指向同一资源</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;<span class="comment">//p1计数1，p1析构后销毁p</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">//p2计数1，p2析构时p已经被销毁</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>循环引用问题</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	A():m_sptrB(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">	~A()&#123;&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	B():m_sptrA(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">	~B()&#123;&#125;</span><br><span class="line">	<span class="built_in">shared_ptr</span>&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA计数1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB计数1</span></span><br><span class="line">	pA-&gt;m_sptrB = pB;<span class="comment">//m_sptrB引用pB，pB计数2，pA析构后计数1</span></span><br><span class="line">	pB-&gt;m_sptrA = pA;<span class="comment">//m_sptrA引用pA，pA计数2，pB析构后计数1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>多线程情况🔗<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c75a0d33655c">https://www.jianshu.com/p/c75a0d33655c</a></p>
<ul>
<li>共享指针本身的<code>引用计数</code>操作是<code>原子的</code>，不会有内存泄漏</li>
<li>对共享指针内部封装的<code>原始指针</code>进行操作时，则<code>需要加锁</code></li>
<li>当同时读写同一个共享指针时，不能确定<code>编译器操作引用计数和原始指针的先后顺序</code></li>
</ul>
<p>解决方法：运用weak_ptr检测指针是否被释放，有两种方法：</p>
<ol>
<li>使用<strong>weak_ptr.lock</strong>函数得到一个shared_ptr指针，如果已经释放返回空</li>
<li>直接使用weak_ptr.expired()来判断一个指针是否被释放</li>
</ol>
</li>
</ul>
<h2>weak_ptr（解决循环引用问题）</h2>
<ul>
<li>
<p>指向shared_ptr管理的对象，但不会增减<code>强引用</code>计数器</p>
</li>
<li>
<p>调用<code>expired()</code>比调用<code>use_count()</code>方法速度更快，以确定是否指向有效资源</p>
</li>
<li>
<p>调用<code>lock()</code>将weak_ptr转型为share_ptr</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">//直接创建share_ptr，强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;T&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;<span class="comment">//使用share_ptr创建weak_ptr，弱引用计数1，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;T&gt; wp2 = wp1;<span class="comment">//使用weak_ptr创建weak_ptr，弱引用计数2，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp2 = wp2.lock();<span class="comment">//将weak_ptr转型为share_ptr</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>解决循环引用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	weak_ptr&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的weak_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintpB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_sptrB.expired())<span class="comment">//弱引用B有效，则lock为强引用</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; m_sptrB.lock( )-&gt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	weak_ptr&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的weak_ptr</span></span><br><span class="line">	<span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA强引用计数1</span></span><br><span class="line">	<span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB强引用计数1</span></span><br><span class="line">	pA-&gt;m_sptrB = pB;<span class="comment">//弱引用m_sptrB引用pB，pB强引用计数1，弱引用计数1，pA析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">	pB-&gt;m_sptrA = pA;<span class="comment">//弱引用m_sptrA引用pA，pA强引用计数1，弱引用计数1，pB析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">	pA-&gt;PrintpB(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1>面试补充</h1>
<h2>shared_ptr初始化unique_ptr?</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp=make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; u=make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// unique_ptr&lt;int&gt; up=move(sp);！！！编译错误</span></span><br><span class="line"><span class="comment">//不存在用户定义的从 &quot;std::shared_ptr&lt;int&gt;&quot; 到 </span></span><br><span class="line"><span class="comment">//&quot;std::unique_ptr&lt;int, std::default_delete&lt;int&gt;&gt;&quot; 的适当转换</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up=move(u);</span><br></pre></td></tr></table></figure>
<h2>手撕智能指针</h2>
<p>🔗<a target="_blank" rel="noopener" href="https://blog.csdn.net/yanchenzhi/article/details/107591037">https://blog.csdn.net/yanchenzhi/article/details/107591037</a></p>
<h3>unique_ptr</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针，智能指针内部包含的普通指针</span></span><br><span class="line">    <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    UniquePtr(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//禁止赋值</span></span><br><span class="line">    UniquePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造方法，使用普通指针初始化，默认值nullptr</span></span><br><span class="line">    UniquePtr(T* p=<span class="literal">nullptr</span>):m_p(p)&#123;&#125;;</span><br><span class="line">    ~UniquePtr()<span class="comment">//析构函数，delete指针释放资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            m_p=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3>shared_ptr</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针</span></span><br><span class="line">    <span class="keyword">int</span>* count;<span class="comment">//int指针指向共享的计数值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造，计数0(nullptr)，普通指针根据具体类型T*置为0，nullptr</span></span><br><span class="line">    SharedPtr():count(<span class="number">0</span>),m_p((T*)<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">//使用普通指针构造，时刻注意count是指针，因此new int</span></span><br><span class="line">    SharedPtr(T* p):count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)),m_p(p)&#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="comment">//1.参数p同样为shared_ptr，因此需要取p.m_p裸指针赋值</span></span><br><span class="line">    <span class="comment">//2.拷贝后，参数p的引用计数++，count先指向参数的count</span></span><br><span class="line">    <span class="comment">//可以直接在初始化形参列表中：count(&amp;(++ *p.count))</span></span><br><span class="line">    <span class="comment">//先p.count取得参数的int计数指针</span></span><br><span class="line">    <span class="comment">//再*操作取得计数的值，并++</span></span><br><span class="line">    <span class="comment">//最后&amp;操作取得参数计数指针的地址，并赋值给count</span></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p):count(p.count),m_p(p.m_p)</span><br><span class="line">    &#123;</span><br><span class="line">        ++(*count);<span class="comment">//*取count值后++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载赋值=运算符</span></span><br><span class="line">    <span class="comment">//1.赋值m_p</span></span><br><span class="line">    <span class="comment">//2.赋值count</span></span><br><span class="line">    <span class="comment">//由于是将参数所在的指针赋给当前指针，因此当前指针的引用计数需要--，而参数指针的计数++</span></span><br><span class="line">    <span class="comment">//因此还需判断当前指针计数，为零则需析构</span></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果自赋值，直接返回本身*this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;p) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//参数指针的引用计数++，p.count获取参数的int指针，*取引用计数的值，最后++</span></span><br><span class="line">        ++(*(p.count));</span><br><span class="line">        <span class="comment">//是否析构</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;<span class="comment">//此时析构并不置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行赋值操作</span></span><br><span class="line">        count = p.count;</span><br><span class="line">        m_p = p.m_p;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">    <span class="comment">//析构，计数为0时才析构，否则计数值--即可</span></span><br><span class="line">    ~SharedPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_p为空则不需要操作</span></span><br><span class="line">        <span class="comment">//否则先--count，如果不为零也不需要操作</span></span><br><span class="line">        <span class="comment">//否则析构，释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回引用计数值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *count;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:vae.xusong.cn@gmail.com">Vae</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/">https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://vae1997.github.io" target="_blank">许嵩的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a></div><div class="post_share"><div class="social-share" data-image="/../images/common/2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"><img class="prev-cover" src="/../images/common/3.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Hexo配置记录</div></div></a></div><div class="next-post pull-right"><a href="/2020/09/24/Hexo+Github/"><img class="next-cover" src="/../images/common/1.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Hexo+Github搭建博客踩坑记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/09/25/C++知识点记录/" title="C++知识点记录"><img class="cover" src="/../images/common/4.png"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-25</div><div class="title">C++知识点记录</div></div></a></div></div></div></article></main><footer id="footer" style="background-image: url(/../images/common/2.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By Vae</div><div class="footer_custom_text">音樂純粹，愛V絕對！😄</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>