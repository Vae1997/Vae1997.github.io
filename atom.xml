<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>许嵩的博客</title>
  
  
  <link href="https://vae1997.github.io/atom.xml" rel="self"/>
  
  <link href="https://vae1997.github.io/"/>
  <updated>2020-09-24T11:38:33.722Z</updated>
  <id>https://vae1997.github.io/</id>
  
  <author>
    <name>Vae</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++11特性总结记录</title>
    <link href="https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-09-24T11:36:34.760Z</published>
    <updated>2020-09-24T11:38:33.722Z</updated>
    
    <content type="html"><![CDATA[<p><code>B站侯捷C++11</code><a href="https://www.bilibili.com/video/BV1p4411v7Dh?from=search&seid=11158986983875788976">:tv:</a></p><h1 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h1><p>通过编译器自动获取变量类型，:warning:常在类型长/复杂(lambda)的情况下使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin();<span class="comment">//迭代器类型vector&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;···&#125;;<span class="comment">//获取lambda的返回类型</span></span><br></pre></td></tr></table></figure><h1 id="default-amp-delete"><a href="#default-amp-delete" class="headerlink" title="=default &amp; =delete"></a>=default &amp; =delete</h1><p>:book:<a href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html">https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html</a></p><p>简单理解为：</p><ul><li>=default：需要用编译器默认生成的（Big-Three）特殊成员函数</li><li>=delete：禁止使用当前修饰的函数</li></ul><h2 id="default"><a href="#default" class="headerlink" title="=default"></a>=default</h2><ul><li>类中的特殊成员函数（构造、析构、拷贝、赋值）显式定义后，编译器默认生成的将失效</li><li>若仍需使用默认的函数，则必须显式定义，<code>增加编码工作量</code></li><li>此外，显式定义的函数<code>效率低于</code>编译器自动生成的</li><li>:warning:可在类外定义，但只能修饰类的特殊成员函数，且该函数没有默认参数</li></ul><h2 id="delete"><a href="#delete" class="headerlink" title="=delete"></a>=delete</h2><ul><li>为禁止类对象之间的拷贝、赋值，或禁用不期望的转换和操作符</li><li>:warning:适用于普通函数，若修饰成员函数则只能在类中定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//inline default</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;<span class="comment">//delete只能在类中定义</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>=<span class="keyword">delete</span>;<span class="comment">//普通函数也可delete</span></span><br><span class="line">    <span class="keyword">virtual</span> ~A();</span><br><span class="line">&#125;;</span><br><span class="line">A::~A()=<span class="keyword">default</span>;<span class="comment">//Out-of-line default</span></span><br></pre></td></tr></table></figure><h1 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h1><p>简单理解为：用于获取对象类型</p><ul><li>用于说明返回类型：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// decltype(x+y)add(T1 x, T2 y); add函数返回类型为x+y的返回类型</span></span><br><span class="line"><span class="comment">//但是x+y先于声明，编译无法通过，因此使用如下方法</span></span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x+y);//使用-&gt;，指定add函数的返回类型</span><br></pre></td></tr></table></figure></li><li>用于模板中：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj为容器，则获取类型后可以进一步获取相关属性</span></span><br><span class="line"><span class="keyword">decltype</span>(obj)::iterator</span><br></pre></td></tr></table></figure></li><li>获取lambda表达式的类型：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义用于对象比较的lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp=[](<span class="keyword">const</span> Obj&amp; obj1, <span class="keyword">const</span> Obj&amp; obj2)&#123;<span class="keyword">return</span> ···&#125;;</span><br><span class="line"><span class="comment">//在set中根据cmp比较对象大小</span></span><br><span class="line">std::set&lt;Obj, decltype(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure></li></ul><h1 id="initialization"><a href="#initialization" class="headerlink" title="initialization"></a>initialization</h1><p>C++11之前初始化可以使用（）、{ }、=，C11提出一致使用{ }进行初始化</p><p>:warning:编译器看到{ }，实际生成的是initializer_list<T>，即<code>初始化列表</code></p><p>:warning:初始化列表背后关联<code>array&lt;T,n&gt;</code>容器（仅包含array的头部指针），并将容器中的值挨个传递到<code>构造函数</code></p><p>:warning:如果构造函数的参数本身就是initializer_list<T>，则整体直接传递，不再进行拆解</p><h2 id="initializer-list"><a href="#initializer-list" class="headerlink" title="initializer_list"></a>initializer_list</h2><p>使用{ }设置默认初值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;<span class="comment">//j为int，默认0</span></span><br><span class="line"><span class="keyword">int</span>* p;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;;<span class="comment">//q为int*，默认nullptr</span></span><br><span class="line"><span class="keyword">char</span> c&#123;<span class="number">99999</span>&#125;;<span class="comment">//原则上不可以，根据编译器而定error/warning</span></span><br></pre></td></tr></table></figure><p>initializer_list<T>作为函数参数，接收任意个T类型的参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span>;</span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);<span class="comment">//必须使用&#123; &#125;传参</span></span><br></pre></td></tr></table></figure><h1 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h1><p>可以简单当作是inline函数，格式如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ⅰ] (Ⅱ) <span class="keyword">mutable</span> <span class="keyword">throw</span> -&gt; retType &#123;Ⅲ&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[]：导入器，捕获外部变量，传值(默认)/传引用</p></li><li><p>()：参数，当需要传参，或指定mutable、throw、retType之一时，则必须有</p></li><li><p>mutable：决定[]中的值是否可以进行修改，可选</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [id]()<span class="keyword">mutable</span>&#123;<span class="comment">//id为值传递，指定mutable则内部可以修改id值</span></span><br><span class="line">    <span class="comment">//但注意此时，id作为0传递进来</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;;</span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line">f1();<span class="comment">//调用lambda，值传递传入的id为0，但不影响外面的id值42</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;id]()<span class="keyword">mutable</span>&#123;···&#125;;<span class="comment">//传引用，则lambda内部的id和外部“共享”</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=,&amp;id]&#123;···&#125;;<span class="comment">//除id外的其余变量均为默认的值传递，没有mutable不能进行修改</span></span><br></pre></td></tr></table></figure></li><li><p>throw：抛出异常，可选</p></li><li><p>retType：返回类型，可选</p></li></ul><p>:warning:默认情况下，<code>lambda函数总是一个const函数</code>，mutable可以取消其常量性</p><h1 id="rvalue-references"><a href="#rvalue-references" class="headerlink" title="rvalue references"></a>rvalue references</h1><p>:book:<a href="https://www.cnblogs.com/qicosmos/p/3369940.html">https://www.cnblogs.com/qicosmos/p/3369940.html</a></p><p>:book:<a href="https://www.cnblogs.com/qicosmos/p/3376241.html">https://www.cnblogs.com/qicosmos/p/3376241.html</a></p><p>:book:<a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html">https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html</a></p><p>:book:<a href="https://segmentfault.com/a/1190000016041544">https://segmentfault.com/a/1190000016041544</a> (<strong>更为详细全面</strong>)</p><ul><li><p>减少不必要的对象拷贝；使泛函定义更简洁</p></li><li><p>实现移动语义（Move Sementics）和完美转发（Perfect Forwarding）</p></li></ul><h2 id="lvalue-amp-rvalue"><a href="#lvalue-amp-rvalue" class="headerlink" title="lvalue &amp; rvalue"></a>lvalue &amp; rvalue</h2><ul><li><p>左值：表达式结束后依然存在的<code>持久化对象</code></p></li><li><p>右值：常表现为<code>临时对象</code>，只在当前语句中有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = get_a();<span class="comment">//a为左值，非引用返回的get_a()返回的临时变量为右值（纯右值）</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">std</span>::move(a);<span class="comment">//通过move返回的右值（将亡值）</span></span><br></pre></td></tr></table></figure></li><li><p>区分方法：若可对表达式<code>用 &amp; 符取址</code>，则为左值，否则为右值</p></li><li><p>右值也可以被修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T()生成临时对象（右值），并将对象内部的变量通过set方法进行修改</span></span><br><span class="line">T().<span class="built_in">set</span>().get();</span><br></pre></td></tr></table></figure><h2 id="lvalue-references-amp-rvalue-references"><a href="#lvalue-references-amp-rvalue-references" class="headerlink" title="lvalue references &amp; rvalue references"></a>lvalue references &amp; rvalue references</h2></li><li><p>左值赋值左值引用（变量别名），右值赋值右值引用（临时变量的别名，生命周期延长）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; refa = a;<span class="comment">//左值引用refa，只能被左值a赋值，refa为左值</span></span><br><span class="line"><span class="comment">//！int&amp; b = 1; 左值引用b不能被右值1赋值</span></span><br><span class="line"><span class="comment">//！int&amp;&amp; b = a; 右值引用b不能被左值a赋值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; b = <span class="number">1</span>;<span class="comment">//右值引用b，只能被右值1赋值，但注意此时b本身为左值</span></span><br></pre></td></tr></table></figure></li><li><p>const lvalue references</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span>;<span class="comment">//const左值引用可以接收右值</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Move-Sementics"><a href="#Move-Sementics" class="headerlink" title="Move Sementics"></a>Move Sementics</h2><ul><li><p>对于右值的拷贝和赋值会调用<code>移动构造函数</code>和<code>移动赋值操作符</code></p></li><li><p>若没有定义，则<code>拷贝构造函数</code>和<code>拷贝赋值操作符</code>会被调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造，若没有移动构造，当参数使用move或传递右值时，由于拷贝构造参数为const T&amp;，因此才会接受右值进行调用</span></span><br><span class="line">MyString(<span class="keyword">const</span> MyString&amp; str): _len(str._len) &#123;</span><br><span class="line">    _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">   _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动构造，当vector/deque扩容时，移动构造使用noexcept确保成功扩容</span></span><br><span class="line"><span class="comment">//str需要修改，因此不加const，但需要noexcept（表明一定不会发生异常）</span></span><br><span class="line">MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span> : _len(str._len) &#123;</span><br><span class="line">    _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">    str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">    str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">        str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">        str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通的函数和操作符也可以利用右值引用操作符实现转移语义</p></li></ul><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><ul><li>希望将左值转为右值：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">fun(<span class="built_in">std</span>::move(a));<span class="comment">//右值，调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用move后，原对象并非立即析构</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> b=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> c = <span class="built_in">std</span>::move(b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//B: 0x61fe10，move后b对象依旧在，只是内容为空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br><span class="line"><span class="built_in">std</span>::move(c);<span class="comment">//只是调用move而不进行移动构造或移动赋值，则原对象没有影响</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br></pre></td></tr></table></figure><h2 id="universal-reference"><a href="#universal-reference" class="headerlink" title="universal reference"></a>universal reference</h2><p>通用引用T&amp;&amp;不一定为右值引用，取决于<code>初始化</code>，以及是否发生<code>类型推导</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;<span class="comment">//T类型需要推导，T&amp;&amp;为通用引用</span></span><br><span class="line">fun(<span class="number">10</span>);<span class="comment">//param被右值10初始化</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">fun(x);<span class="comment">//param被左值x初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//const T&amp;&amp;不需要推导，为右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure><p>引用折叠：只有右值引用推导为右值引用时，得到的还是右值引用；否则将变为左值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ra=a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; aa = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//a,ra,aa均为左值，传入f()，T&amp;&amp;则为左值引用</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">f(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br><span class="line">f(<span class="built_in">std</span>::move(str));<span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br></pre></td></tr></table></figure><h2 id="Perfect-Forwarding"><a href="#Perfect-Forwarding" class="headerlink" title="Perfect Forwarding"></a>Perfect Forwarding</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;fun(i);&#125;<span class="comment">//经过传递，临时对象i成为命名对象，内部调用①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;<span class="comment">//int&amp;&amp;类型确定，因此只能传递右值</span></span><br><span class="line">    fun(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));<span class="comment">//std::forward实现右值的完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">fun(<span class="number">1</span>);<span class="comment">//右值，调用②</span></span><br><span class="line">forward(<span class="number">2</span>);<span class="comment">//2传入forward内部后调用①，不完美的转发！</span></span><br><span class="line">forward_value(<span class="number">3</span>);<span class="comment">//3传入内部后，std::forward确保调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述情况虽然使用forward可以将右值进行完美传递，但类型还是有局限性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用引用+forward进行完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入右值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const右值时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfect_forward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T&gt;(t));<span class="comment">//使用forward但此时T类型不确定，则f()接收的是通用引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="smart-pointer"><a href="#smart-pointer" class="headerlink" title="smart pointer"></a>smart pointer</h1><p>侯捷的C++11视频缺失，但在<a href="https://www.bilibili.com/video/BV14s411E772?p=17">:tv:</a> 中有所提及<br>:book:<a href="https://simonfang1.github.io/blog/2018/08/23/smart-pointer/">https://simonfang1.github.io/blog/2018/08/23/smart-pointer/</a><br>:book:<a href="http://www.cplusplus.com/reference/memory/auto_ptr/">http://www.cplusplus.com/reference/memory/auto_ptr/</a><br>:book:<a href="https://interview.huihut.com/#/?id=%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">https://interview.huihut.com/#/?id=%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88</a><br>:book:<a href="https://www.jianshu.com/p/e4919f1c3a28">https://www.jianshu.com/p/e4919f1c3a28</a></p><h2 id="auto-ptr（C11弃用）"><a href="#auto-ptr（C11弃用）" class="headerlink" title="auto_ptr（C11弃用）"></a>auto_ptr（C11弃用）</h2><ul><li><p>auto_ptr对象间赋值拷贝后所有权将被转移，且原来的指针将被<code>置空</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//auto_ptr以值传递方式作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;T&gt; tp)</span></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;T&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> T)</span></span>; </span><br><span class="line">Fun(p);<span class="comment">//p传入时发生拷贝，此时p已经为nullptr</span></span><br><span class="line"><span class="comment">//! p-&gt;xxx;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>auto_ptr对象<code>仅使用delete</code>析构，无法管理数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! std::auto_ptr&lt;T&gt; p(new T[5]);</span></span><br></pre></td></tr></table></figure></li><li><p>不能和标准容器一起使用</p></li></ul><h2 id="unique-ptr（代替auto-ptr）"><a href="#unique-ptr（代替auto-ptr）" class="headerlink" title="unique_ptr（代替auto_ptr）"></a>unique_ptr（代替auto_ptr）</h2><ul><li><p>不支持赋值拷贝，但可以使用<code>move</code>显式转移所有权</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line"><span class="comment">//! std::unique_ptr&lt;T&gt; p2 = p1;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>析构时可以delete，也可delete[]，因此可以管理数组</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">// delete p1</span></span><br><span class="line">std::unique_ptr&lt;T[]&gt; p2(new T[5]);//delete[] p2</span><br></pre></td></tr></table></figure></li><li><p><code>release()</code>仅释放所有权，而<code>reset()</code>同时会释放资源</p></li></ul><h2 id="shared-ptr（基于引用计数实现）"><a href="#shared-ptr（基于引用计数实现）" class="headerlink" title="shared_ptr（基于引用计数实现）"></a>shared_ptr（基于<code>引用计数</code>实现）</h2><ul><li><p>多个shared_ptr指向同一对象时，共享一个引用计数器并记录shared_ptr实例数量</p></li><li><p>当最后一个指向对象的shared_ptr销毁时，会自动销毁其所指对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;<span class="comment">//直接创建</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);<span class="comment">//make_shared高效创建</span></span><br></pre></td></tr></table></figure></li><li><p><code>use_count()</code>方法得到强引用计数值</p></li><li><p>默认使用delete析构，析构数组需显式指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式指定delete[]析构</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T[<span class="number">5</span>],[](T* p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>避免不同的share_ptr指向同一资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;<span class="comment">//p1计数1，p1析构后销毁p</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">//p2计数1，p2析构时p已经被销毁</span></span><br></pre></td></tr></table></figure></li><li><p><code>循环引用问题</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A():m_sptrB(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~A()&#123;&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B():m_sptrA(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~B()&#123;&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA计数1</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB计数1</span></span><br><span class="line">pA-&gt;m_sptrB = pB;<span class="comment">//m_sptrB引用pB，pB计数2，pA析构后计数1</span></span><br><span class="line">pB-&gt;m_sptrA = pA;<span class="comment">//m_sptrA引用pA，pA计数2，pB析构后计数1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多线程情况:link:<a href="https://www.jianshu.com/p/c75a0d33655c">https://www.jianshu.com/p/c75a0d33655c</a></p><ul><li>共享指针本身的<code>引用计数</code>操作是<code>原子的</code>，不会有内存泄漏</li><li>对共享指针内部封装的<code>原始指针</code>进行操作时，则<code>需要加锁</code></li><li>当同时读写同一个共享指针时，不能确定<code>编译器操作引用计数和原始指针的先后顺序</code></li></ul><p>解决方法：运用weak_ptr检测指针是否被释放，有两种方法：</p><ol><li>使用<strong>weak_ptr.lock</strong>函数得到一个shared_ptr指针，如果已经释放返回空</li><li>直接使用weak_ptr.expired()来判断一个指针是否被释放</li></ol></li></ul><h2 id="weak-ptr（解决循环引用问题）"><a href="#weak-ptr（解决循环引用问题）" class="headerlink" title="weak_ptr（解决循环引用问题）"></a>weak_ptr（解决循环引用问题）</h2><ul><li><p>指向shared_ptr管理的对象，但不会增减<code>强引用</code>计数器</p></li><li><p>调用<code>expired()</code>比调用<code>use_count()</code>方法速度更快，以确定是否指向有效资源</p></li><li><p>调用<code>lock()</code>将weak_ptr转型为share_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">//直接创建share_ptr，强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;T&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;<span class="comment">//使用share_ptr创建weak_ptr，弱引用计数1，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;T&gt; wp2 = wp1;<span class="comment">//使用weak_ptr创建weak_ptr，弱引用计数2，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp2 = wp2.lock();<span class="comment">//将weak_ptr转型为share_ptr</span></span><br></pre></td></tr></table></figure></li><li><p>解决循环引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">weak_ptr&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的weak_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintpB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_sptrB.expired())<span class="comment">//弱引用B有效，则lock为强引用</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; m_sptrB.lock( )-&gt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">weak_ptr&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的weak_ptr</span></span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB强引用计数1</span></span><br><span class="line">pA-&gt;m_sptrB = pB;<span class="comment">//弱引用m_sptrB引用pB，pB强引用计数1，弱引用计数1，pA析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">pB-&gt;m_sptrA = pA;<span class="comment">//弱引用m_sptrA引用pA，pA强引用计数1，弱引用计数1，pB析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">pA-&gt;PrintpB(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="面试补充"><a href="#面试补充" class="headerlink" title="面试补充"></a>面试补充</h1><h2 id="shared-ptr初始化unique-ptr"><a href="#shared-ptr初始化unique-ptr" class="headerlink" title="shared_ptr初始化unique_ptr?"></a>shared_ptr初始化unique_ptr?</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp=make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; u=make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// unique_ptr&lt;int&gt; up=move(sp);！！！编译错误</span></span><br><span class="line"><span class="comment">//不存在用户定义的从 &quot;std::shared_ptr&lt;int&gt;&quot; 到 </span></span><br><span class="line"><span class="comment">//&quot;std::unique_ptr&lt;int, std::default_delete&lt;int&gt;&gt;&quot; 的适当转换</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up=move(u);</span><br></pre></td></tr></table></figure><h2 id="手撕智能指针"><a href="#手撕智能指针" class="headerlink" title="手撕智能指针"></a>手撕智能指针</h2><p>:link:<a href="https://blog.csdn.net/yanchenzhi/article/details/107591037">https://blog.csdn.net/yanchenzhi/article/details/107591037</a></p><h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针，智能指针内部包含的普通指针</span></span><br><span class="line">    <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    UniquePtr(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//禁止赋值</span></span><br><span class="line">    UniquePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造方法，使用普通指针初始化，默认值nullptr</span></span><br><span class="line">    UniquePtr(T* p=<span class="literal">nullptr</span>):m_p(p)&#123;&#125;;</span><br><span class="line">    ~UniquePtr()<span class="comment">//析构函数，delete指针释放资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            m_p=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针</span></span><br><span class="line">    <span class="keyword">int</span>* count;<span class="comment">//int指针指向共享的计数值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造，计数0(nullptr)，普通指针根据具体类型T*置为0，nullptr</span></span><br><span class="line">    SharedPtr():count(<span class="number">0</span>),m_p((T*)<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">//使用普通指针构造，时刻注意count是指针，因此new int</span></span><br><span class="line">    SharedPtr(T* p):count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)),m_p(p)&#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="comment">//1.参数p同样为shared_ptr，因此需要取p.m_p裸指针赋值</span></span><br><span class="line">    <span class="comment">//2.拷贝后，参数p的引用计数++，count先指向参数的count</span></span><br><span class="line">    <span class="comment">//可以直接在初始化形参列表中：count(&amp;(++ *p.count))</span></span><br><span class="line">    <span class="comment">//先p.count取得参数的int计数指针</span></span><br><span class="line">    <span class="comment">//再*操作取得计数的值，并++</span></span><br><span class="line">    <span class="comment">//最后&amp;操作取得参数计数指针的地址，并赋值给count</span></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p):count(p.count),m_p(p.m_p)</span><br><span class="line">    &#123;</span><br><span class="line">        ++(*count);<span class="comment">//*取count值后++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载赋值=运算符</span></span><br><span class="line">    <span class="comment">//1.赋值m_p</span></span><br><span class="line">    <span class="comment">//2.赋值count</span></span><br><span class="line">    <span class="comment">//由于是将参数所在的指针赋给当前指针，因此当前指针的引用计数需要--，而参数指针的计数++</span></span><br><span class="line">    <span class="comment">//因此还需判断当前指针计数，为零则需析构</span></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果自赋值，直接返回本身*this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;p) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//参数指针的引用计数++，p.count获取参数的int指针，*取引用计数的值，最后++</span></span><br><span class="line">        ++(*(p.count));</span><br><span class="line">        <span class="comment">//是否析构</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;<span class="comment">//此时析构并不置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行赋值操作</span></span><br><span class="line">        count = p.count;</span><br><span class="line">        m_p = p.m_p;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">    <span class="comment">//析构，计数为0时才析构，否则计数值--即可</span></span><br><span class="line">    ~SharedPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_p为空则不需要操作</span></span><br><span class="line">        <span class="comment">//否则先--count，如果不为零也不需要操作</span></span><br><span class="line">        <span class="comment">//否则析构，释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回引用计数值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *count;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;B站侯捷C++11&lt;/code&gt;&lt;a href=&quot;https://www.bilibili.com/video/BV1p4411v7Dh?from=search&amp;seid=11158986983875788976&quot;&gt;:tv:&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;au</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建博客踩坑记录</title>
    <link href="https://vae1997.github.io/2020/09/24/Hexo+Github/"/>
    <id>https://vae1997.github.io/2020/09/24/Hexo+Github/</id>
    <published>2020-09-24T07:48:18.315Z</published>
    <updated>2020-09-24T09:15:27.652Z</updated>
    
    <content type="html"><![CDATA[<p>参考链接:<a href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程</a></p><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li><p>安装git和nodejs，并在github创建仓库</p></li><li><p>以管理员权限打开cmd，并执行<code>npm install -g hexo-cli</code>安装hexo客户端</p></li><li><p>在需要创建博客的目录下执行<code>hexo init blog</code></p></li><li><p><code>cd blog</code>并执行<code>npm install</code></p></li><li><p>编辑blog/_config.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;Vae1997&#x2F;Vae1997.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>执行<code>npm install hexo-deployer-git --save</code>，确保可以找到git命令</p></li><li><p>此时执行<code>hexo g -d</code>后即可访问<a href="https://vae1997.github.io/">https://vae1997.github.io/</a></p></li><li><p>可执行如下命令避免每次提交时都需要输入用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Vae1997&quot;</span><br><span class="line">git config --global user.email &quot;844821239@qq.com&quot;</span><br></pre></td></tr></table></figure></li></ol><h2 id="个性化配置"><a href="#个性化配置" class="headerlink" title="个性化配置"></a>个性化配置</h2><h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><p>使用<a href="https://demo.jerryc.me/posts/21cfbf15/">Butterfly</a>主题</p><ol><li><code>npm i hexo-theme-butterfly</code></li><li>编辑blog/_config.yml文件：修改<code>theme: butterfly</code></li><li><code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></li></ol><p>主题文件夹路径：blog\node_modules\hexo-theme-butterfly</p><h2 id="踩坑记录"><a href="#踩坑记录" class="headerlink" title="踩坑记录"></a>踩坑记录</h2><h3 id="误提交大于100M的文件"><a href="#误提交大于100M的文件" class="headerlink" title="误提交大于100M的文件"></a>误提交大于100M的文件</h3><p>执行hexo d后出现：this exceeds GitHub’s file size limit of 100.00 MB</p><p>需退回上一次的提交：参考<a href="https://ztygcs.github.io/posts/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4github%E6%8A%A5%E9%94%99/">大文件上传致Github报错</a></p><ol><li><code>cd blog/.deploy_git</code></li><li><code>git log</code>查看上次提交</li><li>复制第一个commit后的代码，执行<code>git reset xxxxx</code></li><li>再次查看提交记录，已经回滚到上一次</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考链接:&lt;a href=&quot;https://cloud.tencent.com/developer/article/1520557&quot;&gt;这可能是迄今为止最全的hexo博客搭建教程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;操作步骤&quot;&gt;&lt;a href=&quot;#操作步骤&quot; class=&quot;hea</summary>
      
    
    
    
    
  </entry>
  
</feed>
