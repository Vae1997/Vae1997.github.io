<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>许嵩的博客</title>
  <icon>https://www.gravatar.com/avatar/0f37be44c33d1c7c2846a570c1c7a15b</icon>
  
  <link href="https://vae1997.github.io/atom.xml" rel="self"/>
  
  <link href="https://vae1997.github.io/"/>
  <updated>2020-09-25T08:32:52.796Z</updated>
  <id>https://vae1997.github.io/</id>
  
  <author>
    <name>Vae</name>
    <email>vae.xusong.cn@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++知识点记录</title>
    <link href="https://vae1997.github.io/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>https://vae1997.github.io/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-25T08:14:50.000Z</published>
    <updated>2020-09-25T08:32:52.796Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>🔗<a href="https://light-city.club/sc/">c++那些事</a>、<a href="https://interview.huihut.com/#/">interview</a></p><h1>从cpp到exe</h1><p>🔗<a href="https://www.cnblogs.com/mhq-martin/p/11898245.html">https://www.cnblogs.com/mhq-martin/p/11898245.html</a></p><p>🔗<a href="https://my.oschina.net/u/920274/blog/3126740/print">https://my.oschina.net/u/920274/blog/3126740/print</a></p><table><thead><tr><th>过程</th><th>编写源程序</th><th>预编译</th><th>编译</th><th>汇编</th><th>链接</th></tr></thead><tbody><tr><td>文件后缀</td><td>.cpp</td><td>.i</td><td>.s</td><td>.o</td><td>.exe</td></tr></tbody></table><h2>预编译</h2><ul><li>展开头文件：将<code>#include</code>中指定的代码写入当前文件</li><li>宏替换：将源程序中使用宏定义<code>#define</code>修饰的宏名称，替换为对应的字符串文本</li><li>条件编译：根据<a href="https://blog.csdn.net/ForestRound/article/details/52717968">C++条件编译</a>指令<code>#ifndef</code>等，判断将要进行编译的代码块，<code>防止头文件被重复引用</code></li><li>去掉注释：将<code>//</code>或<code>/**/</code>内容忽略</li></ul><p>预编译结束后，生成的文件后缀<code>.i</code></p><h2>编译</h2><ul><li>根据<code>编译原理</code>那一套，检查代码规范性、是否有语法错误等（词法、语法、语义分析+优化）</li><li>接着将.i文件编译，生成一个用汇编语言描述的<code>.s</code>文件</li></ul><p>⚠️此处只进行编译生成汇编代码，而不真正的进行汇编</p><h2>汇编</h2><ul><li>把.s文件翻译成二进制机器指令<code>.o</code>文件</li></ul><p>⚠️直接打开将乱码，使用反汇编工具才可以读懂</p><h2>链接</h2><ul><li>链接所有的函数、全局变量，将所有的.o文件链接成一个可执行文件</li></ul><p>⚠️当.o文件太多，链接不方便，因此将常用/共享的.o目标文件打包，就出现了静/动态链接库</p><h3>静态库和动态库</h3><p>🔗<a href="https://www.cnblogs.com/skynet/p/3372855.html">https://www.cnblogs.com/skynet/p/3372855.html</a></p><p>Windows下为.lib和.dll文件，Linux下为.a和.so文件</p><p>静态链接库：</p><ul><li>链接时将汇编生成的目标文件 .o 与引用的库（函数库等）一起链接打包到可执行文件中，<code>体积大</code></li><li>程序运行时，与函数库再无关联，因此<code>移植性好</code></li><li>不同程序链接相同的静态库，因此内存中有多份拷贝，<code>浪费资源空间</code></li><li>当静态库进行更新，则所有链接静态库的程序均需要重新编译链接（<code>全量更新</code>）</li></ul><p>动态链接库：</p><ul><li>程序编译为可执行文件后，可执行文件并未链接需要的函数库，<code>体积小</code></li><li>只有当程序开始运行时，才会搜索文件系统，将需要的函数库动态加载进来（<code>移植性差</code>）</li><li>不同程序可以共享一份动态库，<code>节省资源空间</code></li><li>只需要进行动态库本身的更新，程序不需要改动（<code>增量更新</code>）</li></ul><h1>程序内存分配</h1><p>🔗<a href="https://blog.csdn.net/u010594850/article/details/25512269">https://blog.csdn.net/u010594850/article/details/25512269</a></p><p>🔗<a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p><p><img src="/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/20180122125137873.png" alt="程序内存"></p><p>Linux 系统中的<code>每个段</code>都是从 0 地址开始的整个 <code>4GB 虚拟空间</code>（32 位环境下），内核1G+用户空间3G</p><p>用户空间中的3G虚拟地址空间，地址从低到高依次被分配为：</p><ul><li><p>程序代码区：存放函数体（成员函数、全局函数）编译后的二进制可执行代码，只读（注意地址并非从0x0开始）</p></li><li><p>常量区：存放=（赋值符号）右边的立即数、字面量、字符串常量等（右值），只读，🚨和const修饰与否无关！</p></li><li><p>全局数据区：存放全局变量、静态变量，程序运行期间一直存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证环境vscode，gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)</span></span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> e;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="string">&quot;　&quot;</span>&lt;&lt;&amp;d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;e&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//0x403010 0x403014 0x403018　0x407030 0x40703c 0x407034</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> g;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;g&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;h&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//0x407040 0x40301c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局数据区内，初始化的变量位于低地址，未初始化的位于高地址</li><li>所有初始化的全局变量（无论static）按照定义先后顺序，向着地址增长的方向存放</li><li><code>未初始化的全局变量，static全局变量和普通全局变量地址也是分开的</code>，目前来看中间隔了8个字节</li><li><code>未初始化的普通全局变量位于低地址，而static在高地址</code>，两部分也分别按照定义先后顺序，地址向上增长</li></ul></li><li><p>堆：包括<code>动态分配的内存</code>，从低地址开始向上增长</p></li><li><p>文件映射段：包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</p></li><li><p>栈：包括<code>局部变量</code>和<code>函数调用的上下文</code>等，栈的大小是固定的，一般是 <code>8 MB</code>，可配置修改，<code>地址向下增长</code></p></li></ul><h2>堆和栈的区别</h2><p>申请方式：</p><ul><li>堆由new/delete，malloc/free等方法动态分配，容易出现内存泄漏</li><li>栈由系统自动分配（⚠️栈区的内存空间也可使用alloca动态分配，但会自动释放）</li></ul><p>申请后系统的响应：</p><ul><li>栈只要剩余空间大于申请空间，即可分配，直到异常提示栈溢出</li></ul><blockquote><p>操作系统有一个记录空闲内存地址的链表</p></blockquote><ul><li>堆申请时遍历空闲链表，找到首个满足分配大小的内存块进行分配，并从空闲链表中删除<ul><li>如果分配的内存块有剩余，则将剩余部分加入空闲链表</li><li>分配的内存首地址一般记录分配的大小，delete时才能正确释放</li></ul></li></ul><p>申请大小限制：栈的大小一般较小，而堆32位理论可分配4G</p><p>生长方向：栈向下（地址下降），堆向上（地址上升）</p><p>碎片化：栈每次分配连续的内存，无碎片问题；堆如果频繁new/delete势必造成内存不连续，产生大量碎片</p><p>分配效率：栈的分配往往对应CPU指令级别的操作，效率高；堆往往由库函数提供分配方法，效率低</p><h2><a href="https://www.cnblogs.com/lfri/p/12593582.html">对象创建的两种方式</a></h2><ul><li>静态建立：<code>A a;</code><ul><li>对象分配在<code>栈空间</code></li><li>编译器移动栈顶指针腾出空间，再<code>直接调用构造函数</code>创建对象</li><li>对象生命结束，编译器调用析构函数释放栈空间</li></ul></li><li>动态建立：<code>A* a = new A();</code><ul><li>执行<code>operator new()</code>函数，在<code>堆空间</code>中寻找内存分配</li><li>调用构造函数，在分配的内存中创建对象</li></ul></li></ul><blockquote><p>C++是静态绑定语言，编译器管理了对象的整个生命周期</p></blockquote><p>🔗<a href="https://blog.csdn.net/qq_40840459/article/details/80079608">https://blog.csdn.net/qq_40840459/article/details/80079608</a></p><h3>只在栈上生成对象的类</h3><ul><li><code>将new和delete操作符重载为私有</code></li><li>此时使用new创建对象，编译器无法进行访问</li></ul><h3>只在堆上生成对象的类</h3><ul><li><code>将析构函数设为私有</code>，最好设为protected，确保多态时正常执行父类的虚析构函数</li><li>此时使用静态创建对象，编译器无法进行访问</li></ul><p>⚠️此时需要单独定义一个函数，执行delete进行内存空间的释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;      <span class="comment">// 注意函数的第一个参数和返回值都是固定的   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125;  <span class="comment">// 重载了new就需要重载delete     </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">destory</span><span class="params">()</span></span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;  </span><br><span class="line"><span class="keyword">protected</span> :  </span><br><span class="line">    <span class="keyword">virtual</span> ~B()&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;<span class="comment">//0x61fe2f</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//!!! A* a2 = new A();             //函数 &quot;A::operator delete&quot; 不可访问</span></span><br><span class="line">    <span class="comment">//!!! B b;                         //&quot;B::~B() noexcept&quot; 不可访问</span></span><br><span class="line">    B* b = <span class="keyword">new</span> B();<span class="comment">//0x7c1700</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    b-&gt;destory();</span><br><span class="line">    C c1;<span class="comment">//0x61fe20</span></span><br><span class="line">    C* c2 = <span class="keyword">new</span> C();<span class="comment">//0x7c1700</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;c1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2>new/delete和malloc/free区别</h2><p>🔗<a href="https://www.cnblogs.com/qg-whz/p/5140930.html">https://www.cnblogs.com/qg-whz/p/5140930.html</a></p><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center">new/delete</th><th style="text-align:center">malloc/free</th></tr></thead><tbody><tr><td style="text-align:center">分配内存的位置</td><td style="text-align:center">自由存储区(C++基于new的概念)</td><td style="text-align:center">堆(C/操作系统的概念)</td></tr><tr><td style="text-align:center">内存分配成功返回值</td><td style="text-align:center">完整类型指针</td><td style="text-align:center">void*，一般需要强制转换为需要的类型</td></tr><tr><td style="text-align:center">内存分配失败返回值</td><td style="text-align:center">默认抛出bac_alloc异常</td><td style="text-align:center">返回NULL</td></tr><tr><td style="text-align:center">分配内存的大小</td><td style="text-align:center">由编译器根据类型计算得出</td><td style="text-align:center">必须显式指定字节数</td></tr><tr><td style="text-align:center">处理数组</td><td style="text-align:center">有处理数组的new[]和delete[]</td><td style="text-align:center">需要用户计算数组的大小后进行内存分配</td></tr><tr><td style="text-align:center">已分配内存的扩充</td><td style="text-align:center">无法直观地处理</td><td style="text-align:center">使用realloc简单完成</td></tr><tr><td style="text-align:center">是否相互调用</td><td style="text-align:center">可以，operator new/delete实现底层调用malloc/free</td><td style="text-align:center">不可调用new</td></tr><tr><td style="text-align:center">分配内存时内存不足</td><td style="text-align:center">客户能够指定处理函数或重新制定分配器</td><td style="text-align:center">无法通过用户代码进行处理</td></tr><tr><td style="text-align:center">函数重载</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center">构造函数与析构函数</td><td style="text-align:center">调用</td><td style="text-align:center">不调用</td></tr></tbody></table><p>有了malloc为什么还需要new？</p><ul><li>对于<code>非内部数据类型的对象</code>而言，用maloc/free无法满足动态对象的要求</li><li>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数</li><li>由malloc/free是库函数而不是运算符，不在编译器控制权限之内</li></ul><h1>内存对齐</h1><p>🔗<a href="https://zhuanlan.zhihu.com/p/101140160">https://zhuanlan.zhihu.com/p/101140160</a></p><p>🔗<a href="https://www.jianshu.com/p/49ddb946a226">https://www.jianshu.com/p/49ddb946a226</a></p><p>对齐：内存中数据首地址是CPU单次获取数据大小的整数倍</p><p>目的</p><ul><li><p>平台原因(移植原因)：代码移植时硬件平台不同，内存地址不能随便访问</p></li><li><p>性能原因：加快CPU寻址，确保一次访问内存就能获取到完整的数据</p></li></ul><p><code>#pragma pack(n)</code>：设定结构体、联合以及类成员变量以 n 字节方式对齐</p><p>关于该指令其他用法，参考<a href="https://www.jianshu.com/p/90a6eef329ec">#pragma pack 指令详解</a></p><h2>sizeof()</h2><p>⚠️运算符/关键字，判断数据类型或者表达式长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2>对齐规则</h2><ul><li><p>基本类型的对齐值就是其sizeof值</p></li><li><p>数据成员对齐规则：结构(struct)(或联合(union))的数据成员</p><ul><li>第一个数据成员放在offset为0的地方</li><li>以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行</li></ul></li><li><p>结构(或联合)的整体对齐规则：</p><ul><li>数据成员完成各自对齐</li><li>结构(或联合)本身也要进行对齐</li><li>对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行;</li></ul></li></ul><p>关于共用体和结构体，参考<a href=":link:https://juejin.im/post/6844904022877405191">C语言中关于sizeof(struct)和sizeof(union)</a></p><p>关于虚函数、虚继承，参考<a href="https://blog.csdn.net/fuhuixin7497/article/details/78198287">c++普通继承、虚继承、虚函数对sizeof的影响</a></p><p>关于位域的sizeof，参考<a href="http://blog.chinaunix.net/uid-20726927-id-2455478.html">含位域结构体的sizeof</a>、<a href="https://www.cnblogs.com/zlcxbb/p/6803059.html">C/C++ 位域知识小结</a></p><h1>面向对象特性</h1><p>封装：将事物抽象为类，对不可信的类/对象隐藏自身属性/方法，使得代码模块化</p><p>继承：使用现有类的全部功能，并在不改动原有类的前提下对功能进行扩展</p><p>多态：不同对象调用同一个方法而表现出不同的行为</p><h1>C++类访问控制</h1><p><a href="https://blog.csdn.net/shuzfan/article/details/68954774">https://blog.csdn.net/shuzfan/article/details/68954774</a></p><table><thead><tr><th></th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>类成员是否可以访问</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>友元是否可以访问</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>子类是否可以访问</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>类的实例化对象是否可以访问</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>public继承</td><td>public</td><td>protected</td><td>private</td></tr><tr><td>protected继承</td><td>protected</td><td>protected</td><td>private</td></tr><tr><td>private继承</td><td>private</td><td>private</td><td>private</td></tr></tbody></table><h1><a href="%5Bhttps://www.fa1c0n.cn/2020/03/08/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91-%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%8D%E5%90%88%E3%80%81%E5%A7%94%E6%89%98%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%5D(https://www.fa1c0n.cn/2020/03/08/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91-%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%8D%E5%90%88%E3%80%81%E5%A7%94%E6%89%98%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)">C++类间关系</a></h1><p>🔗<a href="https://www.jianshu.com/p/4d2e63e71a07">https://www.jianshu.com/p/4d2e63e71a07</a></p><p>🔗<a href="https://www.cnblogs.com/narutow/p/8117352.html">https://www.cnblogs.com/narutow/p/8117352.html</a></p><h2>继承</h2><p>从内存的角度上讲，子类拥有父类的成员变量，对于成员函数来说，继承代表子类拥有函数的调用权</p><p>变量的初始化顺序：</p><ul><li><p>基类的静态变量或全局变量按照定义</p></li><li><p>派生类的静态变量或全局变量按照定义</p></li><li><p>基类的成员变量</p></li><li><p>派生类的成员变量</p></li></ul><h2>Composition 组合</h2><p>当一个类中<code>包含另外一个类对象</code>时，可称为组合</p><ul><li>构造由内而外：先调用包含的那个类的构造方法，在调用自身的构造</li><li>析构由外而内：先调用自身析构，再调用内部包含的</li></ul><p>⚠️创建对象时，两个类的对象同时会创建，因此两个类对象的生命周期是一致的</p><h3>组合+继承</h3><ul><li>子类继承父类，父类存在组合<ul><li>构造：组合的类构造=&gt;父类=&gt;子类</li><li>析构：子类析构=&gt;父类析构=&gt;组合类析构</li></ul></li><li>子类继承父类，子类存在组合<ul><li>构造：父类构造=&gt;组合类构造=&gt;子类</li><li>析构：子类析构=&gt;组合类析构=&gt;父类</li></ul></li></ul><h2>Delegation 委托</h2><p>Composition by reference：一个类中只记录另一个类的指针，并不是包含关系</p><ul><li>当前类只是将部分功能委托给另一个类实现</li><li>被委托的类对象，生命周期不被限制，等到需要用到的时候才去创建</li></ul><h3>委托+继承</h3><p>观察者模式的实现方式</p><ul><li>委托类即为观察目标</li><li>观察者抽象类即为被委托的父类</li><li>具体的观察者即为继承父类的子类</li></ul><p><img src="/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/image-20200807195739441.png" alt="观察者"></p><h1>C++对象模型</h1><p>🔗<a href="https://cloud.tencent.com/developer/article/1155155">https://cloud.tencent.com/developer/article/1155155</a></p><p><img src="/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt="对象模型"></p><h2>多态与虚表</h2><p>C++ 多态分类及实现：</p><ol><li>重载多态（编译期）：函数重载、运算符重载</li><li>参数多态（编译期）：类模板、函数模板</li><li>强制多态（编译期/运行期）：基本类型转换、自定义类型转换</li><li>子类多态（运行期）：虚函数，由于在运行期间才能确定，因此为<code>动态多态</code></li></ol><p>虚函数：用 virtual 修饰的<code>非静态成员函数</code></p><ul><li>static修饰的函数在对象构造之前已经存在，不能为虚函数</li><li>构造函数出现在对象生成之前，因此不能为虚函数</li><li>析构函数指定为虚函数，当析构发生了多态的对象时（父类指针指向子类），正常调用子类析构函数，防止内存泄漏</li></ul><p>🚨当没有虚函数时，父类指针可以指向子类，🔗<a href="https://blog.csdn.net/FX677588/article/details/77727110">https://blog.csdn.net/FX677588/article/details/77727110</a></p><ul><li>基类指针指向子类，该指针只能访问基类方法（静态绑定）</li><li>子类指针指向基类，必须先做强制转型动作（不建议）</li><li>基类和子类定义了同名成员函数，指针类型是谁就调用谁</li></ul><p><code>如果编译器能明确知道调用的是哪个虚函数，则不用查虚表，直接调用</code></p><h2>虚指针、虚表存放位置</h2><p>🔗<a href="https://cloud.tencent.com/developer/article/1394319">https://cloud.tencent.com/developer/article/1394319</a></p><ul><li>虚指针：一般在对象内存的起始位置，即就是对象的地址（32位占4字节），保证多层/多重继承下获得虚表效率高</li><li>虚表：应用程序的常量区，虚指针指向的地址（首个虚函数地址）</li></ul><h2>非继承</h2><ul><li>非静态数据成员：位于每一个对象内存中</li><li>静态数据成员、静态成员函数、非静态成员函数：位于对象内存之外</li><li>虚函数：虚指针指向的虚函数表</li></ul><p>虚函数表：</p><ul><li>每个具有虚函数的类，和类绑定（所有该类对象<code>共用一个虚表</code>）</li><li>表中按照虚函数在类中的<code>定义顺序</code>，依次存放对应的指向虚函数地址的指针</li><li>虚函数表之前设置一个指向type_info的指针，用以支持RTTI（运行时类型识别），用于描述对象继承关系等</li></ul><p>虚表指针：</p><ul><li>每个对象都有虚表指针(vptr)，由编译器为其生成</li></ul><h2>单继承</h2><ul><li>子类和父类各拥有自己的虚函数表</li><li>子类若<code>重写父类的虚函数</code>，则子类虚函数将<code>覆盖虚表中对应的父类虚函数</code></li><li>若子类声明自己<code>新的虚函数</code>，则该虚函数地址将<code>扩充到虚函数表最后</code></li></ul><h2>多继承</h2><ul><li>子类<code>新增的虚函</code>数被放在声明的<code>第一个基类</code>的虚函数表中</li><li>发生<code>重写</code>时，<code>所有基类</code>的虚函数都被子类<code>覆盖</code></li><li>内存布局中，<code>父类按照其声明顺序排列</code></li></ul><h2>虚继承</h2><p>虚继承解决了菱形继承中<code>最派生类</code>拥有<code>多个间接父类实例</code>的情况</p><ul><li><p>虚继承的子类也<code>保留父类的vprt与虚函数表</code>，与子类内容<code>以一个四字节的0</code>来分界</p></li><li><p>若发生虚函数<code>重写</code>，同样地将<code>覆盖</code>父类中的虚函数表对应位置</p></li><li><p>若声明<code>新的虚函数</code>，则编译器将为子类增加一个<code>新的虚表指针vptr</code>，对应新的虚函数表</p></li></ul><p>虚继承中的子类，生成一个隐藏的<code>虚基类指针</code>， 指向<code>虚基类表</code>，存放的是<strong>偏移值</strong></p><p>偏移值：</p><ul><li>第一个条目存放<code>虚基类指针所在地址</code>到该类<code>对象内存首地址</code>的偏移值</li><li>如果有虚函数指针，值为-4；否则为0</li><li>其余条目为该类的<code>最左</code>虚继承父类、<code>次左</code>虚继承父类…的内存地址<code>相对于虚基类指针</code>的偏移值</li></ul><h2>菱形虚继承</h2><ul><li>在子类对象内存中，基类出现的顺序是：<code>最左父类、次左父类、虚祖父类</code></li><li>子类对象的<code>数据成员放在虚祖父类前面</code>，两部分数据依旧以<code>0来分隔</code></li><li>子类<code>覆盖并扩展最左父类的虚函数表</code>，与简单继承的对象模型相同</li><li>虚祖父类的内容放到了子类对象内存布局的最后</li></ul><h1>指针VS引用</h1><p><a href="https://cloud.tencent.com/developer/article/1021622">https://cloud.tencent.com/developer/article/1021622</a></p><ul><li><p>指针有自己的大小（32位4字节），而引用只是一个别名（汇编角度也占内存），sizeof是被引用对象的大小</p></li><li><p>指针可以被初始化为NULL，而引用必须声明时初始化</p></li><li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，引用不发生拷贝</p></li><li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变</p></li><li><p>指针可以有多级指针（**p），而引用至于一级</p></li><li><p>指针++指向下一个地址，引用++则是对被引用对象++</p></li></ul><h1>++i VS i++</h1><p>++i 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">int</span>::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i++ 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">int</span>::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> oldValue = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/19811087">https://www.zhihu.com/question/19811087</a></p><p>i++ 最后返回的是一个临时变量，而<strong>临时变量是右值</strong></p><h2>效率</h2><p>🔗<a href="https://blog.51cto.com/genwoxuevc/499483">https://blog.51cto.com/genwoxuevc/499483</a></p><ul><li>对于基本类型，效率无差异</li><li>对于自定义类型，++i更好，返回对象的引用，无拷贝开销</li></ul><h2>线程安全</h2><p>线程不安全，非原子操作</p><h1>宏</h1><h2>#include</h2><p>#include&lt; &gt;：引用的是编译器的<code>类库路径里面的头文件</code>，一般是引用自带的一些头文件</p><p>#include&quot; &quot;：引用的是程序目录的<code>相对路径中的头文件</code>，一般是用来引用自己写的一些头文件</p><p>⚠️使用 #include&quot; &quot; 先在项目当前目录查找是否有对应头文件，如果没有再去类库路径下找</p><h2>#define</h2><p>🔗<a href="https://www.cnblogs.com/zhizhiyu/p/10155614.html">https://www.cnblogs.com/zhizhiyu/p/10155614.html</a></p><p>不带参数的宏定义：#define 宏名 字符串</p><ul><li><p>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义</p></li><li><p>预处理阶段进行展开和替换，因此<code>不做语法检查</code></p></li><li><p>可以用#undef命令终止宏定义的作用域</p></li><li><p>宏定义<code>不分配内存</code></p></li></ul><p>带参数的宏定义：#define 宏名（参数表） 字符串</p><ul><li><p>宏名和参数的括号间不能有空格</p></li><li><p>宏替换只作替换，不做计算，不做表达式求解</p></li><li><p>宏展开不占运行时间，只占编译时间</p></li></ul><p>宏比较大小：<code> #define MIN(A,B)  ((A)&lt;=(B)?(A):(B))</code></p><h1>const</h1><h2>const和#define区别</h2><p>🔗<a href="https://blog.csdn.net/love_gaohz/article/details/7567856">https://blog.csdn.net/love_gaohz/article/details/7567856</a></p><ul><li>const有具体类型，<code>分配内存</code>；宏定义没有，仅仅是展开，不分配内存</li><li>const编译期间进行<code>类型检查</code>；宏定义位于预处理阶段，没有类型检查</li><li>const在内存中只有<code>一份拷贝</code>；宏定义在替换后会出现多个拷贝</li></ul><p>⚠️编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，没有存储与读内存的操作，效率很高</p><h2>基本说明</h2><ul><li><p>const普通变量<code>当且仅当</code>在定义的时候进行初始化，一旦初始化之后就不能被再次赋值</p></li><li><p>const成员变量只能在<code>初始化形参列表</code>中进行初始化操作</p></li><li><p>const可用于对重载函数的区分</p></li><li><p>const成员函数内部不能修改类的任何成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>🔴同时存在同名的const和非const成员函数时</p><ul><li>const对象只能调用const成员函数</li><li>非const只能调用非const成员函数</li></ul><h2>修饰指针和引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line"><span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line"><span class="keyword">const</span> A* p = &amp;a;            <span class="comment">// 指针变量，指向常对象，即指向的对象不能变，指针本身可以变</span></span><br><span class="line">A* <span class="keyword">const</span> p = &amp;b;            <span class="comment">// 常量指针，即指针本身不能变，但可以指向不同对象</span></span><br><span class="line"><span class="keyword">const</span> A&amp; q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向的字符char不可改变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，p3指针自身不可改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量，都不能变</span></span><br></pre></td></tr></table></figure><p>⚠️主要判断const后面修饰的对象，如果是类型(int/class)即指向的对象不可变；如为变量名称即为指针/引用本身不能变</p><h3>const多级指针</h3><p>🔗<a href="https://blog.csdn.net/SoYangA/article/details/80292025">https://blog.csdn.net/SoYangA/article/details/80292025</a></p><ul><li>一级指针<ul><li><code> const int* p</code>：p指向的int型数不能变</li><li><code>int const *p</code>：同上，p指向的int型数不能变（可认为修饰*p，其中*表示取值，即为int型数）</li><li><code>int* const p</code>：p指针本身不可变</li><li><code>const int* const p</code>：p指针本身不可变，p指向的int型数也不能变</li></ul></li><li>二级指针<ul><li><code>const int** p</code>：p指向的int型数不能变</li><li><code>int** const p</code>：二级指针p本身不可变</li><li><code>int* const *p</code>：二级指针p指向的一级指针*p本身不可变</li><li><code>const int* const * const p</code>：一级指针*p，二级指针p，指向的值均不可变</li></ul></li></ul><h2>修饰函数参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br></pre></td></tr></table></figure><p>⚠️<code>const int&amp;</code>常引用作为函数参数，既避免了参数的拷贝，又避免了函数内部对实参值的修改</p><h2>修饰函数返回值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">f6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = f6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">f7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = f7();</span></span><br></pre></td></tr></table></figure><h1>extern “C”</h1><p>作用：编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理（按照 C 语言方式编译和链接）</p><ul><li>可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题</li></ul><p><a href="https://cloud.tencent.com/developer/article/1496000">关于extern</a></p><p>修饰的变量或函数，表示在其他文件中定义</p><p>关键字extern用于扩展变量和函数的可见性。</p><p>由于函数默认存在extern,不需要再定义和声明的时候使用extern。</p><p>当变量使用extern时，它只是声明没有定义。</p><p>当变量用extern声明并且有初始化时，和变量的定义一样</p><h1>inline</h1><p>作用：减少函数调用时的消耗，是否对函数内联，决定权在于编译器</p><ul><li><p>一般不内联包含循环、递归、switch 等复杂操作的内联函数</p></li><li><p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</p></li></ul><p>编译器处理步骤：</p><ol><li>将 inline 函数体复制到 inline 函数调用点处</li><li>为所用 inline 函数中的局部变量分配内存空间</li><li>将 inline 函数的输入参数和返回值映射到调用方法的局部变量空间中</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）</li></ol><p>优点</p><ul><li><p>在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度</p></li><li><p>在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会</p></li><li><p>内联函数在运行时可调试，而宏定义不可以</p></li></ul><p>缺点</p><ul><li><p>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p></li><li><p>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接</p></li></ul><p>虚函数内联：当虚函数表现多态性的时候不能内联</p><h1>static</h1><p><a href="https://blog.csdn.net/cc198877/article/details/8844729">https://blog.csdn.net/cc198877/article/details/8844729</a></p><p>修饰局部对象：延长局部对象生命周期（直到程序结束）</p><p>修饰全局对象：限制全局对象的作用域（仅在本文件内访问）</p><p>修饰普通变量：</p><ul><li>声明时未赋初值，编译器根据类型会自动初始化</li><li>生命周期直到程序运行结束，不随函数运行结束而结束</li><li>只在当前文件可见（多人开发防止重名）</li></ul><p>修饰成员变量：</p><ul><li><p>只能在类外通过类名初始化<code>int A::a = 1;</code></p></li><li><p>只有一个拷贝（和类绑定），一个对象的修改会影响其他对象（可以理解为共享）</p><p>⚠️因为对象共享静态成员变量，因此<code>不能使用构造函数初始化</code>静态成员变量</p></li><li><p>一般通过<code>A::a</code>进行访问，也可以使用对象访问</p></li><li><p>可以作为成员函数的默认参数，但是普通的数据成员不行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> z=y)</span></span>&#123;&#125;  <span class="comment">//可以，但是int z=x不行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>修饰普通函数：只在当前文件可见（多人开发防止重名）</p><p>修饰成员函数：</p><ul><li><p>函数内部只能访问类的静态成员（变量/函数），但可以通过对象来引用非静态成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x):s(x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(A&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a.s;<span class="comment">//通过引用对象来操作非静态成员</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;s;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    A::f(a);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>⚠️<code>非静态成员函数</code>可以<code>任意访问静态成员</code></p></li><li><p>一般通过<code>A::f()</code>进行访问，也可以使用对象访问</p></li></ul><h2>static成员函数this？</h2><p>无this，static修饰后和类绑定，而this和对象绑定</p><h2>static成员函数virtual？</h2><p>不可以，因为static编译期间就确定，virtual运行时才动态绑定</p><h1>this</h1><p>指针，指向<code>调用非静态成员函数</code>的对象</p><ol><li>先将对象的地址赋给this指针</li><li>this指针作为非静态成员函数的<code>隐含参数</code>传递（由编译器完成）</li><li>函数内部对成员变量操作时，都隐式使用this指针</li></ol><p>this类型：</p><ul><li>this指针被隐含地声明为: <code>ClassName* const this</code>，this指针本身不能变</li><li>当调用const成员函数时，this指针的类型为：<code>const ClassName* const</code>，表明指针本身和指向的对象均不能改变</li></ul><p>⚠️this是右值，不能取地址</p><p>需要显式使用this指针：</p><ol><li>为实现对象的链式引用</li><li>为避免对同一对象进行赋值操作</li><li>在实现一些数据结构时，如list</li></ol><h1>friend</h1><p><a href="https://blog.csdn.net/u012796139/article/details/46404401">https://blog.csdn.net/u012796139/article/details/46404401</a></p><p>友元函数：本身是普通的函数，在类外定义</p><ul><li>在类中通过friend修饰，类外通过对象访问类中的成员</li></ul><p>友元成员函数：本身是成员函数，在另一个类中指定为友元函数</p><p>友元类：在类中使用friend修饰另一个类为友元类</p><ul><li>在友元类中可以访问当前类中的成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//可在A中访问B的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//可在类外的普通函数中访问B的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::vfa</span><span class="params">()</span></span>;<span class="comment">//将A的虚函数指定为B的友元函数，该方法中可对B私有成员修改</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::f</span><span class="params">()</span></span>;<span class="comment">//将A的成员函数指定为B的友元函数，该方法中可对B私有成员修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>delete this</h2><p>🔗<a href="https://blog.csdn.net/u010013164/article/details/38713083">https://blog.csdn.net/u010013164/article/details/38713083</a></p><p>🔗<a href="http://blog.sina.com.cn/s/blog_4b4cf2af0100ywgv.html#commonComment">http://blog.sina.com.cn/s/blog_4b4cf2af0100ywgv.html#commonComment</a></p><p>构造函数中delete this：</p><ul><li>A a；试图delete一个未经new得到的指针，崩溃</li><li>A* a = new A；合法</li></ul><p>析构函数中delete this：</p><ul><li>delete先调用析构，再释放内存</li><li>析构中又delete，因此无限递归调用，栈溢出</li></ul><p>在成员函数中delete this合法，但：</p><ol><li>保证this对象是通过 <code>new</code>分配的（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h1>4种强制类型转换</h1><h2>C类型转换</h2><p><code>TYPE b = (TYPE) a</code>，可进行任意类型转换</p><ul><li>转换不明确，不能进行错误检查，易出错</li></ul><h2>static_cast</h2><p>静态类型转换</p><p>静态：在<code>编译期间就可以决定</code>，使用率最高</p><ul><li><p>用于各种隐式转换，比如非const转const，void*转指针等</p></li><li><p>不执行运行时类型检查（转换安全性不如 dynamic_cast）</p></li><li><p>通常用于转换数值数据类型（如 float -&gt; int）</p></li><li><p>可以在整个类层次结构中移动指针</p><ul><li>子类转化为父类安全（向上转换）</li><li>父类转化为子类虽然成功，但不安全（因为子类可能有不在父类的字段或方法）</li></ul></li></ul><h2>dynamic_cast</h2><p>用于多态类型的转换，<code>执行行运行时类型检查</code></p><ul><li>只适用于指针或引用<ul><li>对不明确的<code>指针</code>的转换将失败，返回 <code>nullptr</code></li><li>对不明确的<code>引用</code>的转换将失败，引发<code>bad_cast异常</code></li></ul></li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h2>const_cast</h2><p>用于删除 const、volatile 和 __unaligned 特性</p><ul><li>目标类类型只能是指针或引用</li></ul><h2>reinterpret_cast</h2><p><code>数据的二进制形式重新解释</code>，但不改变其值，其本身并不安全，不建议使用</p><ul><li>滥用 reinterpret_cast 运算符可能很容易带来风险</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性</li><li>reinterpret_cast 的一个实际用途是在哈希函数中<ul><li>通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引</li></ul></li></ul><h1>重载/隐藏/重写覆盖</h1><p><a href="https://cloud.tencent.com/developer/article/1177174">https://cloud.tencent.com/developer/article/1177174</a></p><h1>STL</h1><p><a href="https://www.bilibili.com/video/BV1db411q7B8?p=3">侯捷STL</a></p><p>🔗<a href="https://blog.csdn.net/u012370255/article/details/40541499">https://blog.csdn.net/u012370255/article/details/40541499</a></p><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td><td>定长数组</td><td>O(1)查询</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td><td>变长数组</td><td>尾部插入/删除O(1)其余O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td><td>双端队列</td><td>头尾插入/删除 O(1)其余O(n)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><p>🔗<a href="https://blog.csdn.net/Virtual_Func/article/details/49724135">https://blog.csdn.net/Virtual_Func/article/details/49724135</a></p><p>🔴无法存放引用类型</p><h2>Array（C11）</h2><p>数组：定长数组，初始化开辟空间后就不能改动</p><h2>Vector</h2><p>变长数组，堆中开辟连续内存</p><p>使用三个指针确定空间范围：首、尾、容量大小</p><h3>resize()和reserve()</h3><ul><li><code>resize</code>：增加容器的size和capacity</li><li><code>reserve</code>：方法仅进行扩容</li></ul><h2>模拟Vector</h2><p><a href="https://blog.csdn.net/shanghx_123/article/details/86662085">https://blog.csdn.net/shanghx_123/article/details/86662085</a></p><ol><li>私有成员为三个普通指针：start、finish、end</li><li>begin返回start，end返回finish</li><li>size返回finish-start，capacity返回end-start</li><li>重载[]运算符，返回start[pos]</li><li>实现erase：将删除位置pos之后的数据向前覆盖，返回pos指针</li><li>析构：delete[] start;再将三个指针置空</li><li>实现reserve：开辟新空间n，赋值所有数据，重新定位三个指针</li><li>实现resize：<ul><li>如果n小于size，调整finish=start+n</li><li>如果n大于capacity，调用reserve(n)</li><li>否则调整finish指针，新位置和旧位置之间使用参数指定的值覆盖</li></ul></li><li>实现insert：<ul><li>如果元素已达到容量，则2倍扩容，重置pos=start+size</li><li>将pos之后的元素后移一位，在pos位置插入新元素</li></ul></li></ol><h2>map和unordered_map</h2><p>使用场景：</p><p>除了有顺序要求和有单词操作时间要求的场景下用map，其他场景都使用unordered_map</p><h1>面试补充</h1><h2>if else 和 switch case</h2><p>分支较多时，效率上：switch高</p><ul><li>if else 需要挨个判断，时间换空间，分支太多代码可读性差</li><li>switch case 则直接跳转到对应case执行，空间换时间，代码可读性好</li></ul><p>类型上：if 更灵活</p><ul><li>if else 判断条件为逻辑表达式，只要最终是bool类型即可</li><li>swatch case 表达式类型受限：枚举/整型（int、 short、 char 、 byte）</li></ul><h2>递归、迭代、遍历和循环</h2><ul><li>循环(loop)：最基础的概念, 所有重复的行为</li><li>递归(recursion)：在函数内<code>调用自身</code>, 将复杂情况逐步转化成基本情况</li><li>(数学)迭代(iterate)：在多次循环中逐步接近结果</li><li>(编程)迭代(iterate)：按<code>顺序访问线性结构</code>中的每一项，迭代器（顺序、线性）</li><li>遍历(traversal)：<code>按规则访问非线性结构</code>中的每一项，树的遍历（前中后为规则，非线性）</li></ul><p>迭代：轮番交替，并替代</p><p>循环：只是单一重复执行，中间没有替代操作</p><h2>堆栈溢出</h2><p>可能的原因</p><ul><li>递归深度：函数每次被调用时都会将局部数据（在函数内部定义的变量、参数、数组、对象等）放入栈中</li><li>局部变量：存放在栈，大数据结构的局部变量</li></ul><h2>二维数组行列遍历</h2><p>二维数组是按行存储的，按行遍历的效率更高 <a href="https://blog.csdn.net/weixin_40497678/article/details/80733915">参考链接1</a>、 <a href="https://blog.csdn.net/Shuffle_Ts/article/details/89420651">参考链接2</a></p><h2>抽象类和接口</h2><p>🔗<a href="https://blog.csdn.net/hanxueyu666/article/details/75712917">https://blog.csdn.net/hanxueyu666/article/details/75712917</a></p><p>能否取代？同名方法？</p><h2>字符串拼接效率</h2><h2>Union</h2><p>数据覆盖时，考虑大端小端</p><p><a href="https://blog.csdn.net/xiao3404/article/details/22276485">https://blog.csdn.net/xiao3404/article/details/22276485</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> T</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a;</span><br><span class="line">   <span class="keyword">char</span> b[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   T t;</span><br><span class="line">   t.a=<span class="number">0</span>;</span><br><span class="line">   t.b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   t.b[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;v.l is %d\n&quot;</span>,t.a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出513，分析：</p><ol><li>t.a=0；将int的4字节（32位）全赋值为0</li><li>t.b[0]=1；注意<code>小端存储</code>，首个字节8位二进制覆盖为0000 0001</li><li>t.b[1]=2；第二个8位覆盖为0000 0010</li><li>剩余2个字节的高地址依旧全0</li><li>因此此时，0000 0000 + 0000 0000 + 0000 0010 + 0000 0001</li><li>16进制数为201，10进制对应513</li></ol>]]></content>
    
    
    <summary type="html">记录C++面试基础知识点</summary>
    
    
    
    
    <category term="C++" scheme="https://vae1997.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置记录</title>
    <link href="https://vae1997.github.io/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://vae1997.github.io/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-25T06:00:12.000Z</published>
    <updated>2020-09-25T07:58:15.500Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>主题配置</h1><p>使用<a href="https://demo.jerryc.me/posts/21cfbf15/">Butterfly</a>主题</p><ol><li><code>npm i hexo-theme-butterfly</code></li><li>编辑blog/_config.yml文件：修改<code>theme: butterfly</code></li><li><code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></li></ol><p>主题文件夹路径：blog\node_modules\hexo-theme-butterfly</p><h1>加载emoji表情</h1><p>参考：<a href="https://hasaik.com/posts/9b280ea3.html">Hexo中使用emoji表情</a></p><p>在blog目录下执行安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure><p>配置博客配置文件，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    html: true</span><br><span class="line">    xhtmlOut: false</span><br><span class="line">    breaks: true</span><br><span class="line">    linkify: true</span><br><span class="line">    typographer: true</span><br><span class="line">    quotes: &#39;“”‘’&#39;</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">  anchors:</span><br><span class="line">    level: 2</span><br><span class="line">    collisionSuffix: &#39;v&#39;</span><br><span class="line">    permalink: false</span><br><span class="line">    permalinkClass: header-anchor</span><br><span class="line">    permalinkSymbol: ☀</span><br></pre></td></tr></table></figure><h1>插入图片</h1><p>参考：<a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片</a></p><p>安装插件：<code>npm install hexo-asset-image --save</code></p><p>配置Hexo：将<code>post_asset_folder</code>字段置为<code>true</code></p><p>编辑文件：/node_modules/hexo-asset-image/index.js，修改为如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用：<code>![替换文本](图片路径)</code>，测试效果如下：</p><p><img src="/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87.png" alt="测试图片"></p>]]></content>
    
    
    <summary type="html">记录Hexo博客相关配置</summary>
    
    
    
    
    <category term="Hexo" scheme="https://vae1997.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++11特性总结记录</title>
    <link href="https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-09-24T11:36:34.760Z</published>
    <updated>2020-09-25T06:43:21.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>📺<a href="https://www.bilibili.com/video/BV1p4411v7Dh?from=search&amp;seid=11158986983875788976">B站侯捷C++11</a></p><h1>auto</h1><p>通过编译器自动获取变量类型，⚠️常在类型长/复杂(lambda)的情况下使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin();<span class="comment">//迭代器类型vector&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;···&#125;;<span class="comment">//获取lambda的返回类型</span></span><br></pre></td></tr></table></figure><h1>=default &amp; =delete</h1><p>📖<a href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html">https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html</a></p><p>简单理解为：</p><ul><li>=default：需要用编译器默认生成的（Big-Three）特殊成员函数</li><li>=delete：禁止使用当前修饰的函数</li></ul><h2>=default</h2><ul><li>类中的特殊成员函数（构造、析构、拷贝、赋值）显式定义后，编译器默认生成的将失效</li><li>若仍需使用默认的函数，则必须显式定义，<code>增加编码工作量</code></li><li>此外，显式定义的函数<code>效率低于</code>编译器自动生成的</li><li>⚠️可在类外定义，但只能修饰类的特殊成员函数，且该函数没有默认参数</li></ul><h2>=delete</h2><ul><li>为禁止类对象之间的拷贝、赋值，或禁用不期望的转换和操作符</li><li>⚠️适用于普通函数，若修饰成员函数则只能在类中定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//inline default</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;<span class="comment">//delete只能在类中定义</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>=<span class="keyword">delete</span>;<span class="comment">//普通函数也可delete</span></span><br><span class="line">    <span class="keyword">virtual</span> ~A();</span><br><span class="line">&#125;;</span><br><span class="line">A::~A()=<span class="keyword">default</span>;<span class="comment">//Out-of-line default</span></span><br></pre></td></tr></table></figure><h1>decltype</h1><p>简单理解为：用于获取对象类型</p><ul><li>用于说明返回类型：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// decltype(x+y)add(T1 x, T2 y); add函数返回类型为x+y的返回类型</span></span><br><span class="line"><span class="comment">//但是x+y先于声明，编译无法通过，因此使用如下方法</span></span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x+y);//使用-&gt;，指定add函数的返回类型</span><br></pre></td></tr></table></figure><ul><li>用于模板中：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj为容器，则获取类型后可以进一步获取相关属性</span></span><br><span class="line"><span class="keyword">decltype</span>(obj)::iterator</span><br></pre></td></tr></table></figure><ul><li>获取lambda表达式的类型：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义用于对象比较的lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp=[](<span class="keyword">const</span> Obj&amp; obj1, <span class="keyword">const</span> Obj&amp; obj2)&#123;<span class="keyword">return</span> ···&#125;;</span><br><span class="line"><span class="comment">//在set中根据cmp比较对象大小</span></span><br><span class="line">std::set&lt;Obj, decltype(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure><h1>initialization</h1><p>C++11之前初始化可以使用（）、{ }、=，C11提出一致使用{ }进行初始化</p><p>⚠️编译器看到{ }，实际生成的是initializer_list<T>，即<code>初始化列表</code></T></p><p>⚠️初始化列表背后关联<code>array&lt;T,n&gt;</code>容器（仅包含array的头部指针），并将容器中的值挨个传递到<code>构造函数</code></p><p>⚠️如果构造函数的参数本身就是initializer_list<T>，则整体直接传递，不再进行拆解</T></p><h2>initializer_list</h2><p>使用{ }设置默认初值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;<span class="comment">//j为int，默认0</span></span><br><span class="line"><span class="keyword">int</span>* p;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;;<span class="comment">//q为int*，默认nullptr</span></span><br><span class="line"><span class="keyword">char</span> c&#123;<span class="number">99999</span>&#125;;<span class="comment">//原则上不可以，根据编译器而定error/warning</span></span><br></pre></td></tr></table></figure><p>initializer_list<T>作为函数参数，接收任意个T类型的参数</T></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span>;</span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);<span class="comment">//必须使用&#123; &#125;传参</span></span><br></pre></td></tr></table></figure><h1>lambda</h1><p>可以简单当作是inline函数，格式如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ⅰ] (Ⅱ) <span class="keyword">mutable</span> <span class="keyword">throw</span> -&gt; retType &#123;Ⅲ&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[]：导入器，捕获外部变量，传值(默认)/传引用</p></li><li><p>()：参数，当需要传参，或指定mutable、throw、retType之一时，则必须有</p></li><li><p>mutable：决定[]中的值是否可以进行修改，可选</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [id]()<span class="keyword">mutable</span>&#123;<span class="comment">//id为值传递，指定mutable则内部可以修改id值</span></span><br><span class="line">    <span class="comment">//但注意此时，id作为0传递进来</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;;</span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line">f1();<span class="comment">//调用lambda，值传递传入的id为0，但不影响外面的id值42</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;id]()<span class="keyword">mutable</span>&#123;···&#125;;<span class="comment">//传引用，则lambda内部的id和外部“共享”</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=,&amp;id]&#123;···&#125;;<span class="comment">//除id外的其余变量均为默认的值传递，没有mutable不能进行修改</span></span><br></pre></td></tr></table></figure></li><li><p>throw：抛出异常，可选</p></li><li><p>retType：返回类型，可选</p></li></ul><p>⚠️默认情况下，<code>lambda函数总是一个const函数</code>，mutable可以取消其常量性</p><h1>rvalue references</h1><p>📖<a href="https://www.cnblogs.com/qicosmos/p/3369940.html">https://www.cnblogs.com/qicosmos/p/3369940.html</a></p><p>📖<a href="https://www.cnblogs.com/qicosmos/p/3376241.html">https://www.cnblogs.com/qicosmos/p/3376241.html</a></p><p>📖<a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html">https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html</a></p><p>📖<a href="https://segmentfault.com/a/1190000016041544">https://segmentfault.com/a/1190000016041544</a> (<strong>更为详细全面</strong>)</p><ul><li><p>减少不必要的对象拷贝；使泛函定义更简洁</p></li><li><p>实现移动语义（Move Sementics）和完美转发（Perfect Forwarding）</p></li></ul><h2>lvalue &amp; rvalue</h2><ul><li><p>左值：表达式结束后依然存在的<code>持久化对象</code></p></li><li><p>右值：常表现为<code>临时对象</code>，只在当前语句中有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = get_a();<span class="comment">//a为左值，非引用返回的get_a()返回的临时变量为右值（纯右值）</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">std</span>::move(a);<span class="comment">//通过move返回的右值（将亡值）</span></span><br></pre></td></tr></table></figure></li><li><p>区分方法：若可对表达式<code>用 &amp; 符取址</code>，则为左值，否则为右值</p></li><li><p>右值也可以被修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T()生成临时对象（右值），并将对象内部的变量通过set方法进行修改</span></span><br><span class="line">T().<span class="built_in">set</span>().get();</span><br></pre></td></tr></table></figure></li></ul><h2>lvalue references &amp; rvalue references</h2><ul><li><p>左值赋值左值引用（变量别名），右值赋值右值引用（临时变量的别名，生命周期延长）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; refa = a;<span class="comment">//左值引用refa，只能被左值a赋值，refa为左值</span></span><br><span class="line"><span class="comment">//！int&amp; b = 1; 左值引用b不能被右值1赋值</span></span><br><span class="line"><span class="comment">//！int&amp;&amp; b = a; 右值引用b不能被左值a赋值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; b = <span class="number">1</span>;<span class="comment">//右值引用b，只能被右值1赋值，但注意此时b本身为左值</span></span><br></pre></td></tr></table></figure></li><li><p>const lvalue references</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span>;<span class="comment">//const左值引用可以接收右值</span></span><br></pre></td></tr></table></figure></li></ul><h2>Move Sementics</h2><ul><li><p>对于右值的拷贝和赋值会调用<code>移动构造函数</code>和<code>移动赋值操作符</code></p></li><li><p>若没有定义，则<code>拷贝构造函数</code>和<code>拷贝赋值操作符</code>会被调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造，若没有移动构造，当参数使用move或传递右值时，由于拷贝构造参数为const T&amp;，因此才会接受右值进行调用</span></span><br><span class="line">MyString(<span class="keyword">const</span> MyString&amp; str): _len(str._len) &#123;</span><br><span class="line">    _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">   _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动构造，当vector/deque扩容时，移动构造使用noexcept确保成功扩容</span></span><br><span class="line"><span class="comment">//str需要修改，因此不加const，但需要noexcept（表明一定不会发生异常）</span></span><br><span class="line">MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span> : _len(str._len) &#123;</span><br><span class="line">    _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">    str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">    str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">        str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">        str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通的函数和操作符也可以利用右值引用操作符实现转移语义</p></li></ul><h2>std::move</h2><ul><li>希望将左值转为右值：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">fun(<span class="built_in">std</span>::move(a));<span class="comment">//右值，调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用move后，原对象并非立即析构</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> b=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> c = <span class="built_in">std</span>::move(b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//B: 0x61fe10，move后b对象依旧在，只是内容为空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br><span class="line"><span class="built_in">std</span>::move(c);<span class="comment">//只是调用move而不进行移动构造或移动赋值，则原对象没有影响</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br></pre></td></tr></table></figure><h2>universal reference</h2><p>通用引用T&amp;&amp;不一定为右值引用，取决于<code>初始化</code>，以及是否发生<code>类型推导</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;<span class="comment">//T类型需要推导，T&amp;&amp;为通用引用</span></span><br><span class="line">fun(<span class="number">10</span>);<span class="comment">//param被右值10初始化</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">fun(x);<span class="comment">//param被左值x初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//const T&amp;&amp;不需要推导，为右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure><p>引用折叠：只有右值引用推导为右值引用时，得到的还是右值引用；否则将变为左值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ra=a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; aa = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//a,ra,aa均为左值，传入f()，T&amp;&amp;则为左值引用</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">f(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br><span class="line">f(<span class="built_in">std</span>::move(str));<span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br></pre></td></tr></table></figure><h2>Perfect Forwarding</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;fun(i);&#125;<span class="comment">//经过传递，临时对象i成为命名对象，内部调用①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;<span class="comment">//int&amp;&amp;类型确定，因此只能传递右值</span></span><br><span class="line">    fun(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));<span class="comment">//std::forward实现右值的完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">fun(<span class="number">1</span>);<span class="comment">//右值，调用②</span></span><br><span class="line">forward(<span class="number">2</span>);<span class="comment">//2传入forward内部后调用①，不完美的转发！</span></span><br><span class="line">forward_value(<span class="number">3</span>);<span class="comment">//3传入内部后，std::forward确保调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述情况虽然使用forward可以将右值进行完美传递，但类型还是有局限性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用引用+forward进行完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入右值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const右值时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfect_forward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T&gt;(t));<span class="comment">//使用forward但此时T类型不确定，则f()接收的是通用引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>smart pointer</h1><p>侯捷的C++11视频缺失，但在<a href="https://www.bilibili.com/video/BV14s411E772?p=17">📺</a> 中有所提及<br>📖<a href="https://simonfang1.github.io/blog/2018/08/23/smart-pointer/">https://simonfang1.github.io/blog/2018/08/23/smart-pointer/</a><br>📖<a href="http://www.cplusplus.com/reference/memory/auto_ptr/">http://www.cplusplus.com/reference/memory/auto_ptr/</a><br>📖<a href="https://interview.huihut.com/#/?id=%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">https://interview.huihut.com/#/?id=智能指针</a><br>📖<a href="https://www.jianshu.com/p/e4919f1c3a28">https://www.jianshu.com/p/e4919f1c3a28</a></p><h2>auto_ptr（C11弃用）</h2><ul><li><p>auto_ptr对象间赋值拷贝后所有权将被转移，且原来的指针将被<code>置空</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//auto_ptr以值传递方式作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;T&gt; tp)</span></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;T&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> T)</span></span>; </span><br><span class="line">Fun(p);<span class="comment">//p传入时发生拷贝，此时p已经为nullptr</span></span><br><span class="line"><span class="comment">//! p-&gt;xxx;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>auto_ptr对象<code>仅使用delete</code>析构，无法管理数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! std::auto_ptr&lt;T&gt; p(new T[5]);</span></span><br></pre></td></tr></table></figure></li><li><p>不能和标准容器一起使用</p></li></ul><h2>unique_ptr（代替auto_ptr）</h2><ul><li><p>不支持赋值拷贝，但可以使用<code>move</code>显式转移所有权</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line"><span class="comment">//! std::unique_ptr&lt;T&gt; p2 = p1;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>析构时可以delete，也可delete[]，因此可以管理数组</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">// delete p1</span></span><br><span class="line">std::unique_ptr&lt;T[]&gt; p2(new T[5]);//delete[] p2</span><br></pre></td></tr></table></figure></li><li><p><code>release()</code>仅释放所有权，而<code>reset()</code>同时会释放资源</p></li></ul><h2>shared_ptr（基于<code>引用计数</code>实现）</h2><ul><li><p>多个shared_ptr指向同一对象时，共享一个引用计数器并记录shared_ptr实例数量</p></li><li><p>当最后一个指向对象的shared_ptr销毁时，会自动销毁其所指对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;<span class="comment">//直接创建</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);<span class="comment">//make_shared高效创建</span></span><br></pre></td></tr></table></figure></li><li><p><code>use_count()</code>方法得到强引用计数值</p></li><li><p>默认使用delete析构，析构数组需显式指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式指定delete[]析构</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T[<span class="number">5</span>],[](T* p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>避免不同的share_ptr指向同一资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;<span class="comment">//p1计数1，p1析构后销毁p</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">//p2计数1，p2析构时p已经被销毁</span></span><br></pre></td></tr></table></figure></li><li><p><code>循环引用问题</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A():m_sptrB(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~A()&#123;&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B():m_sptrA(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~B()&#123;&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA计数1</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB计数1</span></span><br><span class="line">pA-&gt;m_sptrB = pB;<span class="comment">//m_sptrB引用pB，pB计数2，pA析构后计数1</span></span><br><span class="line">pB-&gt;m_sptrA = pA;<span class="comment">//m_sptrA引用pA，pA计数2，pB析构后计数1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多线程情况🔗<a href="https://www.jianshu.com/p/c75a0d33655c">https://www.jianshu.com/p/c75a0d33655c</a></p><ul><li>共享指针本身的<code>引用计数</code>操作是<code>原子的</code>，不会有内存泄漏</li><li>对共享指针内部封装的<code>原始指针</code>进行操作时，则<code>需要加锁</code></li><li>当同时读写同一个共享指针时，不能确定<code>编译器操作引用计数和原始指针的先后顺序</code></li></ul><p>解决方法：运用weak_ptr检测指针是否被释放，有两种方法：</p><ol><li>使用<strong>weak_ptr.lock</strong>函数得到一个shared_ptr指针，如果已经释放返回空</li><li>直接使用weak_ptr.expired()来判断一个指针是否被释放</li></ol></li></ul><h2>weak_ptr（解决循环引用问题）</h2><ul><li><p>指向shared_ptr管理的对象，但不会增减<code>强引用</code>计数器</p></li><li><p>调用<code>expired()</code>比调用<code>use_count()</code>方法速度更快，以确定是否指向有效资源</p></li><li><p>调用<code>lock()</code>将weak_ptr转型为share_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">//直接创建share_ptr，强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;T&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;<span class="comment">//使用share_ptr创建weak_ptr，弱引用计数1，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;T&gt; wp2 = wp1;<span class="comment">//使用weak_ptr创建weak_ptr，弱引用计数2，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp2 = wp2.lock();<span class="comment">//将weak_ptr转型为share_ptr</span></span><br></pre></td></tr></table></figure></li><li><p>解决循环引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">weak_ptr&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的weak_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintpB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_sptrB.expired())<span class="comment">//弱引用B有效，则lock为强引用</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; m_sptrB.lock( )-&gt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">weak_ptr&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的weak_ptr</span></span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB强引用计数1</span></span><br><span class="line">pA-&gt;m_sptrB = pB;<span class="comment">//弱引用m_sptrB引用pB，pB强引用计数1，弱引用计数1，pA析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">pB-&gt;m_sptrA = pA;<span class="comment">//弱引用m_sptrA引用pA，pA强引用计数1，弱引用计数1，pB析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">pA-&gt;PrintpB(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>面试补充</h1><h2>shared_ptr初始化unique_ptr?</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp=make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; u=make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// unique_ptr&lt;int&gt; up=move(sp);！！！编译错误</span></span><br><span class="line"><span class="comment">//不存在用户定义的从 &quot;std::shared_ptr&lt;int&gt;&quot; 到 </span></span><br><span class="line"><span class="comment">//&quot;std::unique_ptr&lt;int, std::default_delete&lt;int&gt;&gt;&quot; 的适当转换</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up=move(u);</span><br></pre></td></tr></table></figure><h2>手撕智能指针</h2><p>🔗<a href="https://blog.csdn.net/yanchenzhi/article/details/107591037">https://blog.csdn.net/yanchenzhi/article/details/107591037</a></p><h3>unique_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针，智能指针内部包含的普通指针</span></span><br><span class="line">    <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    UniquePtr(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//禁止赋值</span></span><br><span class="line">    UniquePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造方法，使用普通指针初始化，默认值nullptr</span></span><br><span class="line">    UniquePtr(T* p=<span class="literal">nullptr</span>):m_p(p)&#123;&#125;;</span><br><span class="line">    ~UniquePtr()<span class="comment">//析构函数，delete指针释放资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            m_p=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针</span></span><br><span class="line">    <span class="keyword">int</span>* count;<span class="comment">//int指针指向共享的计数值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造，计数0(nullptr)，普通指针根据具体类型T*置为0，nullptr</span></span><br><span class="line">    SharedPtr():count(<span class="number">0</span>),m_p((T*)<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">//使用普通指针构造，时刻注意count是指针，因此new int</span></span><br><span class="line">    SharedPtr(T* p):count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)),m_p(p)&#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="comment">//1.参数p同样为shared_ptr，因此需要取p.m_p裸指针赋值</span></span><br><span class="line">    <span class="comment">//2.拷贝后，参数p的引用计数++，count先指向参数的count</span></span><br><span class="line">    <span class="comment">//可以直接在初始化形参列表中：count(&amp;(++ *p.count))</span></span><br><span class="line">    <span class="comment">//先p.count取得参数的int计数指针</span></span><br><span class="line">    <span class="comment">//再*操作取得计数的值，并++</span></span><br><span class="line">    <span class="comment">//最后&amp;操作取得参数计数指针的地址，并赋值给count</span></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p):count(p.count),m_p(p.m_p)</span><br><span class="line">    &#123;</span><br><span class="line">        ++(*count);<span class="comment">//*取count值后++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载赋值=运算符</span></span><br><span class="line">    <span class="comment">//1.赋值m_p</span></span><br><span class="line">    <span class="comment">//2.赋值count</span></span><br><span class="line">    <span class="comment">//由于是将参数所在的指针赋给当前指针，因此当前指针的引用计数需要--，而参数指针的计数++</span></span><br><span class="line">    <span class="comment">//因此还需判断当前指针计数，为零则需析构</span></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果自赋值，直接返回本身*this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;p) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//参数指针的引用计数++，p.count获取参数的int指针，*取引用计数的值，最后++</span></span><br><span class="line">        ++(*(p.count));</span><br><span class="line">        <span class="comment">//是否析构</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;<span class="comment">//此时析构并不置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行赋值操作</span></span><br><span class="line">        count = p.count;</span><br><span class="line">        m_p = p.m_p;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">    <span class="comment">//析构，计数为0时才析构，否则计数值--即可</span></span><br><span class="line">    ~SharedPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_p为空则不需要操作</span></span><br><span class="line">        <span class="comment">//否则先--count，如果不为零也不需要操作</span></span><br><span class="line">        <span class="comment">//否则析构，释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回引用计数值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *count;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录C++11中相关特性</summary>
    
    
    
    
    <category term="C++" scheme="https://vae1997.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建博客踩坑记录</title>
    <link href="https://vae1997.github.io/2020/09/24/Hexo+Github/"/>
    <id>https://vae1997.github.io/2020/09/24/Hexo+Github/</id>
    <published>2020-09-24T07:48:18.315Z</published>
    <updated>2020-09-25T06:45:52.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考链接:<a href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程</a></p><h1>操作步骤</h1><ol><li><p>安装git和nodejs，并在github创建仓库</p></li><li><p>以管理员权限打开cmd，并执行<code>npm install -g hexo-cli</code>安装hexo客户端</p></li><li><p>在需要创建博客的目录下执行<code>hexo init blog</code></p></li><li><p><code>cd blog</code>并执行<code>npm install</code></p></li><li><p>编辑blog/_config.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;Vae1997&#x2F;Vae1997.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>执行<code>npm install hexo-deployer-git --save</code>，确保可以找到git命令</p></li><li><p>此时执行<code>hexo g -d</code>后即可访问https://vae1997.github.io/</p></li><li><p>可执行如下命令避免每次提交时都需要输入用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Vae1997&quot;</span><br><span class="line">git config --global user.email &quot;844821239@qq.com&quot;</span><br></pre></td></tr></table></figure></li></ol><h1>踩坑记录</h1><h2>误提交大于100M的文件</h2><p>🔴执行hexo d后出现：this exceeds GitHub’s file size limit of 100.00 MB</p><p>需退回上一次的提交：参考<a href="https://ztygcs.github.io/posts/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4github%E6%8A%A5%E9%94%99/">大文件上传致Github报错</a></p><ol><li><code>cd blog/.deploy_git</code></li><li><code>git log</code>查看上次提交</li><li>复制第一个commit后的代码，执行<code>git reset xxxxx</code></li><li>再次查看提交记录，已经回滚到上一次</li></ol>]]></content>
    
    
    <summary type="html">记录Hexo博客搭建过程</summary>
    
    
    
    
    <category term="Hexo" scheme="https://vae1997.github.io/tags/Hexo/"/>
    
    <category term="搭建" scheme="https://vae1997.github.io/tags/%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Git" scheme="https://vae1997.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
