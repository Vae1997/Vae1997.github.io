<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>许嵩的博客</title>
  <icon>https://www.gravatar.com/avatar/0f37be44c33d1c7c2846a570c1c7a15b</icon>
  
  <link href="https://vae1997.github.io/atom.xml" rel="self"/>
  
  <link href="https://vae1997.github.io/"/>
  <updated>2020-10-05T02:58:15.663Z</updated>
  <id>https://vae1997.github.io/</id>
  
  <author>
    <name>Vae</name>
    <email>vae.xusong.cn@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git常用命令</title>
    <link href="https://vae1997.github.io/2020/10/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://vae1997.github.io/2020/10/05/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
    <published>2020-10-05T02:52:26.000Z</published>
    <updated>2020-10-05T02:58:15.663Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li><p>打开git-cmd</p></li><li><p>关闭证书校验：git config --system http.sslverify false</p></li><li><p>git clone + 仓库url</p></li><li><p>cd 到仓库目录下，如BattleCity</p></li><li><p>添加文件或文件夹，如pics/battle-city.gif</p></li><li><p>git add pics/battle-city.gif</p></li><li><p>git commit -m “描述”</p></li><li><p>git push -u origin master，输入用户名+密码</p></li><li><p>等待上传完成，若出现fatal: the remote end hung up unexpectedly为网络原因，重新执行push</p></li><li><p>push时出现：</p><figure class="highlight plain"><figcaption><span>failed to push some refs to 'https://github.com/Vae1997/BattleCity/'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.&#96;&#96;&#96;</span><br></pre></td></tr></table></figure><p>为仓库已经更新，本地不是最新的仓库<br>执行：git pull origin master，拉取最新仓库后接着push</p></li></ol>]]></content>
    
    
    <summary type="html">记录git常见操作命令</summary>
    
    
    
    
    <category term="git" scheme="https://vae1997.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>数据结构和算法记录</title>
    <link href="https://vae1997.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/"/>
    <id>https://vae1997.github.io/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-25T09:06:40.000Z</published>
    <updated>2020-09-25T09:07:44.801Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>排序</h1><p><a href="https://leetcode-cn.com/problems/sort-an-array/">力扣传送门</a></p><h2>归并</h2><p>最差时间复杂度 ---- O(nlogn)</p><p>最优时间复杂度 ---- O(nlogn)</p><p>平均时间复杂度 ---- O(nlogn)</p><p>所需辅助空间 ------ O(n)</p><p>稳定性 ------------ 稳定</p><h3>Merge操作</h3><p>归并两个有序数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; t;<span class="comment">//临时存储合并好的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Merge</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=left;<span class="comment">//左数组起始位</span></span><br><span class="line">    <span class="keyword">int</span> R=mid+<span class="number">1</span>;<span class="comment">//右数组起始位</span></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=mid &amp;&amp; R&lt;=right)<span class="comment">//两个数组都还有元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//左边≤右边，左侧进队，=确保稳定</span></span><br><span class="line">        <span class="keyword">if</span>(nums[L]&lt;=nums[R])</span><br><span class="line">            t.push_back(nums[L++]);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            t.push_back(nums[R++]);<span class="comment">//否则右侧进队</span></span><br><span class="line">    &#125;<span class="comment">//遍历终止，说明有一侧的数组已经没有可以比较的元素</span></span><br><span class="line">    <span class="comment">//表示右侧数组比较完毕，直接将左侧剩余元素直接挨个进队</span></span><br><span class="line">    <span class="keyword">while</span> (L&lt;=mid)</span><br><span class="line">        t.push_back(nums[L++]);</span><br><span class="line">    <span class="comment">//表示左侧数组比较完毕，直接将右侧剩余元素直接挨个进队</span></span><br><span class="line">    <span class="keyword">while</span> (R&lt;=right)</span><br><span class="line">        t.push_back(nums[R++]);</span><br><span class="line">    <span class="comment">//将排序的数组挨个赋值到原来数组对应位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.size(); i++)</span><br><span class="line">        nums[left+i]=t[i];</span><br><span class="line">    t.clear();<span class="comment">//清空临时数组，以备下次归并记录</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MergeSortRecursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left&gt;=right)<span class="keyword">return</span>;<span class="comment">//只有一个元素，则递归结束，开始回溯</span></span><br><span class="line">    <span class="keyword">int</span> mid=(left+right)/<span class="number">2</span>;<span class="comment">//否则，拆分为左右两个数组</span></span><br><span class="line">    MergeSortRecursion(nums,left,mid);<span class="comment">//左侧递归，拆分</span></span><br><span class="line">    MergeSortRecursion(nums,mid+<span class="number">1</span>,right);<span class="comment">//右侧递归，拆分</span></span><br><span class="line">    <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])<span class="comment">//如果左数组末尾≤右侧数组起始，则不需要归并</span></span><br><span class="line">        Merge(nums,left,mid,right);<span class="comment">//拆分结束，归并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    MergeSortRecursion(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">MergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left,mid,right;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> size=<span class="number">1</span>;size&lt;n;size*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left+size&lt;n)</span><br><span class="line">        &#123;</span><br><span class="line">            mid=left+size<span class="number">-1</span>;</span><br><span class="line">            right=mid+size&lt;n?mid+size:n<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;nums[mid+<span class="number">1</span>])</span><br><span class="line">                Merge(nums,left,mid,right);</span><br><span class="line">            left=right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>快排</h2><p>内部比较排序</p><p><code>最差时间复杂度O( n^2 )</code></p><ul><li>每次选取的基准都是最大（或最小）的元素（包括元素全相等）</li><li>导致每次只划分出了一个分区，需要进行n-1次划分才能结束递归，时间复杂度为O(n^2)</li></ul><p><code>最优/平均时间复杂度O(nlogn)</code></p><ul><li>每次选取的基准都是中位数</li><li>这样每次都均匀的划分出两个分区，只需要logn次划分就能结束递归，时间复杂度为O(nlogn)</li></ul><p>所需辅助空间</p><ul><li>主要是递归造成的栈空间的使用(用来保存left和right等局部变量)</li><li>取决于递归树的深度，一般为O(logn)，最差为O(n)</li></ul><p>稳定性：不稳定</p><p>不稳定发生在基准元素与A[tail+1]交换的时刻</p><p>{ 1, 3, 4, 2, 8, 9, 8, 7, 5 }，基准元素是5，一次划分操作后5要和第一个8进行交换，从而改变了两个元素8的相对次序</p><p>优化：</p><ul><li><p>优化1：基准选取方法采用三数取中法，避免基准选择不当（最大、最小、有序数组）</p></li><li><p>优化2：数组分割方法采用挖坑替换，避免交换操作带来的时间开销</p></li><li><p>优化3：递归时判断当前操作数组大小（right-left），小于10个元素时采用插入排序</p></li><li><p>优化4：递归时采用尾递归，减少递归空间开销</p></li><li><p>优化5：使用栈模拟递归，避免递归空间开销</p></li><li><p>优化6：针对大量重复数组，三路快排（增加相等区间数组）</p></li></ul><p>普通实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;=R)<span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> P=nums[R];<span class="comment">//右端元素作为中枢</span></span><br><span class="line">    <span class="keyword">int</span> left=L,right=R;<span class="comment">//保存左右端点</span></span><br><span class="line">    <span class="keyword">while</span>(L&lt;R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[L]&lt;=P)L++;<span class="comment">//找到左侧大于中枢的位置</span></span><br><span class="line">        nums[R]=nums[L];<span class="comment">//覆盖到右侧</span></span><br><span class="line">        <span class="keyword">while</span>(L&lt;R &amp;&amp; nums[R]&gt;=P)R--;<span class="comment">//找到右侧小于中枢的位置</span></span><br><span class="line">        nums[L]=nums[R];<span class="comment">//覆盖到左侧</span></span><br><span class="line">    &#125;</span><br><span class="line">    nums[L]=P;<span class="comment">//L==R的位置即为中枢元素位置</span></span><br><span class="line">    QuickSort(nums,left,L<span class="number">-1</span>);<span class="comment">//递归快排左侧</span></span><br><span class="line">    QuickSort(nums,L+<span class="number">1</span>,right);<span class="comment">//递归快排右侧</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    QuickSort(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>堆排序</h2><p>内部比较排序</p><p>最差时间复杂度 ---- O(nlogn)</p><p>最优时间复杂度 ---- O(nlogn)</p><p>平均时间复杂度 ---- O(nlogn)</p><p>所需辅助空间 ------ O(1)</p><p>稳定性 ------------ 不稳定</p><p>不稳定发生在堆顶元素与A[i]交换的时刻</p><p>{ 9, 5, 7, 5 }，堆顶元素是9，堆排序下一步将9和第二个5进行交换，得到序列 { 5, 5, 7, 9 }，再进行堆调整得到{ 7, 5, 5, 9 }，</p><p>重复之前的操作最后得到{ 5, 5, 7, 9 }从而改变了两个5的相对次序</p><p>⚠️从<code>最后一个非叶节点</code>开始向上建堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> i,<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L=<span class="number">2</span>*i+<span class="number">1</span>;<span class="comment">//左节点下标</span></span><br><span class="line">    <span class="keyword">int</span> R=<span class="number">2</span>*i+<span class="number">2</span>;<span class="comment">//右节点下标</span></span><br><span class="line">    <span class="keyword">int</span> max=i;<span class="comment">//最大元素下标</span></span><br><span class="line">    <span class="keyword">if</span>(L&lt;n &amp;&amp; nums[L]&gt;nums[max])max=L;</span><br><span class="line">    <span class="keyword">if</span>(R&lt;n &amp;&amp; nums[R]&gt;nums[max])max=R;</span><br><span class="line">    <span class="keyword">if</span>(max!=i)<span class="comment">//表示需要进行调整</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[i],nums[max]);<span class="comment">//交换i位置和max元素</span></span><br><span class="line">        Heap(nums,max,n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sortArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=nums.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)</span><br><span class="line">    &#123;<span class="comment">//从最后一个节点n的父节点向上构建堆</span></span><br><span class="line">        Heap(nums,i,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n&gt;<span class="number">1</span>)<span class="comment">//调整到只有一个节点</span></span><br><span class="line">    &#123;</span><br><span class="line">        swap(nums[<span class="number">0</span>],nums[--n]);<span class="comment">//将堆顶的最大元素交换到最后一个节点位置</span></span><br><span class="line">        Heap(nums,<span class="number">0</span>,n);<span class="comment">//从堆顶继续调整</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>哈希表</h1><p>🔗<a href="https://juejin.im/post/6844903885287637006">https://juejin.im/post/6844903885287637006</a></p><h2>原理</h2><p>存储：数组</p><p><img src="/2020/09/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/16bd1006f29c29d1" alt="哈希"></p><p>存/取：</p><ol><li>将Key通过Hash函数计算得到Hash值</li><li>Hash值 % 数组大小 = 存放下标</li><li>如果匹配，则说明查找成功，返回k:v</li></ol><h2>实现</h2><ul><li>Hash函数：尽可能减少冲突次数</li><li>解决冲突：发生冲突时的手段</li><li>实现相关操作：实现基本操作方法</li></ul><h2>冲突解决</h2><p>发生因素：Hash函数、数组容量</p><p>负载因子：存储的键值对数目与数组容量的比值</p><ul><li><p>存入元素少，浪费空间</p></li><li><p>当存入过多元素，负载因子变大，冲突概率提高</p></li></ul><p>扩容：Java的HashMap将原来的key<code>重新映射到容量为2倍的数组</code></p><h3>拉链法</h3><p>基于数组和链表的组合来解决冲突</p><ul><li>发生冲突时，将冲突的键值对插入链表</li></ul><p>🔴当元素个数和“篮子”数一致时，发生扩容，一般为下一个素数值，之后所有元素重新进行键值对映射</p><h3>开放定址法</h3><p>发生冲突时，直接去寻找下一个空的地址（探测）</p><ul><li>只要底层的表足够大，就总能找到空的地址</li></ul><h1>红黑树</h1><p>作者：小谷围coder<br>链接：<a href="https://www.nowcoder.com/discuss/489210?channel=666&amp;source_id=home_feed">https://www.nowcoder.com/discuss/489210?channel=666&amp;source_id=home_feed</a><br>来源：牛客网</p><p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>它的性质是这样的：</p><ol><li>每个节点不是红色就是黑色。</li><li>根节点是黑色的。</li><li>叶节点的空节点是黑色的。</li><li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li><li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li></ol><p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p><p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p><h1>二叉搜索树</h1><p>将给定数组元素构建为二叉搜索树，<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">力扣</a></p><ul><li>排序后，从中间开始递归构建</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">dfs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> L,<span class="keyword">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L&gt;R)<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = L+(R-L)/<span class="number">2</span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">    root-&gt;left = dfs(nums,L,mid<span class="number">-1</span>);</span><br><span class="line">    root-&gt;right = dfs(nums,mid+<span class="number">1</span>,R);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">sortedArrayToBST</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(),nums.end());</span><br><span class="line">    <span class="keyword">return</span> dfs(nums,<span class="number">0</span>,nums.size()<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>最小生成树</h1><p>找到可以将n个点以最小代价链接起来的n-1条边</p><p><a href="https://www.jianshu.com/p/a5f0f46be8e2">https://www.jianshu.com/p/a5f0f46be8e2</a></p><h2>Kruskal算法</h2><ol><li>找一条最小边，这条边的两个点不在一棵树上，则链接</li><li>找次小边，两个点不是同一个树链接，以此类推，直至n-1条边</li></ol><p>⚠️当一条边的两个点在同一个树中，则需找下一个次小的边</p><h2>Prim算法</h2><ol><li>任选一点作为起点，并选择与其相连的最小代价的点为下一起点</li><li>从新起点继续选择最小代价进行链接，以此类推，直到选择n个节点</li></ol><p>⚠️分别保存已选择的节点和未选择的节点，当一个节点所链接的节点均已经选择后，需检查是否存在未选择的节点，直到未选择节点为空</p><h1>最短路径</h1><h2>Dijkstra算法</h2><ol><li>选取一个起点，并检测链接的边，取最短</li><li>加入最短边的节点，再分别检测每个点链接的边取最短</li><li>排除已经检测过的节点，直到加入所有的节点</li></ol><h1>优先队列</h1><p><a href="https://leetcode-cn.com/problems/top-k-frequent-elements/">力扣传送门</a></p><p>priority_queue：默认为大顶堆，适合求前k小</p><p>改为小顶堆：<code>priority_queue&lt;E, vector&lt;E&gt;, greater&lt;E&gt;&gt;</code></p><p>也可以自定义：<code>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,cmp&gt; pq;</code></p><p>其中的cmp如下：pair的first表示频次，second表示元素</p><ul><li>pair默认以first排前k小，相同时再排second</li></ul><h2>情况1</h2><p>全使用默认设置：<code>priority_queue&lt;pair&lt;int,int&gt;&gt; pq;</code></p><p>输入：[1,1,1,2,2,2,3,3,4,4,5] 3，输出：[4,3,5]</p><p>频次前三小的元素为：3，4，5，根据输出判断出：</p><ol><li>频次按照从大到小输出，因此4，3排在5之前</li><li>频次相同时，按照元素从大到小输出，4排在3之前输出</li></ol><h2>情况2</h2><p>使用greater：<code>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,greater&lt;pair&lt;int,int&gt;&gt;&gt; pq;</code></p><p>输入：[1,1,1,2,2,2,3,3,4,4,5] 3，输出：[4,1,2]</p><p>频次前三大的元素：1，2，4</p><ol><li>频次按照从小到大输出，4排在1，2之前</li><li>频次相同时，优先选取较大元素，因此选4不选3</li><li>频次相同时，元素从小到大排序输出，1在2之前输出</li></ol><p>使用less：<code>priority_queue&lt;pair&lt;int,int&gt;,vector&lt;pair&lt;int,int&gt;&gt;,less&lt;pair&lt;int,int&gt;&gt;&gt; pq;</code></p><p>输入：[1,1,1,2,2,2,3,3,4,4,5,6] 3 输出：[3,6,5]</p><p>频次前三小的元素：5，6，3</p><ol><li>频次按照从大到小输出，3排在5，6之前</li><li>频次相同时，优先选取较小元素，因此选3不选4</li><li>频次相同时，元素从大到小排序输出，6在5之前输出</li></ol><h2>情况3</h2><p>自定义比较方法（单一维度比较）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p1,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="comment">//比较</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3>直接<code>return p1.first&lt;p2.first;</code></h3><p>[1,1,1,2,2,2,3,3,4,4,5,6] 3 =&gt; [4,5,6]</p><ol><li>前三小：4，5，6；频次从大到小输出</li><li>频次相同，选较大元素；按照从小到大输出</li></ol><p>如果改为second则为前三小的元素，按照从大到小输出[3,2,1]</p><h3>直接<code>return p1.first&gt;p2.first;</code></h3><p>[1,1,1,2,2,2,3,3,4,4,5] 3 =&gt; [4,2,1]</p><ol><li>前三大：4，2，1；频次从小到大输出</li><li>频次相同，选较大元素；按照从大到小输出</li></ol><p>如果改为second则为前三大的元素，按照从小到大输出[4,5,6]</p><h2>情况4</h2><p>自定义比较方法（多维度比较）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p1,<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1.first&gt;p2.first)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//表示先按照频率排，找前k大的频率，频次从小到大</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p1.first&lt;p2.first)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;<span class="comment">//频率相同</span></span><br><span class="line">            <span class="keyword">if</span>(p1.second&gt;p2.second)<span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//按照元素大小排，从小到大输出</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>[1,1,1,2,2,2,3,3,4,4,5,6] 3 =&gt; [4,1,2]</p>]]></content>
    
    
    <summary type="html">记录数据结构相关知识点</summary>
    
    
    
    
    <category term="数据结构" scheme="https://vae1997.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://vae1997.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识点整理</title>
    <link href="https://vae1997.github.io/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://vae1997.github.io/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2020-09-25T08:43:27.000Z</published>
    <updated>2020-09-25T09:07:04.022Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>记录计算机网络相关内容</h1><p>🔗：<a href="https://cyc2018.github.io/">cyc2018</a>&amp;<a href="http://interview.huihut.com/">huihut</a>&amp;<a href="%5Bhttps://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md%5D(https://github.com/CavsZhouyou/Front-End-Interview-Notebook/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md)">CavsZhouyou</a></p><h2>基本概念</h2><h3>网络</h3><p>不同主机用网络连接，不同网络用internet连接，Internet是连接全球的internet</p><h3>主机间通信方式</h3><p>P2P：<code>不区分</code>服务的请求方和提供方，C/S：客户端为请求方，服务端为提供方</p><h3>电路交换和分组交换</h3><ul><li>电路交换：用户之间进行通信的整个过程中，始终<code>占用一条</code>专用物理链路，利用率低</li><li>分组交换<ul><li>各个分组记录自身的<code>首部和尾部</code>，并携带<code>源端和目的端</code>等信息</li><li>同一传输线路可传输多个分组，互不影响</li></ul></li></ul><h3>时延</h3><p>总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延</p><ul><li>排队：根据当前网络的通信量，分组可能在路由器的<code>输入/输出队列</code>中排队等待</li><li>处理：主机/路由器收到分组后进行的一系列处理操作（分析首部、提取数据、差错检验、路由选择…）</li><li>传输：主机/路由器传输数据帧的耗时=数据帧长度(bit)/传输速率(bit/s)</li><li>传播：电磁波在信道中的传播时间=信道长度(m)/光速(m/s)</li></ul><h3>计算机网络体系结构</h3><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200723164820782.png" alt="计算机网络体系结构"></p><ul><li>应用层：以<code>报文</code>为单位在具体应用<code>程序之间</code>提供传输数据服务（HTTP、DNS）</li><li>传输层：以<code>报文段/用户数据报</code>的形式在<code>进程之间</code>提供数据传输服务（TCP/UDP）</li><li>网络层：将传输层数据以<code>分组</code>形式进行封装，通过<code>路由器</code>在<code>主机之间</code>提供数据传输服务（IP/ARP）</li><li>链路层：将网络层数据进一步封装成<code>帧</code>，通过<code>网桥/交换机</code>为<code>同一链路</code>的主机之间提供数据传输服务</li><li>物理层：屏蔽底层物理硬件设备差异，确保传输前后的比特流不变，对于链路层的比特流来说，底层硬件是透明的</li></ul><p>⚠️TCP/IP不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层</p><h2>物理层</h2><ul><li><p>数据传输单位：比特</p></li><li><p>通信方式</p><ul><li>单工：单向传输（广播）</li><li>半双工：双方交替传输</li><li>全双工：双方同时传输</li></ul></li><li><p>带通调制：将<code>离散的数字信号</code>转换为<code>连续的模拟信号</code></p></li></ul><h2>数据链路层</h2><ul><li>封装成帧：首部+网络层数据报+尾部，构成一帧</li><li>透明传输：IP数据报中内容和首部/尾部相似，则需通过<code>转义字符</code>对帧的首尾进行界定</li><li>差错检测：通过<code>循环冗余检验</code>（CRC）来检查传输比特流中可能出现的差错</li></ul><h3>信道分类</h3><ul><li>点对点信道：一对一通信，简单，使用PPP协议（用户主机和互联网服务提供商ISP的通信）</li><li>广播信道：通过<code>信道复用</code>或<code>CSMA/CD协议</code>，避免在同一广播信道发送数据时产生<code>冲突</code><ul><li>单播：给局域网指定的MAC地址发送帧，一对一</li><li>多播：给局域网多个站点发送帧，一对多</li><li>广播：给局域网内所有站点发送帧，一对全体</li></ul></li></ul><h3>信道复用</h3><ul><li>频分：相同时间内，不同主机<code>占用不同频率的带宽</code>资源，信道利用率低</li><li>时分：不同主机在不同的时间段内，占用相同的带宽频率，信道利用率低</li><li>统计时分：对时分复用的改进，不固定不同主机（数据）在帧中的位置，构成一帧即可发送</li><li>波分：光的频分，但光频率高，常用波长表示</li><li>码分：不同主机使用不同的码，可以在同一时间使用相同频带通信，分配 m bit 的码片，则发送数据量为原先的m倍</li></ul><h3>CSMA/CD 协议</h3><ul><li>基本原理<ul><li>多点接入：所有节点都共享网络传输信道（总线型网络）</li><li>载波监听：节点在发送数据之前，首先检测信道是否空闲，如果信道空闲则发送，否则就等待</li><li>碰撞检测：在发送出信息后，再对冲突进行检测，当发现冲突时，则取消发送</li></ul></li><li>争用期：端到端传播时延为t，一个来回最大2t，2t时间还未发生碰撞，则肯定这次发生不会冲突，2t为争用期</li><li>重传等待时间：发生碰撞时需要等待一段时间后再发送，从集合 {0, 1, …, (2k-1)} 中随机取出一个数 r，取<code> r 倍的争用期</code>作为重传等待时间</li></ul><h3>局域网</h3><p>典型的<code>广播</code>信道，地理范围、站点数量有限，按照拓扑结构分：星型、环形、总线等</p><h3>以太网</h3><p><code>一种星型拓扑结构的局域网</code></p><h4>帧格式</h4><p>每个以太网帧都有最小的大小64bytes最大不能超过1518bytes</p><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200723210947925.png" alt="以太网帧格式"></p><ul><li>地址；源地址和目的地址均为MAC地址</li><li>类型：标记上层使用的协议（IP/ARP）</li><li>数据：长度在 46-1500 之间，如果太小则需要填充；<code>最大传输单元MTU，默认1500字节</code></li><li>FCS：帧检验序列，使用的是 CRC 检验方法；</li></ul><h4>连接方式</h4><ul><li>集线器<ul><li>早期连接方式，作用于比特，<code>物理层设备</code></li><li>一个比特到达接口后被重新生成，能量强度放大，从而扩大网络传输距离，之后再发送至所有其他接口</li><li>一个集线器同时收到两个不同接口的比特，则表明发送碰撞</li></ul></li><li>交换机<ul><li>集线器的替代，<code>链路层设备</code></li><li>根据MAC地址进行<code>存储转发</code>，不会发生碰撞</li><li>自动将<code>MAC地址及其端口</code>映射更新到<code>交换表</code>中</li></ul></li></ul><h2>网络层</h2><p>将传输层的报文段/用户数据报<code>封装成分组/包</code>进行转发，向上提供<code>无连接、最大努力交付</code>的服务</p><ul><li>IP协议：规定了网络层的编址和转发方式</li><li>路由选择协议：决定了数据报从源到目的地所流经的路径</li></ul><h3>IP数据报格式</h3><p>注意首部固定20字节，除非含有选项字段</p><p>⚠️传输次序：0-7，8-15，大端序，又称为<code>网络字节序</code>；若主机为小端序，则需要转为大端序</p><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200724102132514.png" alt="IP数据报格式"></p><ul><li>版本：4（IPV4）、6（IPV6）两个值</li><li>首部长度：占4位，最大值15，值为1表示4字节（1个32位字），固定部分有20字节，因此最小值为5</li><li>填充：通过填充字段，将可选长度修正为4的倍数</li><li>总长度：首部+数据的长度</li><li>生存时间TTL：以路由器跳数为单位，为0则丢弃数据报，防止在网络中一直无法交付而占用信道</li><li>协议：明确需要将数据上交的的具体协议（TCP、UDP…）</li><li>标识：数据报过长时需要进行分片，同一数据报的分片标识一致</li><li>片偏移：8字节为单位，确定不同分片在数据报中的偏移值</li></ul><h3>IP分片和重组</h3><p>🔗<a href="https://cloud.tencent.com/developer/article/1173790">https://cloud.tencent.com/developer/article/1173790</a></p><p>⚠️不得以才做分片，一旦分就需要额外增加首部，接收还要重组，开销明显增大</p><p>分片原因：</p><ul><li>以太网帧格式（非巨帧），MTU限制IP数据报46~1500，超过MTU则分片，不一定按序到达，但IP首部标识可以重组</li></ul><p>MTU进一步=IP首部+TCP首部+MSS</p><p>因此MSS理论最大=1500-20-20=1460字节，默认536（MTU标准576-20-20）</p><p>如果超过MSS则TCP分段，TCP按序号重组</p><p>🚨 发送端进行TCP分段后就一定不会在IP层进行分片，TCP层分段满足了MSS限制，也就满足了MTU的物理限制；UDP没有限制则超过MTU一定分片</p><ul><li><p>但TCP分段后仍然可能IP分片，TCP分段<code>仅满足了通信两端的MTU</code>要求，传输路径上如经过MTU值比该MTU值更小的链路，则再次分片</p></li><li><p>两个通信主机直连，TCP连接协商得到的MTU值(两者网卡MTU较小值)就是路径MTU，发送端只要做了TCP分段，则在整个通信过程中一定不会发生IP分片</p></li><li><p>另注意：分片后<code>传输层的首部仅出现在第一个分片中</code>，剩余分片仅包含IP首部</p></li><li><p>一旦路径中分片丢失，TCP接收端收不到完整的报文，超时后发送端收到三次冗余ACK后整体重传</p></li></ul><p>避免分片：</p><ul><li>路径MTU：是指一条因特网传输路径中，从源地址到目的地址所经过的“路径”上的所有IP跳的最大传输单元的最小值</li><li>路径MTU发现：TraceRoute，确定两个IP主机之间路径最大传输单元的技术</li></ul><h3>编址方式</h3><ul><li>分类：网络号+主机号，不同类别网络号长度固定A8、B16、C24</li><li>子网划分：网络号+子网号+主机号，从主机号划分出子网号，结合子网掩码确定所属子网网段</li><li>CIDA：IP地址/网络前缀，前缀可变，有效减少<code>路由表项</code>数量（超网）</li></ul><h3>地址解析协议ARP</h3><p>⚠️在OSI模型中ARP协议属于链路层；而在TCP/IP模型中，ARP协议属于网络层，另参考📖<a href="https://zhuanlan.zhihu.com/p/28771785">https://zhuanlan.zhihu.com/p/28771785</a></p><ul><li>实现IP地址到MAC地址的转换（RARP相反），从功能上讲是链路层的服务</li><li>通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变</li><li>存在于以太网帧格式中的类型（IP/ARP）字段，帧位于链路层，因此从层次上讲可以看作网络层</li></ul><p>工作原理：</p><ul><li>主机<code>ARP高速缓存</code>中没有目的IP到MAC的映射，则广播发送ARP请求，包含本机IP+本机MAC+目的IP</li><li>目的IP收到ARP请求，返回ARP响应，包含目的IP的MAC地址</li></ul><h3>网际控制报文协议ICMP</h3><p><code>基于IP协议</code>，数据封装在IP数据报中，加强IP报文交付成功的机会，另参见📖<a href="https://zhuanlan.zhihu.com/p/45110873">https://zhuanlan.zhihu.com/p/45110873</a></p><ul><li>差错报文：traceroute，当IP数据报发送错误时将错误信息封装传回源主机</li><li>询问报文：ping查询、子网掩码查询、时间戳查询</li></ul><h4>Ping</h4><p>检测主机之间网络连通情况，基本原理：</p><ul><li><p>源主机构建ICMP请求报文（包含目的IP，ICMP报文中类型字段为8），交付给IP协议构建IP数据报</p></li><li><p>通过ARP协议获得目的主机MAC地址后加入IP报文，交付给链路层封装成帧</p></li><li><p>向目的主机发送包含ICMP echo 请求报文的数据帧</p></li><li><p>目的主机收到后，确认MAC，拆解数据帧，获得IP报文后进一步交付ICMP协议处理</p></li><li><p>处理完成后，目的主机构建ICMP echo 回答报文（ICMP报文中类型字段为0）</p></li><li><p>根据时间和成功响应次数估算往返时间和丢包率</p></li></ul><h4>Traceroute（tracert）</h4><p>利用差错报文遍历传输路径所有路由器，基本原理：</p><ul><li>源主机发送TTL为1的<code>UDP探测报文</code>，每经过路由器TTL值减一，为0时路由器向源主机发送ICMP TTL Exceed包</li><li>源主机收到后显示本次传输信息，并将TTL加一，继续上述步骤直至目的主机收到探测报文，返回ICMP Dest Unreachable包</li><li>源主机收到后停止Traceroute</li></ul><p>⚠️当目的主机收到探测报文时TTL不为0，由于每次的UDP报文中会设置一个不可达的端口号，因此返回<code>端口不可达</code>的ICMP差错报文</p><h3>网络地址转换NAT</h3><p>将专用网内部IP地址转换为全球IP地址，将两个IP一一对应的利用率不高，因此将传输层的端口号加入转换，内部主机公用一个全球IP（NAPT）</p><h3>路由器</h3><p>从功能上划分为<code>路由选择</code>和<code>分组转发</code></p><h4>路由选择协议</h4><p>不同的自治系统AS可使用不同的路由协议</p><ul><li>内部网关协议：<ul><li>RIP：基于距离向量算法交换相邻路由表的信息，实现简单开销小，但最大跳数15限制了网络规模，网络故障经过较长时间才能通知所有路由器</li><li>OSPF：当链路发生改变时，向AS中所有路由器发送自身与相邻路由器的链路状态（距离、时延、带宽等），克服RIP缺点，收敛更快</li></ul></li><li>外部网关协议：BGP，每个AS配置发言人，两个相邻BGP建立TCP连接交换路由信息，最终寻找一条比较好的路由</li></ul><h4>分组转发流程</h4><ul><li>从数据报首部提取目的IP地址和目的网络地址，查询路由表依次进行如下判断：<ul><li>目的网络地址和当前路由器直接相连，则直接交付</li><li>表中存在目的IP地址指向的特定主机路由，将数据报转发到该特定主机路由</li><li>表中存在目的网络地址对应的路由，将数据报转发到该路由</li><li>表中存在默认路由，将数据报转发到该默认路由</li><li>分组转发失败，向生成数据报的应用程序返回“主机/网络不可达”错误</li></ul></li></ul><p>⚠️特定主机路由：为特定目的主机指明的路由，使网络管理人员能更方便地控制、测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。</p><h4>路由表项</h4><p>🔗<a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/3/">http://docs.52im.net/extend/docs/book/tcpip/vol1/3/</a></p><ul><li>目的地址：主机地址/网络地址，具体由标志字段指定</li><li>下一跳地址：目的地址指向的下一跳路由器IP/网络IP，由标志指定</li><li>标志：一个指定目的地址，另一个指定下一跳地址</li><li>为数据包传输指定的网络接口</li></ul><p>除此之外还会包含特定主机路由、默认路由以及其他附加信息（花费、服务质量等）</p><h2>传输层</h2><p>网络层只在主机间传输分组，之后需要传输层提供主机间进程的通信</p><h3>用户数据报协议UDP</h3><h4>基本特点</h4><ul><li>无连接、尽最大可能交付</li><li>面向报文（UDP首部+应用层报文）</li><li>套接字只使用目的地址和目的端口来标识</li><li>支持一对一、一对多、多对一、多对多通信</li><li>传输单位：用户数据报</li><li>不会因为网络拥塞而降低源主机发送速率，发送速率无限制</li><li>使用场景：对实时性要求高</li></ul><h4>首部格式</h4><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200725110750556.png" alt="UDP首部格式"></p><p>⚠️UDP<code>首部8字节</code>，4部分均为2字节，为计算检验和临时添加伪首部</p><ul><li>检验和：只是检验，对于差错的恢复无能为力</li><li>长度：整个报文长度（首部+数据）</li></ul><p>UDP数据报中数据最大长度：IP报文首部16位指定总长度（65535字节）-IP报文首部20字节-UDP首部8字节=65507字节</p><p>上述为理论值，通常MTU默认最小576字节，因此UDP通常在576-20-8=548字节内</p><p>若按MTU最大1500字节计算：UDP最大数据1500-20-8=1472字节</p><h3>传输控制协议TCP</h3><h4>基本特点</h4><ul><li>面向连接、可靠交付</li><li>面向字节流（粘包问题）<ul><li>粘包原因：字节流，数据无边界，两个报文数据可能重叠</li><li>解决方法：<ul><li>双方指定一个定长的数值，作为一个数据包</li><li>在包头说明包体长度，先接收头部，根据说明的长度确定包体</li><li>通过在数据包刻意添加特殊字符来指定边界，但如果数据本身就包含类似特殊字符就会发生误判</li><li>使用更为复杂的应用层协议</li></ul></li></ul></li><li>一对一全双工通信</li><li>传输单位：报文段</li><li>提供流量控制、拥塞控制</li></ul><h4>首部格式</h4><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200725111046745.png" alt="TCP首部格式"></p><p>⚠️TCP<code>首部中包含固定大小的20字节</code></p><ul><li>序号：对字节流编号，确保信息按序到达，4字节，则最大对4GB编号</li><li>确认号：希望收到的下一个报文段的序号</li><li>数据偏移：数据起始位距离报文起始位的偏移（1:4）（首部长度），4bit最大值15，最大偏移15*4字节，<code>TCP首部最长60字节</code></li><li>ACK：值为1时确认号有效，建立连接后的所有报文ack均要置1</li><li>SYN：建立连接时同步序号，连接请求：SYN=1，ACK=0，同意建立连接：SYN=1，ACK=1</li><li>FIN：置为1，表示该报文的发送方数据已经发完，请求释放连接</li><li>窗口：接收方的缓存有限，通过该字段让发送方明确可以发送的数据量</li></ul><p>⚠️MSS</p><ul><li><p>Maximum Segment Size ，TCP提交给IP层最大分段大小</p></li><li><p>MSS是TCP用来限制应用层最大的发送字节数，<code>最常见的可选字段，第一次握手时指定</code></p></li><li><p>如果底层物理接口MTU= 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</p></li><li><p>如果应用层有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。</p></li></ul><h4>三次握手</h4><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200726135310053.png" alt="握手"></p><p>⚠️主动发送连接请求的为客户端</p><ul><li>服务端创建传输控制块TCB，从CLOSED状态转为LISTEN（监听）状态，等待客户端的连接请求</li><li>客户端创建TCB，发送连接请求报文（SYN=1不能携带数据但消耗序号），初始化随机序号seq=x，状态转为SYN-SENT（同步-发送）</li><li>服务端收到后分配资源，发送确认报文（SYN=1，ACK=1），确认号ack=x+1，初始化自身随机序号seq=y，状态转为SYN-RCVD（同步-接收）</li><li>客户端收到后分配资源，对服务端的确认进行确认（ACK=1，可以携带数据但需消耗序号），ack=y+1，seq=x+1，状态转为ESTABLISHED（连接已建立）</li><li>服务端收到确认后，状态转为ESTAB-LISHED（连接已建立）</li></ul><p>⚠️服务端向客户端发送的连接确认也可分为两步（四次握手），但效率不高</p><p>关于初始化序号：🔗<a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/18/">http://docs.52im.net/extend/docs/book/tcpip/vol1/18/</a></p><ul><li>初始化序号随时间改变，因此每次建立连接时都不同</li><li>序号可以看成是32比特的计数器，每4ms+1</li></ul><p>作者：小谷围coder<br>链接：<a href="https://www.nowcoder.com/discuss/489210?channel=666&amp;source_id=home_feed">https://www.nowcoder.com/discuss/489210?channel=666&amp;source_id=home_feed</a><br>来源：牛客网</p><h5 id="TCP三次握手时的第一次的seq序号是怎样产生的">TCP三次握手时的第一次的seq序号是怎样产生的</h5><p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p><p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）</p><h5 id="三次握手？">三次握手？</h5><p>双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信</p><h5 id="两次握手？">两次握手？</h5><p>防止<code>已失效的连接请求报文</code>再次被服务端收到：</p><ul><li>客户端先发了A连接请求，网络原因报文滞留，但没有丢失</li><li>客户端未收到服务端确认，等待超时重传时间到，再次发送连接请求B，成功建立连接，数据发送完毕后断开连接</li><li>此时A连接再次被服务端收到，服务端向客户端回发确认报文，若为两次握手则此时连接建立</li><li>客户端忽略服务端的确认报文，服务端一直等待客户端数据，资源浪费</li><li>因此为三次握手，当服务端第一次没收到客户端确认后就明确客户端并未发送连接请求</li></ul><h4>四次挥手</h4><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200726143055087.png" alt="挥手"></p><p>⚠️主动断开连接的为客户端</p><ul><li>客户端进程发送连接释放请求报文（FIN=1，如果不携带数据也需消耗序号），seq=u（此前发送的数据最后一字节序号+1），状态转为FIN-WAIT-1</li><li>服务端收到请求后，先立即发出确认报文（ACK=1）ack=u+1，自身序号seq=v（此前发送的数据最后一字节序号+1），状态转为CLOSE-WAIT</li><li>⚠️此时为半关闭状态，客户端无数据发送，但可能还需要接收服务端尚未发完的数据</li><li>客户端收到服务端确认后，状态转为FIN-WAIT-2，接收服务端数据并等待服务端发出请求连接释放报文</li><li>服务端发完数据后，发送连接释放报文（FIN=1，ACK=1）ack=u+1（上次对于客户端的确认序号），自身序号seq=w，状态转为LAST-ACK</li><li>客户端收到连接释放请求后，发送确认报文（ACK=1）ack=w+1，seq=u+1，进入TIME-WAIT状态</li><li>⚠️此时客户端还需要等待（时间等待计时器）2MSL（最长报文寿命）后进入CLOSE彻底关闭连接，撤销TCB释放资源</li><li>服务端若收到客户端的ACK则撤销TCB，状态转为CLOSE并断开连接释放资源</li></ul><h5 id="TIME-WAIT？">TIME-WAIT？</h5><ul><li>客户端等待2MSL，4 分钟（MSL 为 2 分钟）的时间后，如果还是没收到服务端可能因为未收到自己的ACK报文，而超时重发的FIN报文，说明服务端已经收到ACK释放了资源</li><li>⚠️服务端没收到ACK后，超时重传FIN，客户端收到后重置2MSL等待时间</li><li>防止“已失效的报文“再次被收到，2MSL的时间足够让本次TCP整个连接的所有报文全部从网络上消失</li></ul><h5 id="四次挥手？">四次挥手？</h5><p>服务端先发送对客户端的ACK，但还需将未发完的数据继续发送，之后再发送FIN断开连接</p><h5 id="保活计时器">保活计时器</h5><p>正常的TCP连接中，客户端因故障而失去收发能力：</p><ul><li>服务端每次收到客户端数据后，重置保活计时器</li><li>计时结束，还未收到客户端数据，服务端每隔一定时间后发送探测数据报文，若10个探测报文后客户端仍无响应，服务端主动关闭连接</li></ul><h4>可靠传输</h4><ul><li>将应用数据<code>分割成块</code>，并进行<code>编号</code>，接收端将<code>排序</code>好的有序数据反馈给应用层</li><li>通过TCP首部的<code>检验和</code>，检测数据变化，若有差错，直接丢弃不进行确认</li><li>接收端<code>丢弃重复</code>的数据</li><li>通过可变大小的<code>滑动窗口</code>实现流量控制</li><li>网络出现拥堵，通过<code>拥塞控制</code>减少数据发送量</li><li>停止等待：每发一个分组就停止发送，等待收到确认；确认后再发下一个</li><li>超时重传<ul><li>RTT：报文从发送到收到确认经历时间</li><li>当在一个RTT时间内仍未收到确认报文，则触发<code>超时重传机制</code>，确保TCP的可靠传输</li></ul></li></ul><h5 id="ARQ协议">ARQ协议</h5><p>自动重传请求，通过超时重传保证可靠交付，细分为停止等待和连续ARQ</p><ul><li>确认丢失：ack报文丢失<ul><li>发送方未收到确认报文，重传之前的报文</li><li>接收方收到重复报文后直接丢弃，再次发送确认报文</li></ul></li><li>确认迟到：ack报文未能在超时计数结束前到达发送方<ul><li>发送方未收到确认报文，重传之前的报文</li><li>接收方收到重复报文丢弃，再次发送确认</li><li>发送方收到确认，发送新的报文</li><li>在此期间，发送方又收到之前的确认报文，直接丢弃</li></ul></li></ul><h6 id="停止等待">停止等待</h6><p>发送端每发送一个分组就停止发送，等待接收端的确认报文，收到之后再发下一个分组</p><ul><li>发送端设置超时计时器，计时结束未收到确认则需重传</li><li>接收端收到重复分组直接丢弃，同时再次发送确认；收到损坏的分组直接丢弃</li><li>简单，信道利用率低</li></ul><h6 id="连续ARQ">连续ARQ</h6><p>在发送窗口内的分组直接发送，接收方仅对按序到达的最后一个分组确认，提高信道利用率，易实现，确认报文丢失不必重传</p><h6 id="滑动窗口">滑动窗口</h6><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200726150851919.png" alt="窗口"></p><p>TCP连接的双方都有自己的窗口，用来暂存字节流，体现在报文中的窗口字段</p><ul><li>已发送并受到确认：当前字节流已经成功完成发送，滑动窗口右移</li><li>已发送但未收到确认：虽然已经发送，但是暂时没收到确认报文，<code>设置定时器</code>来决定是否重发<ul><li>定时器针对的是：<code>最早发送但未收到确认的分组</code></li><li>在定时器时间内收到确认，则窗口右移到确认号ack的位置</li><li>如果还存在已发送未确认分组，重置定时器；否则关闭定时器</li><li>如果超时，重传所有未确认的分组；另外将超时的间隔设置为以前的两倍</li></ul></li><li>未按序收到：接收窗口中存在乱序的报文段，若无选择重传机制，则直接丢弃乱序分组并重新发送最后一个有序分组的确认</li><li>允许发送但未发送：位于窗口内部，可能由于接收端已经饱和，无法继续接收；或因为存在未确认的报文段</li><li>允许接收：接收窗口可以继续接收的窗口大小</li><li>不允许发送/接收：窗口已满，暂时不能进行发送/接收操作</li></ul><p>滑动窗口协议的缺点是因为使用了累计确认的机制，如果出现了只是窗口中的第一个分组丢失，而后面的分组都按序到达的情况 的话，那么滑动窗口协议会重新发送所有的分组，这样就。</p><p>⚠️Go-Back-N问题</p><p>一旦前面有分组丢失，即便之后的分组已按序到达，但发送端只根据确认号<code>从丢失的分组开始全部重传</code>，造成大量不必要的丢弃和重传</p><p>解决方法：<code>选择重传协议</code></p><h6 id="选择重传协议">选择重传协议</h6><p>与滑动窗口的不同：</p><ul><li>发送方窗口内部增加<code>已确认的乱序分组</code></li><li>为<code>每个分组单独设置定时器</code>，而不是仅在最早发送的分组上设置</li></ul><p>对于发送方：</p><ul><li>收到某个分组的确认后，取消其定时器；另外判断是否存在以窗口首部打头的连续分组</li><li>若存在连续分组，则右移窗口；否则将该分组标记为已确认的乱序分组</li><li>某个计时器超时，则重传该分组</li></ul><p>对于接收方：</p><ul><li>只要是接收到的分组，无论连续与否，均缓存</li><li>当所有乱序分组排序为一段整体有序的分组后，再交付</li><li>分组出现差错或不能接受，则直接忽略</li></ul><h5 id="流量控制">流量控制</h5><p>通过获取接收方确认报文中的窗口字段，控制发送方的发送速度，以便接收方来得及接受，减少数据包丢失</p><ul><li>窗口为0，则不能发送，但有例外⚠️<ul><li>允许发送紧急数据：即报文段中URG（紧急比特）置为1时，配合首部的紧急指针</li><li>发送1字节的数据报：通知接收方自身的窗口大小以及下一字节序号</li></ul></li></ul><h5 id="拥塞控制">拥塞控制</h5><p>为降低整个网络的拥堵程度，减少数据包丢失，以便网络始终保持在一个相对畅通的状态</p><p>⚠️发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个</p><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200726190219419.png" alt="拥塞控制"></p><h6 id="慢开始-拥塞避免">慢开始&amp;拥塞避免</h6><ul><li>发送方维护一个<code>拥塞窗口</code>（cwnd），初始值=1，单次最大传输1个报文段</li><li>发送方收到确认后，cwnd=2，4，8······，呈指数增长</li><li>当cwnd &gt;= <code>慢开始门限</code>（ssthresh），即进入拥塞避免阶段，每个收发轮次cwnd+1</li><li>当出现超时，ssthresh = cwnd / 2，<code>cwnd=1</code>，进入慢开始，重复上述步骤</li></ul><p>⚠️若MSS为256字节，则<em>cwnd</em>和<em>ssthresh</em>的初始值分别为256和65535字节；ssthresh初始值可以无穷大</p><h6 id="快重传-快恢复">快重传&amp;快恢复</h6><ul><li>接收方对每一个已经按序收到的报文段进行确认</li><li>若出现未按序到达的报文段，则接收方会一直向发送方反馈未按序到达的那个报文段</li><li>当发送方收到连续<code>三个同样的ack后启动快重传</code>，在定时器结束前，发送所有已发送但还未接收到确认的报文段。</li><li>此时并非因为网络拥堵而造成重传，因此执行<code>快恢复</code>：ssthresh = cwnd / 2 ，<code>cwnd = ssthresh</code>，注意此时直接进入拥塞避免</li></ul><p>📖对于TCP有限状态机11种状态详解：<a href="https://developer.aliyun.com/article/434307">https://developer.aliyun.com/article/434307</a></p><ul><li><p>FIN_WAIT_2：当发送端等待接收端发完数据时，发送端的状态；</p><p>⚠️如果在FIN_WAIT_1状态直接收到ACK和FIN的报文，则直接进入TIME_WAIT</p></li><li><p>CLOSING：双方同时收到对方的FIN请求，罕见</p></li></ul><h3>多路复用与多路分解</h3><p>多路复用：从源端不同的Socket中收集数据后，分别加上对应首部封装成报文段，并传递到网络层的过程</p><p>多路分解：目的端收到传输层报文段后，将其中的数据交付给对应Socket的过程</p><p>UDP：不同报文段的UDP套接字二元组（目的IP+目的端口）如果相同，则会在目的端使用同样的Socket定位</p><p>TCP：使用套接字四元组（源IP+源端口+目的IP+目的端口）将不同报文段定位到不同Socket</p><h3>端口</h3><ul><li>IP定位主机，端口定位进程</li><li>TCP/UDP端口均16位，0~65535</li><li>0~1023为熟知端口号：DNS-53，HTTP-80</li><li>1024~49151需要登记以防重复</li><li>其余为客户端运行时动态分配，存在时间短暂</li></ul><h2>Socket</h2><p>🔗<a href="https://github.com/JerryC8080/understand-tcp-udp/blob/master/chapter6.md">https://github.com/JerryC8080/understand-tcp-udp/blob/master/chapter6.md</a></p><p>🔗<a href="https://blog.csdn.net/G_BrightBoy/article/details/12854117">https://blog.csdn.net/G_BrightBoy/article/details/12854117</a></p><ul><li><p>从 Linux 内核的角度来看，一个套接字就是通信的一个端点</p></li><li><p>从 Linux 程序的角度来看，套接字是一个有相应描述符的文件</p></li></ul><h3>常用接口函数</h3><p>在linux中相关方法基本定义在<code>sys/socket.h</code>中：</p><ul><li><pre><code class="language-cpp">int socket(int domain, int type, int protocol);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 返回socket描述符（非负-成功，-1-失败），但没有完全打开，不能读写（主动套接字）</span><br><span class="line">  - domain：协议域定义通信地址类型，AF_INET（ipv4）、AF_INET6（ipv6）、AF_LOCAL（绝对路径）</span><br><span class="line">  - type：指定socket类型，SOCK_STREAM（面向连接TCP）、SOCK_DGRAM（无连接UDP）</span><br><span class="line">  - protocol：指定协议，IPPROTO_TCP（TCP）、IPPTOTO_UDP（UDP），置为0，则为type默认对应的协议</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;cpp</span><br><span class="line">  int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</span><br></pre></td></tr></table></figure>- 服务端调用，把一个地址族（ipv4/ipv6）中的特定地址和socket绑定（0-成功，-1-失败）- sockfd：指定由 socket() 函数创建的主动套接字描述符- addr：一个`sockaddr`类型的结构体指针，指向要绑定给sockfd的结构体地址，``结构体成员中包含了IP+端口号``（注意网络字节序）  :warning:sockaddr结构体内容和地址族相关，ipv4=&gt;sockaddr_in，ipv6=&gt;sockaddr_in6，都可以强制转换成sockaddr- addrlen：表示sockaddr结构体的长度，如果是 ipv4 的 TCP 连接，一般为 `sizeof(sockaddr_in)`;</code></pre></li><li><pre><code class="language-cpp">int listen(int sockfd, int backlog);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 服务端调用（&#96;&#96;状态从CLOSED转为LISTEN&#96;&#96;），将&#96;&#96;主动套接字转化为监听套接字&#96;&#96;, 该套接字可以接收来自客户端的连接请求（0-成功，-1-失败）</span><br><span class="line"></span><br><span class="line">    :warning:在默认情况下，操作系统内核会认为 socket 函数创建的描述符对应于&#96;&#96;主动套接字&#96;&#96;（active socket）</span><br><span class="line"></span><br><span class="line">    :warning:主动套接字：调用socket后得到的描述符可以调用connect()进行连接</span><br><span class="line"></span><br><span class="line">  - sockfd：指定将要转换的主动套接字</span><br><span class="line"></span><br><span class="line">  - backlog：指定在&#96;&#96;队列&#96;&#96;中的最大socket描述符个数，进入的连接请求将在队列中等待 accept() 它们</span><br><span class="line"></span><br><span class="line">    :red_circle:对于给定的&#96;&#96;监听套接字&#96;&#96;，内核需要维护两个队列，两个队列之和数量不得超过backlog</span><br><span class="line"></span><br><span class="line">    - 已完成连接队列：存放已经完成三次握手的socket连接，均为ESTABLISHED状态</span><br><span class="line">    - 未完成连接队列：存放已经到达服务端，但正等待完成对应三次握手的socket连接，均为SYN-RCVD状态</span><br><span class="line">    - 当队列已满（默认128），则向客户端返回RST报文</span><br><span class="line"></span><br><span class="line">    :warning:另注意此时服务端并未阻塞</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;cpp</span><br><span class="line">  int accept(int listenfd, struct sockaddr *addr, int *addrlen);</span><br></pre></td></tr></table></figure>- 服务器调用，若``已连接socket队列为空则阻塞``，等待来自客户端的连接请求；返回``已连接socket描述符``，用来与客户端进行数据传输- listenfd：指定服务端的监听socket，即先由socket()创建，再经过listen()转换的socket- addr：存放发出连接请求的客户端信息，其中包含的是``客户端的IP+端口``- addrlen：注意类型为int*，不同于bind/connect中的addr参数是直接指定，因此不能直接通过addr前16字节确定地址类型  :warning:accept中的addr是来自于客户端，无法确定地址类型ipv4/ipv6，因此需要该参数进行长度说明  :red_circle: 执行成功，返回内核自动生成的一个新的socket（已连接socket）代表与客户端的连接  - 已连接socket：完成三次握手，服务端用于和客户端传输数据的socket，由accept()返回，位于已连接队列，连接断开时关闭  - 监听socket：服务端通过socket()创建，再通过listen()得到的socket，一直存在直到服务器关闭，专门用于建立连接的socket</code></pre></li><li><pre><code class="language-cpp">int connect(int clientfd, const struct sockaddr *addr, socklen_t addrlen);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 客户端调用（&#96;状态从CLOSED转为SYN-SENT&#96;），自动分配端口号，与目的服务器的套接字建立一个连接（0-成功，-1-失败）</span><br><span class="line"></span><br><span class="line">  - clientfd：本机客户端的socket描述符，直接由socket()创建</span><br><span class="line"></span><br><span class="line">  - addr：一个&#96;sockaddr&#96;类型的结构体指针，包含服务端IP+端口</span><br><span class="line"></span><br><span class="line">  - addrlen：表示sockaddr结构体的长度（协议地址长度）</span><br><span class="line"></span><br><span class="line">  - 通过此函数建立于TCP服务器的连接，实际是发起三次握手过程，仅在连接成功（&#96;状态从SYN-SENT转为ESTABLISHED&#96;）或失败后返回</span><br><span class="line"></span><br><span class="line">    :warning:UDP的connect函数没有三次握手过程，内核只是记录对方的ip和端口号，他们包含在传递给connect的套接口地址结构中，并立即返回给客户端</span><br><span class="line"></span><br><span class="line">- &#96;&#96;&#96;cpp</span><br><span class="line">  int close(int fd);</span><br></pre></td></tr></table></figure>- 服务结束，客户端调用断开fd指定的socket连接，立即返回；但尝试将发送缓冲区的数据进行发送，最后再4次挥手- 服务端一般close的是用于和对应客户端传输数据的`已连接socket`，而监听socket一直存在，除非关闭服务器</code></pre></li></ul><h3>Socket缓冲区</h3><h4>数据收发</h4><p>Linux环境下不区分套接字和普通文件的读写，一律使用read/write方法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>read 函数是负责从socket中读取nbytes字节的内容到buf，理解为客户端接收服务端的数据，win中对应recv()</li><li>当读成功时，read 返回实际所读的字节数</li><li>如果返回的值是 0 表示已经读到文件的结束了，小于 0 表示出现了错误</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>write 函数将 buf 中的nbytes个字节的内容写入socket，理解为客户端向服务端发送数据，win中对应send()</li><li>成功时返回写的字节数，返回值大于 0，表示写了部分或者是全部的数据；失败时返回 -1</li></ul><h4>缓冲区</h4><p>🔗<a href="http://c.biancheng.net/cpp/html/3040.html">http://c.biancheng.net/cpp/html/3040.html</a></p><p>⚠️每个 socket 被创建后，都会分配两个缓冲区，输入（接收）缓冲区和输出（发送）缓冲区</p><ul><li><p>write()只是将要发送的数据暂时<code>写入发送缓冲区</code>就直接返回，不管数据是否真正发送，之后由TCP协议将数据从缓冲区再发送到目标机器</p></li><li><p>数据有可能刚被写入缓冲区就发送到网络，也可能在缓冲区中不断积压，多次写入的数据被一次性发送到网络</p></li><li><p>read()同理，接收端只是<code>从接收缓冲区中读取</code>数据，而不是直接从网络中读取</p></li></ul><p>I/O缓冲区特性如下：</p><ul><li>I/O缓冲区在每个TCP套接字中单独存在；</li><li>I/O缓冲区在创建套接字时自动生成；</li><li>即使关闭套接字也会继续传送发送缓冲区中遗留的数据；</li><li>关闭套接字将丢失接收缓冲区中的数据。</li></ul><h3>I/O模型</h3><p>一个输入（read）操作通常包括两个阶段：</p><ul><li>等待数据准备好（数据到达socket接收缓冲区）</li><li>从内核向进程复制数据（将socket接收缓冲区中的数据read到进程缓冲区）</li></ul><p>Unix I/O有五种模型：</p><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200730155939005.png" alt="IO"></p><h4>阻塞式I/O</h4><p>TCP套接字默认为阻塞模式，只是阻塞当前进程，其他进程正常占用CPU时间运行，CPU利用率高：</p><ul><li>read()/recv()<ul><li>接收缓冲区有数据则read，否则阻塞，直到数据到来</li><li>需要read的数据长度小于接收缓冲区中数据长度，缓冲区中数据将积压，等待再次read</li><li>一旦成功read到数据，则返回，否则一直阻塞</li></ul></li><li>write()/send()<ul><li>发送缓冲区可用长度小于数据长度，write阻塞，直到缓冲区数据被发送，腾出空间后再write</li><li>TCP正在向网络发数据，发送缓冲区被锁定，write同样阻塞，直到发送完毕，缓冲区解锁后再write</li><li>数据长度大于发送缓冲区最大长度，数据将分批发送</li><li>直到所有数据已经被write到发送缓冲区后，write再返回</li></ul></li></ul><h4>非阻塞式I/O</h4><p>轮询（polling）：</p><ul><li>进程执行系统调用后，发现socket缓冲区无法进行读写操作，内核返回一个错误码</li><li>此时应用进程可以继续执行，但是需要<code>不断的执行系统调用</code>来获知 I/O 是否完成，CPU利用率低</li></ul><h4>I/O复用</h4><p>使用 select 或者 poll 等待（阻塞）<code>多个套接字中的任何一个</code>缓冲区变为可操作，从而让单个进程具有处理多个 I/O 事件的能力</p><ul><li>没有 I/O 复用，每个 Socket 连接都要创建一个线程处理</li><li>同时有几万个连接，那么就需要创建相同数量的线程</li><li>相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销</li></ul><p>select/poll/epoll 都是 I/O 多路复用的具体实现：</p><table><thead><tr><th>I/O复用</th><th>速度</th><th>监听描述符数量</th><th>其他</th><th>移植性</th><th>应用场景</th></tr></thead><tbody><tr><td>select</td><td>慢（拷贝全部fd）</td><td>1024</td><td>会修改描述符</td><td>所有系统几乎支持</td><td>实时性高，fd数量少</td></tr><tr><td>poll</td><td>慢（拷贝全部fd）</td><td>无限制</td><td>不会修改</td><td>较新的系统</td><td>fd数量多，活跃多</td></tr><tr><td>epoll</td><td>快（处理就绪fd）</td><td>无限制</td><td>修改描述符状态</td><td>Linux</td><td>fd数量多，但活跃的少</td></tr></tbody></table><p><a href="https://wendeng.github.io/2019/06/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8Eepoll%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/">IO多路复用与epoll原理探究</a></p><p>同步IO：阻塞、非阻塞、信号、IO复用</p><p>同步IO与异步IO：</p><ul><li>同步：由用户进程将数据从内核缓冲区拷贝到用户空间</li><li>异步：由内核负责拷贝数据到用户空间，完成后直接通知用户进程</li></ul><p>阻塞IO与非阻塞IO：主要针对同步IO</p><ul><li>阻塞：IO操作完成后，返回用户空间进行后续操作</li><li>非阻塞：调用IO操作后直接返回状态值，用户进程无需等待</li></ul><h5 id="select">select</h5><p>fd_set的数据结构，实际上是一个long类型的数组，每一位代表一个对应的文件描述符</p><p>缺点：</p><ul><li>每次调用select，需要把fd_set整个集合从用户态拷贝到内核态</li><li>fd多但活跃少时，效率低</li><li>fd增多，遍历集合开销增大</li><li>大小受限，1024个fd，若修改可能重新编译内核</li></ul><h5 id="poll">poll</h5><p>唯一改进select受限，fd理论65535</p><h5 id="epoll">epoll</h5><p>fd-65535，epoll_ctrl不太频繁调用，epoll_wait是非常频繁调用</p><ul><li><strong>水平触发（LT）</strong>：默认工作模式，表示当epoll_wait检测到某描述符事件就绪并通知应用程序时，应用程序可以不立即处理该事件；下次调用epoll_wait时，会再次通知此事件。</li><li><strong>边缘触发（ET）</strong>： 当epoll_wait检测到事件就绪并通知应用程序时，应用程序必须立即处理该事件。如果不处理，下次调用epoll_wait时，不会再次通知此事件。边缘触发只在状态由未就绪变为就绪时只通知一次。</li></ul><p><strong>核心数据结构在于红黑树+双向链表</strong></p><h5 id="使用场景">使用场景</h5><ul><li>fd数目较小，且都比较活跃用select，超过1024用poll；</li><li>fd数目非常大，且单位时间只有小一部分fd处于就绪状态，这个时候使用epoll</li></ul><h4>信号驱动I/O</h4><ul><li>应用进程使用 sigaction 系统调用，内核立即返回，应用进程可以继续执行（非阻塞）</li><li>当缓冲区收到数据，<code>内核向应用进程发送 SIGIO 信号</code>，进程收到之后从缓冲区read数据（<code>可以开始进行I/O操作</code>）</li><li>相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高</li></ul><h4>异步I/O</h4><ul><li>应用进程执行 aio_read 系统调用会立即返回，应用进程可以继续执行（非阻塞）</li><li>内核会在<code>所有操作完成</code>之后向应用进程发送信号（<code>I/O操作已经完成</code>）</li></ul><h3>TCP协议下Socket交互流程</h3><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200728104947260.png" alt="Socket"></p><ul><li>服务端根据地址类型、协议类型调用socket()创建主动套接字</li><li>服务端调用bind()为创建的套接字绑定IP和端口</li><li>服务端调用listen()将主动socket转为监听socket，该socket仅用于监听客户端请求并建立连接，此时服务端状态由CLOSED转为LISTEN</li><li>服务端继续调用accept()，由于已连接队列为空，进入阻塞，等待客户端连接</li><li>客户端创建socket后根据服务端IP+端口调用connect()请求连接，此时客户端状态从CLOSED转为SYN-SENT</li><li>服务端的监听套接字收到客户端socket请求后，状态转为SYN-RCVD，并将连接信息计入未完成连接队列，发送ack和自身syn请求</li><li>客户端收到后，connect()返回成功，状态转为ESTABLISHED，并向服务端发送ack</li><li>服务端收到ack后，accept()返回成功，并由内核创建已连接socket用于数据传输，状态转为ESTABLISHED，并将连接信息计入已连接队列</li><li>至此连接建立，下面数据传输read/write套接字</li><li>----------=======================================================================================================================================================================================================================================</li><li>交互结束，客户端调用close()断开连接，方法直接返回，并最后将发送缓冲区的数据发完后，关闭socket，四次挥手CLOSED</li><li>服务端调用close()关闭对应的socket连接，连接信息从已连接队列移除，监听socket继续监听接受下一次客户端的连接</li></ul><h2>应用层</h2><p>应用层协议定义不同主机进程之间的交互规则</p><h3>DHCP协议</h3><p>基于UDP，动态主机配置协议，自动配置IP、掩码、网关IP，流程如下：</p><ul><li>客户端在局域网广播发送Discover报文，如果DHCP服务器和客户端不在同一子网，还需要中继代理</li><li>服务端收到后发送给客户端的Offer报文中包含IP信息（IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码）</li><li>客户端可能受到多个Offer，需进行选择；然后给一个服务端发送Request报文</li><li>服务端收到后，再回发ack确认报文，表明客户端可以使用提供的IP信息</li><li>客户端最后收到ack确认报文，即可开始使用动态分配的IP</li></ul><h3>DNS协议</h3><p>🔗<a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/14/">http://docs.52im.net/extend/docs/book/tcpip/vol1/14/</a></p><p>🔗<a href="https://developer.aliyun.com/article/396757">https://developer.aliyun.com/article/396757</a></p><ul><li><p>DNS系统：分布式的数据库，每个站点只保留自己的数据</p></li><li><p>域名解析器：通常是应用程序的一部分，Unix中库函数gethostbyname接收主机名返回IP，gethostbyaddr通过IP查找主机名</p></li><li><p>域名服务器：一个区域包含一个主域名服务器和至少一个辅助域名服务器，独立且冗余</p></li><li><p>域名解析：实现主机名和IP地址的互相转换，端口53，UDP传输</p></li><li><p>高速缓存：一个域名服务器收到主机和IP的映射时放入缓存，减少DNS通信量，缓存记录字段如下：</p><ul><li><p>TTL：表示该记录被其他DNS服务器缓存的时间</p></li><li><p>Type：A、NS、CNAME、MX，对应的Name-Value意义如下：</p><table><thead><tr><th>Type</th><th>Name</th><th>Value</th></tr></thead><tbody><tr><td>A</td><td>主机名</td><td>主机IP（列表），标准的主机名到 IP 地址映射</td></tr><tr><td>NS</td><td>域名</td><td>负责该域名的 DNS 服务器的主机名</td></tr><tr><td>CNAME</td><td>别名</td><td>规范的主机名，针对复杂的主机名提供便于记忆的简单别名</td></tr><tr><td>MX</td><td>邮件服务器别名</td><td>邮件服务器的规范主机名</td></tr></tbody></table></li></ul></li></ul><p>⚠️多数情况使用UDP进行传输，要求域名解析器和域名服务器自己保证可靠性</p><p>🚨以下情况使用TCP传输：</p><ul><li><p>返回的响应超过512字节（删减标志位TC=1），域名解析器使用TCP重新发送查询</p><p>⚠️512字节保证UDP报文不会在IP层因为MTU限制而分片，这个限制可通过扩展的DNS协议打破🔗<a href="https://www.cnblogs.com/protosec/p/11673326.html">https://www.cnblogs.com/protosec/p/11673326.html</a></p></li><li><p>辅助域名服务定时（3h）向主域名服务器查询数据是否变动，如果发生变动则进行<code>区域传送</code>，数据量往往很大，使用TCP</p></li></ul><h4>负载均衡</h4><p>大型网站一个域名对应多个IP地址，DNS请求时返回<code>域名对应的IP集合</code>，客户端一般选择最前面的IP发送请求，类似循环队列放入队尾来均分DNS服务端压力</p><h4>查询过程</h4><p>域名层次结构：主机名.次级域名.顶级域名.根域名</p><ul><li>先将DNS请求发送至本地DNS服务器（<code>递归查询</code>，用户只发送一次请求），缓存中无记录，则向根域名发送查询请求（<code>迭代查询</code>）</li><li>根域名服务器返回对应顶级域名服务器IP列表，本地DNS服务器向其中一个顶级服务器发送查询请求（返回，继续迭代查询）</li><li>顶级域名服务器返回对应权威（次级）域名服务器IP列表，本地DNS服务器向其中一个服务器发送查询请求（返回，继续迭代查询）</li><li>权威域名服务器返回一个对应的主机名的 IP 地址列表，最后本地DNS服务器返回给客户端（返回，迭代结束，递归开始回溯）</li></ul><h3>HTTP协议</h3><p>超文本传输协议HTTP基于TCP，定义客户端和服务器之间交换报文的格式和方式，默认使用 80 端口</p><p>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息</p><h4>请求报文</h4><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200729184918746.png" alt="请求"></p><ul><li><p>首行为请求行：<code>GET /index.html HTTP/1.1</code>，第二项为请求的资源页面，第三项为HTTP版本</p><ul><li><p>GET：HTTP方法，常用如下：</p><table><thead><tr><th>请求类型</th><th>作用</th></tr></thead><tbody><tr><td>GET</td><td>获取资源</td></tr><tr><td>POST</td><td>传输实体主题（提交一个表格），可能导致新资源建立或已有资源修改</td></tr><tr><td>HEAD</td><td>获取报文首部（不包含资源），确认URL有效、资源更新时间等</td></tr><tr><td>PUT</td><td>上传文件，无验证机制，不安全；完全替换原始资源，一般不用</td></tr><tr><td>DELETE</td><td>删除指定文件，无验证机制</td></tr><tr><td>PATCH</td><td>不同于PUT，支持部分修改资源</td></tr><tr><td>OPTIONS</td><td>查询URL支持的方法，返回类似：Allow: GET, POST, HEAD, OPTIONS</td></tr><tr><td>CONNECT</td><td>与代理服务器通信时建立隧道，使用SSL和TLS协议把通信内容加密后经网络隧道传输</td></tr><tr><td>TRACE</td><td>追踪路径，服务器返回通信路径，易受攻击</td></tr></tbody></table></li></ul></li><li><p>之后为请求头，与请求行构成请求信息头</p></li><li><p>最后为请求信息体，与信息头中间空了一行</p></li></ul><h5 id="GET和POST区别">GET和POST区别</h5><table><thead><tr><th>对比维度</th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>作用</td><td>获取资源</td><td>传输实体主体</td></tr><tr><td>参数</td><td>以查询字符出现在URL中</td><td>存储在实体主体中</td></tr><tr><td>安全</td><td>不会改变服务器状态，安全</td><td>上传表单后，服务器进行存储，状态改变，不安全</td></tr><tr><td>幂等性</td><td>执行多次效果一样，服务器状态也一样，幂等</td><td>执行多次增加多次记录，非幂等</td></tr><tr><td>可缓存</td><td>GET方法本身可以缓存</td><td>POST 在多数情况下不可缓存的</td></tr><tr><td>报文格式</td><td>报文中实体部分为空</td><td>实体部分一般为向服务器发送的数据</td></tr></tbody></table><h4>响应报文</h4><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200729185319862.png" alt="响应"></p><ul><li><p>首行为状态行：<code>HTTP/1.1 200 OK</code>，第一项为版本</p><ul><li><p>200 OK：状态码，常用如下：</p><table><thead><tr><th>状态码</th><th>类别</th><th>含义</th></tr></thead><tbody><tr><td>100 Continue</td><td>信息性状态码</td><td>一切正常</td></tr><tr><td>200 OK</td><td>成功状态码</td><td>请求正常处理完毕</td></tr><tr><td>3XX</td><td>重定向状态码</td><td>需进行额外操作来完成请求</td></tr><tr><td>404 Not Found</td><td>客户端错误状态码</td><td>请求的页面没找到</td></tr><tr><td>403 Forbidden</td><td>客户端错误状态码</td><td>请求被拒绝</td></tr><tr><td>401 Unauthorized</td><td>客户端错误状态码</td><td>发送的请求需要有认证信息，如果之前已进行过一次请求，则表示用户认证失败</td></tr><tr><td>400 Bad Request</td><td>客户端错误状态码</td><td>请求报文中存在语法错误</td></tr><tr><td>500 Internal Server Error</td><td>服务器错误状态码</td><td>服务器执行请求时发生错误</td></tr><tr><td>503 Service Unavailable</td><td>服务器错误状态码</td><td>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求</td></tr></tbody></table></li></ul></li><li><p>之后为回复头，与状态行构成回复信息头</p></li><li><p>最后为回复信息体，即请求的页面，同样与信息头隔了一行</p></li></ul><h4>连接方式</h4><ul><li><p>长/短连接</p><ul><li>短连接：HTTP/1.1之前默认短连接，每一次HTTP通信新建一个TCP连接，使用 <code>Connection : Keep-Alive</code>长连接，有一个保持时间</li><li>长连接：HTTP/1.1开始默认长连接，只需要建立一次 TCP 连接就能进行多次 HTTP 通信，使用 <code>Connection : close</code>断开连接</li></ul></li><li><p>流水线</p><ul><li>HTTP 请求默认按顺序发出，上一个请求收到响应后才能发出下一个请求</li><li>受网络延迟和带宽限制，下一个请求就可能需要等待很长时间</li><li>流水线是在<code>同一条长连接上连续发出请求</code>，不用等待响应返回，减少延迟</li></ul></li></ul><h4>Cookie</h4><p>HTTP协议本身无状态，简单的协议更能处理大量事务。1.1开始引入Cookie保存状态信息</p><ul><li>Cookie 是服务器发送到用户浏览器并<code>保存在本地</code>的一小块数据</li><li>之后每次向同一服务器再次发起请求时被携带，告知服务端请求是否来自同一浏览器，因此会带来额外的性能开销</li><li>随着浏览器支持的存储方式多样化，Cookie 渐渐被淘汰</li></ul><h4>Session</h4><p>利用 Session 将用户信息<code>存储在服务器端</code>的文件、数据库或者内存，也可以存在 Redis内存型数据库中，效率更高，更安全</p><p>Session 维护用户登录状态过程：</p><ul><li>用户登录提交包含用户名和密码的表单，放入 HTTP 请求报文</li><li>服务器验证用户信息，如果正确则存储到 Redis 中，其中的Key 称为 Session ID</li><li>服务器返回的响应报文中Set-Cookie首部字段包含Session ID，客户端收到后将该 Cookie 值存入浏览器</li><li>客户端之后对同一服务器发送的请求包含该 Cookie 值，服务器收到之后提取对应Session ID，进一步从 Redis 中查找用户信息并返回</li></ul><p>⚠️Session ID经常重新生成以保证安全，另按照安全性要求还会额外附加验证码、登录的操作</p><p>🚨cookie和session对比：</p><ul><li>Cookie 只能存 ASCII 码，Session对数据类型无限制</li><li>Cookie 存储在浏览器中安全性低，可将 Cookie 值加密，在服务器解密</li><li>用户所有信息都存储在 Session 中开销非常大</li></ul><h4>HTTP/1.1缺点</h4><ul><li>长连接情况下多个请求复用同一个TCP连接，连接中的通信次序是固定的</li><li>服务器按次序挨个处理请求，如果前面请求响应慢，则之后的请求都在排队等待（队头阻塞）</li><li>避免：减少请求数，同时打开多个长连接</li></ul><h4>HTTP/2</h4><p>二进制协议（头信息和数据体都是二进制，统称为“帧”），而1.1版本报头信息必须是ASCII文本</p><ul><li>同样复用TCP连接，但连接双方均可<code>不用按照次序同时发送多个请求或响应</code>，解决队头阻塞问题</li><li>由于无序，则需要对包中的数据做标记，将每个请求或回应的所有数据包称为一个<code>数据流</code>并通过唯一编号进行区分</li><li>通过<code>头信息压缩</code>提高速度；另外通过<code>服务器推送</code>主动向客户端推送静态资源</li></ul><p>缺点：多个数据流复用同一个TCP连接，一个流进入拥塞，之后的流均被阻塞（与本身设计无关，TCP协议的问题）</p><ul><li>HTTP/3 协议：基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上。 QUIC 协议在 UDP 协议上实现了多路复用、有序交付、重传等等功能</li></ul><p>HTTP协议缺点：</p><ul><li>报文为明文，容易被获取，获取后易被修改</li><li>通信双方没有认证，容易被冒充</li></ul><h3>HTTPS协议</h3><ul><li>HTTPS 是基于 HTTP 协议，使用 TLS/SSL 来对数据加密</li><li>提供了一种校验机制检测信息是否被篡改</li><li>通过身份证书防止被冒充</li></ul><p>🔗<a href="https://zhuanlan.zhihu.com/p/43789231">https://zhuanlan.zhihu.com/p/43789231</a></p><h4>TLS握手</h4><ol><li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的<code>一个随机数</code>、以及客户端支持的加密方法</li><li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的<code>证书</code>、以及一个<code>服务器生成的随机数</code></li><li>客户端确认服务器证书有效后，生成<code>一个新的随机数</code>，并使用<code>数字证书中的公钥</code>加密这个随机数，最后将<code>Hash后的值</code>发给服务器用来供服务器检验</li><li>服务器使用自己的私钥解密客户端发送过来的随机数，并提供前面<code>所有内容的 hash 值</code>来供客户端检验</li><li>客户端和服务器端根据约定的加密方法使用前面的<code>三个随机数生成对话秘钥</code>，以后的对话过程都使用这个秘钥来加密信息</li></ol><h4>实现原理</h4><p>TLS 的握手过程主要用到了三个方法来保证传输的安全：</p><ul><li>对称加密：双方使用同一个秘钥对数据进行加密和解密，但秘钥还是会通过网络传输</li><li>非对称加密：公钥公开，私钥保密，使用公钥对数据进行加密，使用私钥进行解密，但是加密过程慢</li><li>两者结合：对称加密无法保证秘钥安全传输，因此<code>非对称加密用于对称加密的秘钥</code>，而通信使用对称加密的方式来加密</li></ul><p>⚠️没有办法确定公钥是安全的，公钥也可以被截获后伪装</p><h4>数字证书</h4><p>最重要的是CA（认证中心）的可靠性，浏览器内置一些顶层的认证中心的证书</p><ul><li><p>使用Hash算法<code>对公钥等信息加密生成信息摘要</code></p></li><li><p>CA 用自己的<code>私钥对信息摘要加密形成数字签名</code></p></li><li><p>信息摘要+数字签名=数字证书</p></li><li><p>接收方对收到的数字证书作如下处理：</p><ul><li>取得数字证书中的信息摘要，并使用同样的 Hash 算法生成一个摘要</li><li>使用CA的公钥来对数字证书中的数字签名进行解密</li></ul><p>🚨CA的公钥也是通过数字证书验证，浏览器添加信任的CA公钥对应的证书</p><ul><li>将解密的摘要和生成的摘要进行对比，从而确定公钥是否被更改</li></ul></li></ul><h5 id="为啥要Hash">为啥要Hash</h5><p>证书信息hash之后，数据为定长，此时进行加密解密就很快</p><h5 id="每次请求都要TLS握手？">每次请求都要TLS握手？</h5><p>使用session，在服务器存储密钥到对应的session ID，客户端每次请求携带ID，服务端查询密钥解密即可</p><h3><a href="http://www.google.com">www.google.com</a>(Web请求过程)</h3><p>🔗<a href="http://www.178linux.com/1055">http://www.178linux.com/1055</a></p><p>URL合法性检验</p><ul><li>分析所需要使用的传输协议和请求的资源的路径</li><li>如果资源已经在缓存中并且没有失效就直接使用，否则再发起新的请求</li></ul><p>DHCP配置主机信息</p><ul><li>如果主机还没有IP信息，则通过DHCP配置主机信息</li><li>主机发送广播，封装为DHCP请求报文，DHCP服务器收到后返回IP相关信息</li><li>双方经过确认后（参考DHCP流程），主机可以开始使用IP地址发送报文了</li></ul><p>ARP获取网关MAC地址</p><ul><li><p>DHCP返回信息中只包含网关的IP地址，因此还需要ARP协议解析出MAC地址</p></li><li><p>ARP缓存中找不到网关IP对应MAC地址，则主机ARP广播自身IP和MAC，询问网关IP的MAC</p></li><li><p>网关收到后向主机返回自己的MAC地址，主机可以向网关发送DNS请求了</p></li></ul><p>DNS解析URL获取目的IP</p><ul><li>知道网关MAC后，如果本地没有URL对应IP地址缓存，则主机向网关发送DNS请求，网关根据转发表确认下一跳转发</li><li>路由器包含内外网关协议，因此无论DNS服务器在内外网，经过网关路由器转发一定可以到达DNS服务器</li><li>DNS服务器收到查询请求后，如果缓存中找不到域名对应IP，则进行迭代查询</li><li>DSN服务端收到权威域名服务器返回的IP地址集合后，转到网关路由器最终到达主机，主机获得目的IP地址</li></ul><p>ARP获取目的主机MAC地址</p><ul><li>由于应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号</li><li>然后下发给网络层，网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址</li><li>然后下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机MAC地址作为源MAC地址</li><li>目的 MAC 地址分情况处理：<ul><li>通过将 IP 地址与我们本机的子网掩码相与，判断是否与请求主机在同一个子网</li><li>在同一个子网，使用 APR 协议获取到目的主机的 MAC 地址</li><li>不在一个子网，请求应该转发到网关，最终通过多次转发后ARP请求发给目的主机</li><li>目的主机发送自己的MAC地址到源主机</li></ul></li></ul><p>获取到Web服务器IP后，主机作为客户端和服务端进行TCP三次握手过程</p><p>如果使用HTTPS，正式通信之前还额外需要TLS握手来保证传输的安全性</p><p>HTTP请求页面</p><ul><li>TCP连接建立，TLS握手成功之后，浏览器生成HTTP GET报文，并发送到Web服务端</li><li>服务端收到请求后，从TCP socket读取GET报文，将请求的页面作为数据封装为HTTP响应报文，发送回主机</li><li>主机浏览器收到后，抽取出页面数据并进行渲染，最终显示Web页面</li></ul><p>最终通信结束，四次握手释放连接</p><h1>面经补充</h1><h2>服务端大量TIME-WAIT</h2><p>🔗<a href="https://www.cnblogs.com/dadonggg/p/8778318.html">https://www.cnblogs.com/dadonggg/p/8778318.html</a></p><p>🔗<a href="https://blog.csdn.net/acs713/article/details/28427181">https://blog.csdn.net/acs713/article/details/28427181</a></p><p>🔗<a href="https://jishuin.proginn.com/p/763bfbd25a93">https://jishuin.proginn.com/p/763bfbd25a93</a></p><p>出现场景：<code>高并发短连接的HTTP请求</code></p><p>🔴 如果 <code>connection 头部取值被设置为 close </code>时，基本都由<code>「服务端」发起主动关闭连接</code></p><p>HTTP短连接如果由服务端发出FIN信号，则在高并发情况下，服务端会出现大量TIME-WAIT状态</p><ul><li>如果此时服务端重启，则之前TIME-WAIT链接还没断开，对应端口还未释放</li><li>当服务端再次尝试bind相同端口时，端口绑定失败，客户端也就链接失败</li></ul><h2>服务端大量CLOSE-WAIT</h2><p>作者：小谷围coder<br>链接：<a href="https://www.nowcoder.com/discuss/489210?channel=666&amp;source_id=home_feed">https://www.nowcoder.com/discuss/489210?channel=666&amp;source_id=home_feed</a><br>来源：牛客网</p><p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p><ul><li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li><li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li></ul><p>处理方法：</p><ul><li>停止应用程序</li><li>修改程序里的bug</li></ul><h2>SO_REUSEADDR和SO_REUSEPORT</h2><p>🔗<a href="https://zhuanlan.zhihu.com/p/37278278">https://zhuanlan.zhihu.com/p/37278278</a></p><p>服务端调用<code>bind</code>时增加的参数</p><p>SO_REUSEADDR：字面意思re use addr，地址重用</p><ul><li>确保当服务端出现timewait状态的链接时，server能够重启成功</li></ul><p>⚠️如果不需要2MSL等待时间，而需要<code>立即释放端口</code>，也可以设置该参数</p><p>SO_REUSEPORT：re use port，端口重用</p><ul><li><p>使得多进程/线程创建多个绑定同一个ip:port的监听socket，<code>提高服务器的并发能力</code></p></li><li><p>每一个进程有一个独立的监听socket，并且bind相同的ip:port，独立的listen()和accept()</p></li><li><p>避免了惊群效应</p></li></ul><h2>惊群效应</h2><p>🔗<a href="https://www.yanxurui.cc/posts/linux/2017-09-07-thundering-herd-and-reuseport/">https://www.yanxurui.cc/posts/linux/2017-09-07-thundering-herd-and-reuseport/</a></p><p>惊群（thundering herd）问题：</p><ul><li>多个进程等待同一个事件（比如同一个socket的可读事件）</li><li>当事件发生时，内核唤醒所有的进程，但该事件只需要被一个进程处理</li><li>浪费CPU资源</li></ul><p><img src="/2020/09/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/listen_accept_reuseport.png" alt="listen_accept_reuseport.png"></p><p>当SO_REUSEPORT选项启用时：</p><ul><li>每个进程都创建<code>独立的listening socket</code>，监听<code>相同的ip端口</code></li><li>accept的时候只有一个进程会获得连接。这样就可以避免加锁的开销，提高CPU利用率</li></ul><h2>可靠UDP</h2><p>🔗<a href="https://www.jianshu.com/p/6c73a4585eba">https://www.jianshu.com/p/6c73a4585eba</a></p><p>UDP本身在传输层，不可靠，因此需要在应用层实现可靠传输</p><ul><li>添加seq/ack机制，确保数据发送到对端</li><li>添加发送和接收缓冲区，主要是用户超时重传</li><li>添加超时重传机制</li></ul><p>详细说明：</p><ol><li>发送数据时，生成一个<code>随机seq</code>=x，然后每一片<code>按照数据大小分配seq</code></li><li>数据到达接收端后放入<code>接收端缓存</code>，并发送一个ack=x的包，表示对方已经收到了数据</li><li>发送端收到了ack包后，删除缓冲区对应的数据，发送下一个字段</li><li>超时时间到后，定时任务检查是否需要重传数据</li></ol>]]></content>
    
    
    <summary type="html">记录计算机网络面试知识点</summary>
    
    
    
    
    <category term="计算机网络" scheme="https://vae1997.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点整理</title>
    <link href="https://vae1997.github.io/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>https://vae1997.github.io/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2020-09-25T08:36:05.000Z</published>
    <updated>2020-09-25T08:44:05.245Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>🔗<a href="https://cyc2018.github.io/CS-Notes/">cyc2018</a>、<a href="https://interview.huihut.com/#/?id=%f0%9f%92%bb-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f">huihut</a></p><h1>基本概念</h1><p>🔗<a href="https://juejin.im/entry/6844903464678457357">https://juejin.im/entry/6844903464678457357</a></p><h2>并发/并行</h2><p>并发：操作系统通过引入进程和线程，使得程序能够并发运行</p><ul><li>宏观上，能同时运行多个程序</li><li>微观上，<code>任意时刻</code>，有且仅有<code>一个程序</code>在运行</li><li>硬件环境：<code>一个CPU</code></li></ul><p>并行：需要硬件支持，如多流水线、多核处理器或者分布式计算系统</p><ul><li><code>同一时刻</code>能运行<code>多个程序</code></li><li>硬件环境中存在<code>多个CPU</code></li></ul><h2>阻塞/非阻塞</h2><p>阻塞：进程/线程的5个状态之一</p><ul><li>线程调用某个函数，需要<code>等待IO请求</code>或暂时<code>得不到竞争资源</code>时，操作系统会把该线程阻塞起来<ul><li>阻塞调用：调用者只有收到结果后才返回，否则一直阻塞，<code>socket的recv/read方法</code></li><li>非阻塞调用：调用的函数不会阻塞当前线程，而会立刻返回，<code>socket的send/write方法</code></li></ul></li><li>避免浪费CPU资源</li><li>等到得到了资源，再变成就绪状态，等待CPU调度运行</li></ul><p>阻塞和挂起：</p><ul><li>阻塞是被动的，比如抢不到资源</li><li>挂起是主动的，线程自己调用 suspend() 退出运行态，调用 resume() 恢复运行</li></ul><p>线程执行完就会被销毁，如果不想线程被频繁的创建，销毁，怎么办？</p><ul><li>可以给线程里面写个死循环</li><li>或者让线程有任务的时候执行，没任务的时候挂起</li></ul><h2>同步/异步</h2><p>同步和阻塞都是调用方法之后等待结果返回，但<code>同步调用时线程不一定阻塞</code></p><ul><li>同步调用虽然没返回，但线程还是在<code>运行状态</code>，CPU时间片尚未耗尽，很可能还在执行这段代码</li><li>阻塞调用时，线程已耗尽CPU时间片，失去CPU资源</li></ul><p>异步和非阻塞都是不必等待结果，函数直接返回</p><ul><li>异步调用时，如果还有CPU时间片，则继续执行；否则也会阻塞</li><li>非阻塞调用时，方法直接返回，并在CPU时间片内继续向下执行</li></ul><h2>基本特征</h2><p>并发、异步、共享、虚拟</p><p>共享：系统资源被多个并发进程使用，宏观上，“同时”共享；微观上，互斥共享</p><p>虚拟：一个物理实体转换为多个逻辑实体</p><ul><li>时分复用（并发）：一个CPU并发处理多个进程，进程轮流占用CPU</li><li>空分复用（虚存）：将物理内存抽象，每个进程都有各自的地址空间</li></ul><h1>进程/线程</h1><ul><li>进程：资源分配的基本单位，使用PCB（进程控制块）描述基本状态信息<ul><li>同一进程的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆空间）</li><li>一个进程崩溃时，一般不会造成其他进程崩溃</li><li>进程创建/切换时，开销大（创建/撤销时资源处理，切换时保护现场）</li><li>进程间通信需要IPC，切换使用进程表维护信息</li></ul></li><li>线程：资源调度的基本单位，使用TCB（线程控制块）描述基本状态信息<ul><li>每个线程拥有自己的栈段，又叫运行时段，用来存放局部变量和临时变量</li><li>一个线程的崩溃将会导致整个进程的崩溃</li><li>线程创建/切换时，系统开销相对较小</li><li>线程间可以直接读写同一进程内部数据通信，切换使用涉及线程表</li></ul></li></ul><h2>进程状态</h2><p>⚠️线程间的状态转换和进程是一样的</p><p><img src="/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/92.jpg" alt="状态转换"></p><ul><li>创建：一般通过系统调用fork创建进程，为进程分配资源后，进入就绪状态</li><li>就绪：进程已经拿到全部资源，等待CPU分配时间片被调度，进入运行状态</li><li>运行：<ul><li>进程正常结束/抛出异常，进入终止状态</li><li>进程等待IO操作/事件/资源，<code>主动放弃CPU</code>，进入阻塞状态</li><li>进程CPU时间片用完/被抢占，进入就绪状态</li></ul></li><li>阻塞：进程等待的事件完成/拿到需要的资源后，进入就绪状态</li></ul><h2>进程调度</h2><p>批处理系统：用户操作少，进程调度<code>保证任务吞吐量和从提交到终止的时间</code></p><ul><li>先来先服务（FCFS）：非抢占、按进程请求顺序调度<ul><li>短作业等长作业完成再执行，<code>短作业等待时间长</code></li></ul></li><li>短作业优先：非抢占、按进程预估的运行时间从短到长调度<ul><li>如果一直有短作业，则<code>长作业永远不能执行</code></li></ul></li><li>最短剩余时间优先：抢占式<ul><li>系统没新进程，当前进程运行完毕，继续下一个剩余时间最短的进程</li><li>新进程还未运行，其总的运行时间比当前进程剩余运行时间少，则抢占CPU；否则新进程等待</li></ul></li></ul><p>交互式系统：大量用户操作，调度保证<code>快速响应</code></p><ul><li><p>时间片轮转：就绪进程按照FCFS排入队列</p><ul><li>从队首拿进程运行，时间片用尽后，当前进程放入队尾，继续执行队首进程</li></ul><p>⚠️效率和CPU时间片大小有关：</p><ul><li>取太小，响应快，但进程切换频繁，增加耗时，CPU利用率低</li><li>取太大，CPU利用率高，但无法确保及时响应</li></ul></li><li><p>优先级调度：根据进程的优先级进行调度</p><ul><li>优先级随着等待时间的增加而变高，避免低优先级无法调度</li></ul></li><li><p>多级反馈队列：多层队列，优先级从高到低，时间片由小到大</p><ul><li>上一层队列无进程，再执行当前队列</li><li>新进程进入第一层队尾，耗尽时间片后，进程加入下一层队尾</li><li>当前已经是最后一层，则接入队尾</li></ul></li></ul><h2>进程同步</h2><p>🔗<a href="https://www.ibm.com/developerworks/cn/linux/l-synch/part1/">https://www.ibm.com/developerworks/cn/linux/l-synch/part1/</a></p><p>并发的进程对资源的异步访问顺序不确定，因此需要同步机制使得进程有先后执行次序</p><ul><li>临界资源：每次只允许一个进程访问的资源</li><li>临界区：对临界资源进行访问的代码段</li><li>互斥：多进程同一时刻只允许一个进程进入临界区</li></ul><h3>原子操作</h3><p>原子操作绝<code>不会</code>在执行完毕前被任何其他任务或事件<code>打断</code>（最小的执行单位）</p><ul><li>原子操作通常用于实现资源的<code>引用计数</code>（共享指针shared_ptr）</li></ul><h3>信号量</h3><p>🔗<a href="https://www.jianshu.com/p/836fe237efbf">https://www.jianshu.com/p/836fe237efbf</a></p><p>对其进行原子操作up/down</p><p>整型信号量：只能执行初始化/P/V三种操作</p><ul><li>不满足让权等待原则，发生<code>忙等</code></li><li>临界区外的进程在循环中确认信号量的值，占着CPU不释放，这是一种忙等状态</li></ul><p>记录型信号量：避免忙等</p><ul><li><p>down：信号量-1（P操作）</p><ul><li>大于0，则当前进程可继续执行，直到离开临界区后执行up</li><li>小于0，进程挂起（调用<code>block原语</code>进入阻塞），加入<code>信号量的等待队列</code>，此时信号量的值表示等待的进程数</li><li>等于0，信号量被用完，但没有等待该信号量的进程</li></ul></li><li><p>up：信号量+1（V操作）</p><ul><li>大于0，表示可用信号量数</li><li>小于等于0，调用<code>wakeup原语</code>唤醒等待队列中第一个进程（就绪）</li></ul></li></ul><blockquote><p>Linux内核的信号量在概念和原理上与用户态的System V的IPC机制信号量是一样的，但是它绝不可能在内核之外使用，因此它与System V的IPC机制信号量毫不相干</p></blockquote><p>互斥量：信号量取值0/1，0表示临界区加锁；1临界区解锁</p><p>⚠️信号量实现互斥/同步</p><ul><li>互斥：针对不同临界资源设置不同的互斥量，初始化为1<ul><li>进入临界区之前执行P操作，确保其他进程无法进入</li><li>离开临界区之后执行V操作，释放锁</li></ul></li><li>同步：多个进程根据不同的前后关系，设置不同的同步信号量<ul><li>前进程执行之后，执行V操作，如果不大于0，唤醒等待队列首个进程</li><li>后进程执行之前，执行P操作，如果为负值，则阻塞，等待前操作完成执行V</li></ul></li></ul><h3>生产者消费者</h3><p>一个互斥量 mutex 来控制对缓冲区的互斥访问</p><p>一个信号量empty表示空余缓冲区数量</p><p>一个信号量full表示非空缓冲区数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mutex = <span class="number">1</span>;<span class="comment">//互斥量初始化为1，表示缓冲区可访问</span></span><br><span class="line"><span class="keyword">int</span> empty = N;<span class="comment">//同步信号量，空缓冲区大小为N</span></span><br><span class="line"><span class="keyword">int</span> full = <span class="number">0</span>;<span class="comment">//同步信号量，产品数为0</span></span><br><span class="line"><span class="comment">//生产者</span></span><br><span class="line">producer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce();<span class="comment">//生产产品</span></span><br><span class="line">        P(empty);<span class="comment">//获取一块空余的缓冲区，如果为0，则阻塞，等待empty&gt;0</span></span><br><span class="line">        P(mutex);<span class="comment">//访问缓冲区,加锁，如果为0，等待解锁</span></span><br><span class="line">        insert();<span class="comment">//放入产品</span></span><br><span class="line">        V(mutex);<span class="comment">//访问完毕，解锁</span></span><br><span class="line">        V(full);<span class="comment">//产品增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line">consumer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full);<span class="comment">//消费一个产品，如果为0，阻塞，等待full&gt;0</span></span><br><span class="line">        P(mutex);<span class="comment">//访问缓冲区,加锁，如果为0，等待解锁</span></span><br><span class="line">        remove();<span class="comment">//拿出产品</span></span><br><span class="line">        consume();<span class="comment">//消费产品</span></span><br><span class="line">        V(mutex);<span class="comment">//访问完毕，解锁</span></span><br><span class="line">        V(empty);<span class="comment">//缓冲区空余数量增加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>读写信号量</h3><p>对访问者进行了细分，或者为读者，或者为写者</p><p>读者：进程持有信号量期间，只能对临界资源进行读操作</p><ul><li>同一个读写信号量的<code>读者数不受限制</code></li><li>当信号量没有被写者拥有或等待，任何读者均可获得该信号量；否则读者挂起</li></ul><p>写者：进程只要有写的需求，必须被归类为写者</p><ul><li>如果进程不需要写，可以降级为读者</li><li>当信号量<code>没有被写者拥有或等待，也没有读者拥有</code>，则一个写者才能获得该信号量；否则写者挂起（排他、独占）</li></ul><h3>自旋锁</h3><p>与互斥锁类似，任何时刻，最多只能有一个保持者，但不会引起调用者睡眠</p><ul><li><p>如果自旋锁已经被占用，调用者自己<code>循环并观察</code>锁是否被释放</p><p>⚠️<code>自旋锁保持锁时间非常短</code>，因此进程不需要睡眠，也不会出现忙等</p></li><li><p>自旋锁的效率远高于互斥锁</p></li><li><p>自旋锁保持期间无法抢占，而信号量和读写信号量保持期间是可以被抢占的</p></li></ul><p>应用场景：</p><ul><li>单核CPU-互斥锁，或进程需要长时间持有锁</li><li>大量进程短时间内持有锁-自旋锁，避免频繁唤醒</li></ul><p>此外还有读写锁、大读者锁、大内核锁、顺序锁等，参见<a href=":link:https://www.ibm.com/developerworks/cn/linux/l-synch/part2/">Linux 内核的同步机制</a></p><h2>进程通信</h2><p>Inter-Process Communication（IPC）</p><h3>管道</h3><p>实际上是在内存中开辟的固定大小的缓冲区</p><ul><li>各个进程互斥访问管道</li><li>管道满，才能读，写阻塞；管道空，才能写，读阻塞</li><li>数据读完后被抛弃，因此不能出现多个读进程</li></ul><p>无名管道：<code>半双工</code>通信，只能<code>父子/兄弟进程</code>（亲缘关系）间使用，实现<code>简单方便</code></p><ul><li>缺点：单向通信、有亲缘关系的进程之间、缓冲区有限</li></ul><p>有名管道（FIFO）：<code>半双工</code>，可在<code>任意关系</code>的进程间通信，缓冲区有限</p><h3>消息队列</h3><p>在内核中，存放消息的链表，由消息队列标识符标识</p><p>消息：进程间数据交换以格式化的消息为单位</p><ul><li>格式化消息类似“报文”，消息头包含发送进程ID、接收进程ID、消息类型、长度等</li></ul><p>消息传递方式</p><ul><li>直接通信：发送的消息直接进入接收进程的<code>消息缓冲队列</code></li><li>间接通信：消息先发送到一个<code>中间实体</code>（信箱），接收进程从信箱读消息</li></ul><p>优缺点：</p><ul><li>通过操作系统<code>发送消息原语/接收消息原语</code>进行数据交换，保证<code>消息收发同步</code></li><li>消息队列独立于读写进程存在，<code>避免</code>管道通信时因为同步而<code>阻塞</code></li><li>读进程根据消息类型有选择地接收消息</li><li>缺点：信息的复制需要额外消耗 CPU 的时间，不适宜于信息量大或操作频繁的场合</li></ul><h3>信号</h3><p>信号（Signals）是进程间通信机制中<code>唯一的异步通信</code>机制，异步通知进程一个事件已经发生</p><ul><li><p>进程收到信号后，任何非原子操作都将被中断（软中断）</p></li><li><p>进程执行定义的信号处理函数，没有定义则执行默认的</p></li></ul><h3>信号量</h3><p>信号量是一个计数器（数量有限），常作为一种锁机制控制多个进程/线程同步访问临界区</p><h3>共享内存</h3><p>进程间将同一文件映射到自身的虚拟地址空间中，实现对同一块内存的共享</p><ul><li>数据不需要在进程间复制，<code>最快的通信方式</code></li><li>需要<code>结合信号量</code>，同步访问共享内存</li><li>只能在同一个计算机系统中多进程共享，不方便网络通信</li></ul><h3>套接字</h3><p>常用于不同主机间进程的网络通信</p><p>优点：</p><ol><li>传输数据为字节级，传输数据可自定义，数据量小效率高</li><li>传输数据时间短，性能高</li><li>适合于客户端和服务器端之间信息实时交互</li><li>可以加密,数据安全性强</li></ol><p>缺点：需对传输的数据进行解析，转化成应用级的数据</p><h3>线程间的通信</h3><p>目的主要是用于线程同步，没有数据交换的机制</p><p>锁机制：互斥锁、读写锁、自旋锁、条件变量</p><ul><li>条件变量（condition）：可以以原子的方式阻塞进程，直到某个特定条件为真为止。对条件的测试是在互斥锁的保护下进行的。条件变量始终与互斥锁一起使用</li></ul><p>信号量、信号、屏障，屏障允许每个线程等待，直到所有的合作线程都达到某一点，然后从该点继续执行</p><h2><a href="https://blog.csdn.net/lishenglong666/article/details/8557215">多线程/多进程</a></h2><table><thead><tr><th>对比维度</th><th>多进程</th><th>多线程</th></tr></thead><tbody><tr><td>数据共享同步</td><td>数据共享复杂，需要用 IPC；数据是分开的，同步简单</td><td>共享进程数据，数据共享简单，同步复杂</td></tr><tr><td>内存、CPU</td><td>占用内存多，切换复杂，CPU 利用率低，资源占用大</td><td>占用内存少，切换简单，CPU 利用率高,资源占用小</td></tr><tr><td>创建销毁切换</td><td>创建销毁、切换复杂，速度慢</td><td>创建销毁、切换简单，速度很快</td></tr><tr><td>编程、调试</td><td>编程简单，调试简单</td><td>编程复杂，调试复杂</td></tr><tr><td>可靠性</td><td>进程间不会互相影响</td><td>一个线程挂掉将导致整个进程挂掉</td></tr><tr><td>分布式</td><td>适应于多核、多机分布式</td><td>适应于多核分布式</td></tr></tbody></table><ul><li>频繁创建销毁，用线程</li><li>大量计算，用线程</li><li>强相关，用线程，弱相关，用进程</li><li>多机分布，用进程，多核分布，用线程</li></ul><h1>死锁</h1><p>🔗<a href="https://zhuanlan.zhihu.com/p/61221667">https://zhuanlan.zhihu.com/p/61221667</a></p><p>进程间相互等待对方占用的资源，但都不释放已经持有的资源</p><h2>必要条件</h2><ul><li>互斥：一个资源只能被一个进程/线程使用</li><li>占有和等待：一个进程占了一个资源，占其他资源时阻塞，不会释放占的资源</li><li>不可抢占：一个被占的资源不能再被其他进程抢走，<code>不可抢占资源只能被显示释放</code></li><li>环路等待：若干进程/线程之间形成一种头尾相接的循环等待资源关系</li></ul><h2>处理方法</h2><h3>鸵鸟策略</h3><p>发生死锁的概率低，解决死锁的代价高，因此选择不做处理</p><h3>死锁检测/恢复</h3><p>不阻止死锁，当检测到死锁发生时，进行恢复</p><p>检测：</p><ul><li>进程只申请一个资源：当检测到环时，即发生死锁</li><li>进程申请多个资源：算法执行时标记进程，运行结束后还存在未标记的进程，即发生死锁<ul><li>寻找一个没有标记的进程，它所请求的资源小于等于系统剩余资源</li><li>如果找到，标记该进程，表示该进程当前可执行，并将其占用的资源释放（加入系统剩余资源）</li><li>如果没有找到，算法终止</li></ul></li></ul><p>恢复：</p><ul><li>抢占恢复：不通知原进程，强行占走资源，用完后送回，方式简单但难实现，不可取</li><li>回滚恢复：类似数据库对数据回滚操作，将每个检测点写入文件，死锁后将资源回滚到上一个检测点，重新分配资源</li><li>杀死恢复：不断杀死死锁进程释放资源，直到死锁解除；或杀死环外的进程释放资源，最为简单直接</li></ul><h3>死锁预防</h3><p>破坏死锁4个必要条件之一，达到预防效果，但会<code>降低系统并发性，资源利用率低</code></p><h4>破坏互斥</h4><p>使资源可以同时访问，就没有进程会阻塞在资源上，从而不发生死锁</p><ul><li>只用于<code>只读环境</code>，因此多数情况下不适用</li></ul><h4>破坏占有和等待</h4><p>进程在执行之前<code>申请需要的全部资源</code>，资源全部得到满足后才开始执行</p><ul><li>实现简单，但资源利用率很低</li><li>有些不常用的资源也被占用，真正需要的进程阻塞</li></ul><h4>破坏不可抢占</h4><p>针对可抢占资源：内存、CPU</p><ol><li>申请新资源时，进程需主动释放已占资源；之后再重新申请该资源</li><li>申请新资源时，如果有则分配；否则剥夺占用的全部资源，进程阻塞，直到资源充足后唤醒进程申请资源</li></ol><h4>破坏循环等待</h4><p>按层将资源编号，申请资源的顺序必须按照编号进行</p><ul><li>一个进程得到某层的一个资源后，只能申请较高一层的资源</li><li>当进程释放某层的一个资源时，必须先释放所占有的较高层的资源</li><li>当进程获得某层的一个资源时，如果想申请同层的另一个资源，必须先释放此层中已占有的资源</li></ul><h3>死锁避免</h3><p>程序运行过程中避免发生死锁</p><p>安全状态：</p><ul><li>没有死锁发生</li><li>当所有进程突然最大程度申请资源时，仍存在某种调度次序使每个进程运行完毕</li></ul><h3>银行家算法</h3><p>🔗<a href="https://blog.csdn.net/qq_33414271/article/details/80245715">https://blog.csdn.net/qq_33414271/article/details/80245715</a></p><p>当一个进程申请使用资源的时候，银行家算法通过<code>试探分配</code>给该进程资源</p><p>然后通过<code>安全性算法</code>判断分配后的系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待</p><ol><li>当一个进程发出资源请求后，根据系统剩余资源判断是否足够可以分配</li><li>如果不够，直接退回；否则假设分配给申请的进程，从系统剩余资源序列减去申请的资源</li><li>此时，从当前进程的Need资源序列减去分配的资源，加入已获得资源序列</li><li>接着，判断此时系统剩余资源能否满足其他某个进程的Need资源序列</li><li>如果一个都不能满足，则假设失败，不给予分配；否则，回到第二步，再次假设分配资源</li></ol><p><img src="/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/20180508204335770" alt="银行家"></p><h1>内存管理</h1><p>🔗<a href="https://blog.csdn.net/weixin_43314519/article/details/107192971">https://blog.csdn.net/weixin_43314519/article/details/107192971</a></p><p>🔗<a href="https://blog.csdn.net/tennysonsky/article/details/45092229">https://blog.csdn.net/tennysonsky/article/details/45092229</a></p><p>🔗<a href="https://blog.csdn.net/qq_37375427/article/details/84206495">https://blog.csdn.net/qq_37375427/article/details/84206495</a></p><h2>物理内存</h2><p>单片机中没有操作系统，烧入程序直接操作物理内存</p><ul><li>地址空间不隔离，可随意修改内存数据</li><li>内存利用率低，程序需要全部载入内存，一旦空间不足就不能运行其他程序</li></ul><h2>虚拟内存</h2><p>通过CPU中的MMU（内存管理单元）实现虚拟内存到物理内存的映射</p><p>目的：<code>地址隔离</code>，<code>“扩充”</code>物理内存</p><ul><li>每个程序拥有自己的地址空间，虚拟内存按页划分</li><li>每一页映射的物理内存不一定连续，也不需要全部映射</li><li>当引用的页不在物理内存时，由硬件执行必要的映射，将页装入物理内存并重新执行失败的指令</li></ul><h2>分段</h2><p>根据程序不同的逻辑段（代码分段、数据分段、栈段、堆段）划分虚拟内存</p><ul><li>每个段都是从 0 开始的独立逻辑地址空间</li><li>而且各个段的长度因程序而不同</li></ul><p><img src="/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200808204147390.png" alt="分段"></p><h3>段表</h3><p>段号+段长+偏移值，但位数不确定</p><ol><li>进程获得某个分段的段号，段号大于段表长度则越界</li><li>查询段表，获得段长和该段在物理内存中的起始地址</li><li>段起始地址+段长=物理地址</li></ol><p>⚠️分段都是连续内存空间，但是易出现内存碎片，内存交换效率低</p><h3>内存碎片</h3><ul><li>外部碎片：多个不连续的小物理内存，导致新进程无法装载</li><li>内部碎片：程序所有内存均被分段载入内存，但其中部分分段不会经常访问</li></ul><h3>内存交换</h3><p>解决外部碎片问题：调整当前物理内存分配布局，腾出连续空间以加载新程序</p><p>⚠️每次交换均需要从磁盘的swap分区进行，磁盘读写速度限制内存交换效率</p><h2>分页</h2><p>按固定大小的页进行内存分配，解决外部内存碎片问题</p><p>⚠️内部内存碎片依旧存在，页固定大小4k，但4k内存并非全都会利用</p><h3>页表</h3><p><code>虚拟内存（页）&lt;=&gt;物理内存（页框）</code></p><ul><li>一般还有一位表示是否存在于内存中（1存在/0不存在）</li><li>根据情况增加访问权限位（读/写）用以<code>内存保护</code>，如果非法访问linux提示<code>段错误</code></li></ul><p>⚠️进程<code>PCB中描述页表起始地址和长度</code></p><p>虚拟内存地址：页号+偏移量</p><ul><li>页大小：<code>32位系统一般为2^12=4KB</code>，则32位虚拟内存地址的后12位标识页内偏移量</li><li>页数量：32-12=20，即为2^20个页，则32位虚拟内存地址的前20位标识页号</li></ul><p>因此，转换大致如下：</p><ul><li>根据虚拟内存地址前几位确定页编号：<code>逻辑地址/页大小=页编号</code></li><li>查找页表中对应编号所对应的页表项，表示物理内存页框编号：页编号&lt;=&gt;页框编号</li><li>如果页表项最后一位为1，则找到对应物理内存为：<code>页大小*页框编号+逻辑地址%页大小（页内偏移）</code></li><li>如果为0，此时如果还有闲置的物理内存，则将当前页面装入物理内存，页表增加映射关系</li><li>如果没有空闲的物理内存，则进行页面置换算法，移除被置换的映射，增加新映射</li></ul><p>⚠️程序的局部性原理：</p><ul><li><p>每次只有进程的少部分代码会在物理内存中运行，其余代码位于<code>磁盘交换分区</code></p></li><li><p>页面置换时，从交换区中取出一页大小的数据进行置换</p></li></ul><h3>快表TLB</h3><p>为加快映射速度，在<code>CPU高速缓存</code>中存放快表</p><ul><li><p>CPU先访问快表，找不到映射再访问内存中的页表</p></li><li><p>找到之后，将对应映射关系加入快表</p><p>🔴如果快表已满，则类似页面置换，通过算法将快表中一个项目置换到内存</p></li></ul><p>一级页表缺陷：页表必须<code>连续存放</code>，<code>常驻物理内存</code>，每个进程一个页表，页表占用空间</p><h3>二级页表</h3><p>对页表本身分页，将需要的页表项调入内存，其余项存在磁盘</p><p>目的：使得页表离散存储，节省物理内存空间</p><p><img src="/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9KMGcxNENVd2FaZlZZeGljRGpBamw0bk14bG15Sms3cmtlc2liR0RhcVpLckhlb3BETEpRWWlhQkJpYVdVa2Fvcm9PanE3MXU0aWFCNjEzTnVjNWYyYU1EeFRRLzY0MA" alt="二级分页"></p><p>由于程序局部性原理，并非每个一级页表项都会对应1024个二级页表，只在需要的时候创建</p><h2>页面置换算法</h2><p>🔗<a href="https://blog.csdn.net/weixin_39731083/article/details/82025029">https://blog.csdn.net/weixin_39731083/article/details/82025029</a></p><p>🔗<a href="https://blog.csdn.net/wangsifu2009/article/details/6757352">https://blog.csdn.net/wangsifu2009/article/details/6757352</a></p><p>🔗<a href="https://www.jianshu.com/p/d76b873fcce7">https://www.jianshu.com/p/d76b873fcce7</a></p><p>目的：降低缺页率，减少缺页中断的次数</p><p>理想算法：置换出最长时间不被访问的页面（无法实现）</p><h3>先进先出</h3><p>调出最早进入内存的页面</p><ul><li><p>将进程调用的页面按次序链接为一个队列，队列满时调出队首页面</p><p>⚠️缺页率高：经常访问的页面随时间推移也会迟早被调出</p></li></ul><h3>第二次机会</h3><p>每个页设置访问标志位R</p><ul><li>如果队首的页R=0，表示最早载入内存并且没被访问，直接置换</li><li>如果队首页R=1，表示访问过，则将其移入队尾，并置R=0（相当于刚载入内存）</li><li>此时再判断新的队首，直到R=0的队首页置换</li></ul><p>⚠️可能需要反复移动页（链表），效率低</p><h3>时钟</h3><p>使用环形链表连接页，并通过指针指向最早的页，又称为最近未用(Not Recently Used, NRU)算法</p><p>改进：使用M标记是否修改</p><ul><li>寻找R=0；M=0进行置换，表示没有被访问、修改</li><li>如果没有，寻找R=0；M=1进行置换；在此期间访问到的页R置为0</li></ul><h3>最近最久未使用</h3><p>LRU（Least Recently Used）：按照上次访问时间排，<code>淘汰上次访问时间最大的</code></p><ul><li>在内存中维护一个<code>所有页面的链表</code></li><li>一个页面被访问后就移到链表表头</li><li>则链表尾部是最近最久未访问的页面，置换</li></ul><p>⚠️每次访问都要更新链表（代价高），另属于堆栈算法莫须有硬件支持</p><h3>最少使用</h3><p>LFU（Least Frequently Used）：内存中的每个页都会有一个<code>移位寄存器</code>，用于记录该<code>页面被访问的频率</code></p><ul><li>算法会选择最近时间内，<code>用得最少次的页面淘汰</code></li></ul><p><img src="/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/1-140F102004L08.jpg" alt="img"></p><h2>分页分段区别</h2><ul><li>页是物理单位，满足系统空间管理需要；段是逻辑单位，满足用户需要</li><li>页的大小固定，由系统决定；段的长度不固定，由用户决定</li><li>分页地址空间是一维的（虚拟地址由一个数表示）<br>分段地址空间则是二维的（虚拟地址有两个数（段号和段内地址）表示）</li></ul><p>出现的原因：</p><ul><li>分页主要用于实现虚拟内存，从而获得更大的地址空间</li><li>分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护</li></ul><h2>段页式</h2><p>结合段式和页式两者管理优点，既能节省内存空间，提高内存分配效率；又能兼顾用户程序需要</p><ul><li>先分段，再将每段分页</li><li>每段对应一个页表，段表存放每个页表的起始地址和页表长度</li><li>虚拟内存地址：段号+段内页号+页内偏移</li></ul><p><img src="/2020/09/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/image-20200808212338475.png" alt="段页式"></p><ol><li>根据段号查段表，得到该段所在页的起始地址</li><li>根据段内页号查找页表，得到该页对应的物理页号</li><li>物理页号*页大小+页内偏移=物理地址</li></ol><h1>面试补充</h1><p>🔗<a href="https://blog.csdn.net/qq_35181209/article/details/78026636">https://blog.csdn.net/qq_35181209/article/details/78026636</a></p><p>🔗<a href="https://www.cnblogs.com/zl1991/p/12932173.html">https://www.cnblogs.com/zl1991/p/12932173.html</a></p><h2>自旋锁设计，CAS</h2><h2>互斥锁底层实现</h2><h2>信号量机制底层硬件实现</h2><h2>字节序</h2><p>🔗<a href="https://www.ruanyifeng.com/blog/2016/11/byte-order.html">https://www.ruanyifeng.com/blog/2016/11/byte-order.html</a></p><table><thead><tr><th>内存地址</th><th>0x00</th><th>0x01</th><th>0x02</th><th>0x03</th></tr></thead><tbody><tr><td>大端字节序（网络字节序）</td><td>12</td><td>34</td><td>56</td><td>78</td></tr><tr><td>小端字节序</td><td>78</td><td>56</td><td>34</td><td>12</td></tr></tbody></table><p>大端：数据高字节低地址，低字节高地址</p><h3>为啥出现小端</h3><p>计算机从低字节开始计算速度更快，效率更高；如果收到大端字节序则需要转换</p><h2>孤儿进程</h2><p>父进程退出但子进程还在运行，子进程为孤儿进程</p><ul><li>会被进程号1收养，不会对系统造成危害</li></ul><h2>僵尸进程</h2><p>正常情况：父进程通过wait获取已经退出的子进程信息后，子进程描述符被释放</p><p>异常情况：父进程没有调用wait，子进程退出，但描述符还存在，此时为僵尸进程</p><ul><li>由于系统进程号有限，大量僵尸进程出现后系统无法产生新进程</li></ul><p>解决方法：杀死父进程，僵尸进程变为孤儿进程后被收养，但由于子进程已经退出，因此释放资源</p>]]></content>
    
    
    <summary type="html">记录操作系统面试知识点</summary>
    
    
    
    
    <category term="操作系统" scheme="https://vae1997.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++知识点记录</title>
    <link href="https://vae1997.github.io/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/"/>
    <id>https://vae1997.github.io/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-25T08:14:50.000Z</published>
    <updated>2020-09-25T08:32:52.796Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>🔗<a href="https://light-city.club/sc/">c++那些事</a>、<a href="https://interview.huihut.com/#/">interview</a></p><h1>从cpp到exe</h1><p>🔗<a href="https://www.cnblogs.com/mhq-martin/p/11898245.html">https://www.cnblogs.com/mhq-martin/p/11898245.html</a></p><p>🔗<a href="https://my.oschina.net/u/920274/blog/3126740/print">https://my.oschina.net/u/920274/blog/3126740/print</a></p><table><thead><tr><th>过程</th><th>编写源程序</th><th>预编译</th><th>编译</th><th>汇编</th><th>链接</th></tr></thead><tbody><tr><td>文件后缀</td><td>.cpp</td><td>.i</td><td>.s</td><td>.o</td><td>.exe</td></tr></tbody></table><h2>预编译</h2><ul><li>展开头文件：将<code>#include</code>中指定的代码写入当前文件</li><li>宏替换：将源程序中使用宏定义<code>#define</code>修饰的宏名称，替换为对应的字符串文本</li><li>条件编译：根据<a href="https://blog.csdn.net/ForestRound/article/details/52717968">C++条件编译</a>指令<code>#ifndef</code>等，判断将要进行编译的代码块，<code>防止头文件被重复引用</code></li><li>去掉注释：将<code>//</code>或<code>/**/</code>内容忽略</li></ul><p>预编译结束后，生成的文件后缀<code>.i</code></p><h2>编译</h2><ul><li>根据<code>编译原理</code>那一套，检查代码规范性、是否有语法错误等（词法、语法、语义分析+优化）</li><li>接着将.i文件编译，生成一个用汇编语言描述的<code>.s</code>文件</li></ul><p>⚠️此处只进行编译生成汇编代码，而不真正的进行汇编</p><h2>汇编</h2><ul><li>把.s文件翻译成二进制机器指令<code>.o</code>文件</li></ul><p>⚠️直接打开将乱码，使用反汇编工具才可以读懂</p><h2>链接</h2><ul><li>链接所有的函数、全局变量，将所有的.o文件链接成一个可执行文件</li></ul><p>⚠️当.o文件太多，链接不方便，因此将常用/共享的.o目标文件打包，就出现了静/动态链接库</p><h3>静态库和动态库</h3><p>🔗<a href="https://www.cnblogs.com/skynet/p/3372855.html">https://www.cnblogs.com/skynet/p/3372855.html</a></p><p>Windows下为.lib和.dll文件，Linux下为.a和.so文件</p><p>静态链接库：</p><ul><li>链接时将汇编生成的目标文件 .o 与引用的库（函数库等）一起链接打包到可执行文件中，<code>体积大</code></li><li>程序运行时，与函数库再无关联，因此<code>移植性好</code></li><li>不同程序链接相同的静态库，因此内存中有多份拷贝，<code>浪费资源空间</code></li><li>当静态库进行更新，则所有链接静态库的程序均需要重新编译链接（<code>全量更新</code>）</li></ul><p>动态链接库：</p><ul><li>程序编译为可执行文件后，可执行文件并未链接需要的函数库，<code>体积小</code></li><li>只有当程序开始运行时，才会搜索文件系统，将需要的函数库动态加载进来（<code>移植性差</code>）</li><li>不同程序可以共享一份动态库，<code>节省资源空间</code></li><li>只需要进行动态库本身的更新，程序不需要改动（<code>增量更新</code>）</li></ul><h1>程序内存分配</h1><p>🔗<a href="https://blog.csdn.net/u010594850/article/details/25512269">https://blog.csdn.net/u010594850/article/details/25512269</a></p><p>🔗<a href="https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/">https://chenqx.github.io/2014/09/25/Cpp-Memory-Management/</a></p><p><img src="/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/20180122125137873.png" alt="程序内存"></p><p>Linux 系统中的<code>每个段</code>都是从 0 地址开始的整个 <code>4GB 虚拟空间</code>（32 位环境下），内核1G+用户空间3G</p><p>用户空间中的3G虚拟地址空间，地址从低到高依次被分配为：</p><ul><li><p>程序代码区：存放函数体（成员函数、全局函数）编译后的二进制可执行代码，只读（注意地址并非从0x0开始）</p></li><li><p>常量区：存放=（赋值符号）右边的立即数、字面量、字符串常量等（右值），只读，🚨和const修饰与否无关！</p></li><li><p>全局数据区：存放全局变量、静态变量，程序运行期间一直存在</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//验证环境vscode，gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)</span></span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> e;</span><br><span class="line"><span class="keyword">int</span> f;</span><br><span class="line"><span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> b=<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c=<span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="string">&quot;　&quot;</span>&lt;&lt;&amp;d&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;e&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;f&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//0x403010 0x403014 0x403018　0x407030 0x40703c 0x407034</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> g;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> h=<span class="number">4</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;g&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;h&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//0x407040 0x40301c</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>全局数据区内，初始化的变量位于低地址，未初始化的位于高地址</li><li>所有初始化的全局变量（无论static）按照定义先后顺序，向着地址增长的方向存放</li><li><code>未初始化的全局变量，static全局变量和普通全局变量地址也是分开的</code>，目前来看中间隔了8个字节</li><li><code>未初始化的普通全局变量位于低地址，而static在高地址</code>，两部分也分别按照定义先后顺序，地址向上增长</li></ul></li><li><p>堆：包括<code>动态分配的内存</code>，从低地址开始向上增长</p></li><li><p>文件映射段：包括动态库、共享内存等，从低地址开始向上增长（跟硬件和内核版本有关）</p></li><li><p>栈：包括<code>局部变量</code>和<code>函数调用的上下文</code>等，栈的大小是固定的，一般是 <code>8 MB</code>，可配置修改，<code>地址向下增长</code></p></li></ul><h2>堆和栈的区别</h2><p>申请方式：</p><ul><li>堆由new/delete，malloc/free等方法动态分配，容易出现内存泄漏</li><li>栈由系统自动分配（⚠️栈区的内存空间也可使用alloca动态分配，但会自动释放）</li></ul><p>申请后系统的响应：</p><ul><li>栈只要剩余空间大于申请空间，即可分配，直到异常提示栈溢出</li></ul><blockquote><p>操作系统有一个记录空闲内存地址的链表</p></blockquote><ul><li>堆申请时遍历空闲链表，找到首个满足分配大小的内存块进行分配，并从空闲链表中删除<ul><li>如果分配的内存块有剩余，则将剩余部分加入空闲链表</li><li>分配的内存首地址一般记录分配的大小，delete时才能正确释放</li></ul></li></ul><p>申请大小限制：栈的大小一般较小，而堆32位理论可分配4G</p><p>生长方向：栈向下（地址下降），堆向上（地址上升）</p><p>碎片化：栈每次分配连续的内存，无碎片问题；堆如果频繁new/delete势必造成内存不连续，产生大量碎片</p><p>分配效率：栈的分配往往对应CPU指令级别的操作，效率高；堆往往由库函数提供分配方法，效率低</p><h2><a href="https://www.cnblogs.com/lfri/p/12593582.html">对象创建的两种方式</a></h2><ul><li>静态建立：<code>A a;</code><ul><li>对象分配在<code>栈空间</code></li><li>编译器移动栈顶指针腾出空间，再<code>直接调用构造函数</code>创建对象</li><li>对象生命结束，编译器调用析构函数释放栈空间</li></ul></li><li>动态建立：<code>A* a = new A();</code><ul><li>执行<code>operator new()</code>函数，在<code>堆空间</code>中寻找内存分配</li><li>调用构造函数，在分配的内存中创建对象</li></ul></li></ul><blockquote><p>C++是静态绑定语言，编译器管理了对象的整个生命周期</p></blockquote><p>🔗<a href="https://blog.csdn.net/qq_40840459/article/details/80079608">https://blog.csdn.net/qq_40840459/article/details/80079608</a></p><h3>只在栈上生成对象的类</h3><ul><li><code>将new和delete操作符重载为私有</code></li><li>此时使用new创建对象，编译器无法进行访问</li></ul><h3>只在堆上生成对象的类</h3><ul><li><code>将析构函数设为私有</code>，最好设为protected，确保多态时正常执行父类的虚析构函数</li><li>此时使用静态创建对象，编译器无法进行访问</li></ul><p>⚠️此时需要单独定义一个函数，执行delete进行内存空间的释放</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="keyword">size_t</span> t)</span></span>&#123;&#125;      <span class="comment">// 注意函数的第一个参数和返回值都是固定的   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>&#123;&#125;  <span class="comment">// 重载了new就需要重载delete     </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">destory</span><span class="params">()</span></span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>;&#125;  </span><br><span class="line"><span class="keyword">protected</span> :  </span><br><span class="line">    <span class="keyword">virtual</span> ~B()&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a;<span class="comment">//0x61fe2f</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;a&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//!!! A* a2 = new A();             //函数 &quot;A::operator delete&quot; 不可访问</span></span><br><span class="line">    <span class="comment">//!!! B b;                         //&quot;B::~B() noexcept&quot; 不可访问</span></span><br><span class="line">    B* b = <span class="keyword">new</span> B();<span class="comment">//0x7c1700</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    b-&gt;destory();</span><br><span class="line">    C c1;<span class="comment">//0x61fe20</span></span><br><span class="line">    C* c2 = <span class="keyword">new</span> C();<span class="comment">//0x7c1700</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;&amp;c1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h2>new/delete和malloc/free区别</h2><p>🔗<a href="https://www.cnblogs.com/qg-whz/p/5140930.html">https://www.cnblogs.com/qg-whz/p/5140930.html</a></p><table><thead><tr><th style="text-align:center">特征</th><th style="text-align:center">new/delete</th><th style="text-align:center">malloc/free</th></tr></thead><tbody><tr><td style="text-align:center">分配内存的位置</td><td style="text-align:center">自由存储区(C++基于new的概念)</td><td style="text-align:center">堆(C/操作系统的概念)</td></tr><tr><td style="text-align:center">内存分配成功返回值</td><td style="text-align:center">完整类型指针</td><td style="text-align:center">void*，一般需要强制转换为需要的类型</td></tr><tr><td style="text-align:center">内存分配失败返回值</td><td style="text-align:center">默认抛出bac_alloc异常</td><td style="text-align:center">返回NULL</td></tr><tr><td style="text-align:center">分配内存的大小</td><td style="text-align:center">由编译器根据类型计算得出</td><td style="text-align:center">必须显式指定字节数</td></tr><tr><td style="text-align:center">处理数组</td><td style="text-align:center">有处理数组的new[]和delete[]</td><td style="text-align:center">需要用户计算数组的大小后进行内存分配</td></tr><tr><td style="text-align:center">已分配内存的扩充</td><td style="text-align:center">无法直观地处理</td><td style="text-align:center">使用realloc简单完成</td></tr><tr><td style="text-align:center">是否相互调用</td><td style="text-align:center">可以，operator new/delete实现底层调用malloc/free</td><td style="text-align:center">不可调用new</td></tr><tr><td style="text-align:center">分配内存时内存不足</td><td style="text-align:center">客户能够指定处理函数或重新制定分配器</td><td style="text-align:center">无法通过用户代码进行处理</td></tr><tr><td style="text-align:center">函数重载</td><td style="text-align:center">允许</td><td style="text-align:center">不允许</td></tr><tr><td style="text-align:center">构造函数与析构函数</td><td style="text-align:center">调用</td><td style="text-align:center">不调用</td></tr></tbody></table><p>有了malloc为什么还需要new？</p><ul><li>对于<code>非内部数据类型的对象</code>而言，用maloc/free无法满足动态对象的要求</li><li>对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数</li><li>由malloc/free是库函数而不是运算符，不在编译器控制权限之内</li></ul><h1>内存对齐</h1><p>🔗<a href="https://zhuanlan.zhihu.com/p/101140160">https://zhuanlan.zhihu.com/p/101140160</a></p><p>🔗<a href="https://www.jianshu.com/p/49ddb946a226">https://www.jianshu.com/p/49ddb946a226</a></p><p>对齐：内存中数据首地址是CPU单次获取数据大小的整数倍</p><p>目的</p><ul><li><p>平台原因(移植原因)：代码移植时硬件平台不同，内存地址不能随便访问</p></li><li><p>性能原因：加快CPU寻址，确保一次访问内存就能获取到完整的数据</p></li></ul><p><code>#pragma pack(n)</code>：设定结构体、联合以及类成员变量以 n 字节方式对齐</p><p>关于该指令其他用法，参考<a href="https://www.jianshu.com/p/90a6eef329ec">#pragma pack 指令详解</a></p><h2>sizeof()</h2><p>⚠️运算符/关键字，判断数据类型或者表达式长度</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">char</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">double</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure><h2>对齐规则</h2><ul><li><p>基本类型的对齐值就是其sizeof值</p></li><li><p>数据成员对齐规则：结构(struct)(或联合(union))的数据成员</p><ul><li>第一个数据成员放在offset为0的地方</li><li>以后每个数据成员的对齐按照#pragma pack指定的数值和这个数据成员自身长度中，比较小的那个进行</li></ul></li><li><p>结构(或联合)的整体对齐规则：</p><ul><li>数据成员完成各自对齐</li><li>结构(或联合)本身也要进行对齐</li><li>对齐将按照#pragma pack指定的数值和结构(或联合)最大数据成员长度中，比较小的那个进行;</li></ul></li></ul><p>关于共用体和结构体，参考<a href=":link:https://juejin.im/post/6844904022877405191">C语言中关于sizeof(struct)和sizeof(union)</a></p><p>关于虚函数、虚继承，参考<a href="https://blog.csdn.net/fuhuixin7497/article/details/78198287">c++普通继承、虚继承、虚函数对sizeof的影响</a></p><p>关于位域的sizeof，参考<a href="http://blog.chinaunix.net/uid-20726927-id-2455478.html">含位域结构体的sizeof</a>、<a href="https://www.cnblogs.com/zlcxbb/p/6803059.html">C/C++ 位域知识小结</a></p><h1>面向对象特性</h1><p>封装：将事物抽象为类，对不可信的类/对象隐藏自身属性/方法，使得代码模块化</p><p>继承：使用现有类的全部功能，并在不改动原有类的前提下对功能进行扩展</p><p>多态：不同对象调用同一个方法而表现出不同的行为</p><h1>C++类访问控制</h1><p><a href="https://blog.csdn.net/shuzfan/article/details/68954774">https://blog.csdn.net/shuzfan/article/details/68954774</a></p><table><thead><tr><th></th><th>public</th><th>protected</th><th>private</th></tr></thead><tbody><tr><td>类成员是否可以访问</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>友元是否可以访问</td><td>Yes</td><td>Yes</td><td>Yes</td></tr><tr><td>子类是否可以访问</td><td>Yes</td><td>Yes</td><td>No</td></tr><tr><td>类的实例化对象是否可以访问</td><td>Yes</td><td>No</td><td>No</td></tr><tr><td>public继承</td><td>public</td><td>protected</td><td>private</td></tr><tr><td>protected继承</td><td>protected</td><td>protected</td><td>private</td></tr><tr><td>private继承</td><td>private</td><td>private</td><td>private</td></tr></tbody></table><h1><a href="%5Bhttps://www.fa1c0n.cn/2020/03/08/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91-%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%8D%E5%90%88%E3%80%81%E5%A7%94%E6%89%98%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%5D(https://www.fa1c0n.cn/2020/03/08/C++%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E9%AB%98%E7%BA%A7%E5%BC%80%E5%8F%91-%E7%BB%A7%E6%89%BF%E3%80%81%E5%A4%8D%E5%90%88%E3%80%81%E5%A7%94%E6%89%98%E4%B8%8E%E7%BB%84%E5%90%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)">C++类间关系</a></h1><p>🔗<a href="https://www.jianshu.com/p/4d2e63e71a07">https://www.jianshu.com/p/4d2e63e71a07</a></p><p>🔗<a href="https://www.cnblogs.com/narutow/p/8117352.html">https://www.cnblogs.com/narutow/p/8117352.html</a></p><h2>继承</h2><p>从内存的角度上讲，子类拥有父类的成员变量，对于成员函数来说，继承代表子类拥有函数的调用权</p><p>变量的初始化顺序：</p><ul><li><p>基类的静态变量或全局变量按照定义</p></li><li><p>派生类的静态变量或全局变量按照定义</p></li><li><p>基类的成员变量</p></li><li><p>派生类的成员变量</p></li></ul><h2>Composition 组合</h2><p>当一个类中<code>包含另外一个类对象</code>时，可称为组合</p><ul><li>构造由内而外：先调用包含的那个类的构造方法，在调用自身的构造</li><li>析构由外而内：先调用自身析构，再调用内部包含的</li></ul><p>⚠️创建对象时，两个类的对象同时会创建，因此两个类对象的生命周期是一致的</p><h3>组合+继承</h3><ul><li>子类继承父类，父类存在组合<ul><li>构造：组合的类构造=&gt;父类=&gt;子类</li><li>析构：子类析构=&gt;父类析构=&gt;组合类析构</li></ul></li><li>子类继承父类，子类存在组合<ul><li>构造：父类构造=&gt;组合类构造=&gt;子类</li><li>析构：子类析构=&gt;组合类析构=&gt;父类</li></ul></li></ul><h2>Delegation 委托</h2><p>Composition by reference：一个类中只记录另一个类的指针，并不是包含关系</p><ul><li>当前类只是将部分功能委托给另一个类实现</li><li>被委托的类对象，生命周期不被限制，等到需要用到的时候才去创建</li></ul><h3>委托+继承</h3><p>观察者模式的实现方式</p><ul><li>委托类即为观察目标</li><li>观察者抽象类即为被委托的父类</li><li>具体的观察者即为继承父类的子类</li></ul><p><img src="/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/image-20200807195739441.png" alt="观察者"></p><h1>C++对象模型</h1><p>🔗<a href="https://cloud.tencent.com/developer/article/1155155">https://cloud.tencent.com/developer/article/1155155</a></p><p><img src="/2020/09/25/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B.png" alt="对象模型"></p><h2>多态与虚表</h2><p>C++ 多态分类及实现：</p><ol><li>重载多态（编译期）：函数重载、运算符重载</li><li>参数多态（编译期）：类模板、函数模板</li><li>强制多态（编译期/运行期）：基本类型转换、自定义类型转换</li><li>子类多态（运行期）：虚函数，由于在运行期间才能确定，因此为<code>动态多态</code></li></ol><p>虚函数：用 virtual 修饰的<code>非静态成员函数</code></p><ul><li>static修饰的函数在对象构造之前已经存在，不能为虚函数</li><li>构造函数出现在对象生成之前，因此不能为虚函数</li><li>析构函数指定为虚函数，当析构发生了多态的对象时（父类指针指向子类），正常调用子类析构函数，防止内存泄漏</li></ul><p>🚨当没有虚函数时，父类指针可以指向子类，🔗<a href="https://blog.csdn.net/FX677588/article/details/77727110">https://blog.csdn.net/FX677588/article/details/77727110</a></p><ul><li>基类指针指向子类，该指针只能访问基类方法（静态绑定）</li><li>子类指针指向基类，必须先做强制转型动作（不建议）</li><li>基类和子类定义了同名成员函数，指针类型是谁就调用谁</li></ul><p><code>如果编译器能明确知道调用的是哪个虚函数，则不用查虚表，直接调用</code></p><h2>虚指针、虚表存放位置</h2><p>🔗<a href="https://cloud.tencent.com/developer/article/1394319">https://cloud.tencent.com/developer/article/1394319</a></p><ul><li>虚指针：一般在对象内存的起始位置，即就是对象的地址（32位占4字节），保证多层/多重继承下获得虚表效率高</li><li>虚表：应用程序的常量区，虚指针指向的地址（首个虚函数地址）</li></ul><h2>非继承</h2><ul><li>非静态数据成员：位于每一个对象内存中</li><li>静态数据成员、静态成员函数、非静态成员函数：位于对象内存之外</li><li>虚函数：虚指针指向的虚函数表</li></ul><p>虚函数表：</p><ul><li>每个具有虚函数的类，和类绑定（所有该类对象<code>共用一个虚表</code>）</li><li>表中按照虚函数在类中的<code>定义顺序</code>，依次存放对应的指向虚函数地址的指针</li><li>虚函数表之前设置一个指向type_info的指针，用以支持RTTI（运行时类型识别），用于描述对象继承关系等</li></ul><p>虚表指针：</p><ul><li>每个对象都有虚表指针(vptr)，由编译器为其生成</li></ul><h2>单继承</h2><ul><li>子类和父类各拥有自己的虚函数表</li><li>子类若<code>重写父类的虚函数</code>，则子类虚函数将<code>覆盖虚表中对应的父类虚函数</code></li><li>若子类声明自己<code>新的虚函数</code>，则该虚函数地址将<code>扩充到虚函数表最后</code></li></ul><h2>多继承</h2><ul><li>子类<code>新增的虚函</code>数被放在声明的<code>第一个基类</code>的虚函数表中</li><li>发生<code>重写</code>时，<code>所有基类</code>的虚函数都被子类<code>覆盖</code></li><li>内存布局中，<code>父类按照其声明顺序排列</code></li></ul><h2>虚继承</h2><p>虚继承解决了菱形继承中<code>最派生类</code>拥有<code>多个间接父类实例</code>的情况</p><ul><li><p>虚继承的子类也<code>保留父类的vprt与虚函数表</code>，与子类内容<code>以一个四字节的0</code>来分界</p></li><li><p>若发生虚函数<code>重写</code>，同样地将<code>覆盖</code>父类中的虚函数表对应位置</p></li><li><p>若声明<code>新的虚函数</code>，则编译器将为子类增加一个<code>新的虚表指针vptr</code>，对应新的虚函数表</p></li></ul><p>虚继承中的子类，生成一个隐藏的<code>虚基类指针</code>， 指向<code>虚基类表</code>，存放的是<strong>偏移值</strong></p><p>偏移值：</p><ul><li>第一个条目存放<code>虚基类指针所在地址</code>到该类<code>对象内存首地址</code>的偏移值</li><li>如果有虚函数指针，值为-4；否则为0</li><li>其余条目为该类的<code>最左</code>虚继承父类、<code>次左</code>虚继承父类…的内存地址<code>相对于虚基类指针</code>的偏移值</li></ul><h2>菱形虚继承</h2><ul><li>在子类对象内存中，基类出现的顺序是：<code>最左父类、次左父类、虚祖父类</code></li><li>子类对象的<code>数据成员放在虚祖父类前面</code>，两部分数据依旧以<code>0来分隔</code></li><li>子类<code>覆盖并扩展最左父类的虚函数表</code>，与简单继承的对象模型相同</li><li>虚祖父类的内容放到了子类对象内存布局的最后</li></ul><h1>指针VS引用</h1><p><a href="https://cloud.tencent.com/developer/article/1021622">https://cloud.tencent.com/developer/article/1021622</a></p><ul><li><p>指针有自己的大小（32位4字节），而引用只是一个别名（汇编角度也占内存），sizeof是被引用对象的大小</p></li><li><p>指针可以被初始化为NULL，而引用必须声明时初始化</p></li><li><p>作为参数传递时，指针需要被解引用才可以对对象进行操作，引用不发生拷贝</p></li><li><p>指针在使用中可以指向其它对象，但是引用只能是一个对象的引用，不能被改变</p></li><li><p>指针可以有多级指针（**p），而引用至于一级</p></li><li><p>指针++指向下一个地址，引用++则是对被引用对象++</p></li></ul><h1>++i VS i++</h1><p>++i 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; <span class="keyword">int</span>::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    *<span class="keyword">this</span> +=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i++ 实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="keyword">int</span>::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> oldValue = *<span class="keyword">this</span>;</span><br><span class="line">    ++(*<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/19811087">https://www.zhihu.com/question/19811087</a></p><p>i++ 最后返回的是一个临时变量，而<strong>临时变量是右值</strong></p><h2>效率</h2><p>🔗<a href="https://blog.51cto.com/genwoxuevc/499483">https://blog.51cto.com/genwoxuevc/499483</a></p><ul><li>对于基本类型，效率无差异</li><li>对于自定义类型，++i更好，返回对象的引用，无拷贝开销</li></ul><h2>线程安全</h2><p>线程不安全，非原子操作</p><h1>宏</h1><h2>#include</h2><p>#include&lt; &gt;：引用的是编译器的<code>类库路径里面的头文件</code>，一般是引用自带的一些头文件</p><p>#include&quot; &quot;：引用的是程序目录的<code>相对路径中的头文件</code>，一般是用来引用自己写的一些头文件</p><p>⚠️使用 #include&quot; &quot; 先在项目当前目录查找是否有对应头文件，如果没有再去类库路径下找</p><h2>#define</h2><p>🔗<a href="https://www.cnblogs.com/zhizhiyu/p/10155614.html">https://www.cnblogs.com/zhizhiyu/p/10155614.html</a></p><p>不带参数的宏定义：#define 宏名 字符串</p><ul><li><p>使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义</p></li><li><p>预处理阶段进行展开和替换，因此<code>不做语法检查</code></p></li><li><p>可以用#undef命令终止宏定义的作用域</p></li><li><p>宏定义<code>不分配内存</code></p></li></ul><p>带参数的宏定义：#define 宏名（参数表） 字符串</p><ul><li><p>宏名和参数的括号间不能有空格</p></li><li><p>宏替换只作替换，不做计算，不做表达式求解</p></li><li><p>宏展开不占运行时间，只占编译时间</p></li></ul><p>宏比较大小：<code> #define MIN(A,B)  ((A)&lt;=(B)?(A):(B))</code></p><h1>const</h1><h2>const和#define区别</h2><p>🔗<a href="https://blog.csdn.net/love_gaohz/article/details/7567856">https://blog.csdn.net/love_gaohz/article/details/7567856</a></p><ul><li>const有具体类型，<code>分配内存</code>；宏定义没有，仅仅是展开，不分配内存</li><li>const编译期间进行<code>类型检查</code>；宏定义位于预处理阶段，没有类型检查</li><li>const在内存中只有<code>一份拷贝</code>；宏定义在替换后会出现多个拷贝</li></ul><p>⚠️编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，没有存储与读内存的操作，效率很高</p><h2>基本说明</h2><ul><li><p>const普通变量<code>当且仅当</code>在定义的时候进行初始化，一旦初始化之后就不能被再次赋值</p></li><li><p>const成员变量只能在<code>初始化形参列表</code>中进行初始化操作</p></li><li><p>const可用于对重载函数的区分</p></li><li><p>const成员函数内部不能修改类的任何成员变量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> a;                <span class="comment">// 常对象成员，只能在初始化列表赋值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x) : a(x) &#123; &#125;;        <span class="comment">// 初始化列表</span></span><br><span class="line">    <span class="comment">// const可用于对重载函数的区分</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;             <span class="comment">// 普通成员函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="keyword">const</span></span>;       <span class="comment">// 常成员函数，不得修改类中的任何数据成员的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>🔴同时存在同名的const和非const成员函数时</p><ul><li>const对象只能调用const成员函数</li><li>非const只能调用非const成员函数</li></ul><h2>修饰指针和引用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A b;                        <span class="comment">// 普通对象，可以调用全部成员函数、更新常成员变量</span></span><br><span class="line"><span class="keyword">const</span> A a;                  <span class="comment">// 常对象，只能调用常成员函数</span></span><br><span class="line"><span class="keyword">const</span> A* p = &amp;a;            <span class="comment">// 指针变量，指向常对象，即指向的对象不能变，指针本身可以变</span></span><br><span class="line">A* <span class="keyword">const</span> p = &amp;b;            <span class="comment">// 常量指针，即指针本身不能变，但可以指向不同对象</span></span><br><span class="line"><span class="keyword">const</span> A&amp; q = a;             <span class="comment">// 指向常对象的引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="keyword">char</span>* p1 = greeting;                <span class="comment">// 指针变量，指向字符数组变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* p2 = greeting;          <span class="comment">// 指针变量，指向的字符char不可改变</span></span><br><span class="line"><span class="keyword">char</span>* <span class="keyword">const</span> p3 = greeting;          <span class="comment">// 自身是常量的指针，p3指针自身不可改变</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> p4 = greeting;    <span class="comment">// 自身是常量的指针，指向字符数组常量，都不能变</span></span><br></pre></td></tr></table></figure><p>⚠️主要判断const后面修饰的对象，如果是类型(int/class)即指向的对象不可变；如为变量名称即为指针/引用本身不能变</p><h3>const多级指针</h3><p>🔗<a href="https://blog.csdn.net/SoYangA/article/details/80292025">https://blog.csdn.net/SoYangA/article/details/80292025</a></p><ul><li>一级指针<ul><li><code> const int* p</code>：p指向的int型数不能变</li><li><code>int const *p</code>：同上，p指向的int型数不能变（可认为修饰*p，其中*表示取值，即为int型数）</li><li><code>int* const p</code>：p指针本身不可变</li><li><code>const int* const p</code>：p指针本身不可变，p指向的int型数也不能变</li></ul></li><li>二级指针<ul><li><code>const int** p</code>：p指向的int型数不能变</li><li><code>int** const p</code>：二级指针p本身不可变</li><li><code>int* const *p</code>：二级指针p指向的一级指针*p本身不可变</li><li><code>const int* const * const p</code>：一级指针*p，二级指针p，指向的值均不可变</li></ul></li></ul><h2>修饰函数参数</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> Var)</span></span>;           <span class="comment">// 传递过来的参数在函数内不可变</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* Var)</span></span>;         <span class="comment">// 参数指针所指内容为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">const</span> Var)</span></span>;         <span class="comment">// 参数指针为常量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; Var)</span></span>;          <span class="comment">// 引用参数在函数内为常量</span></span><br></pre></td></tr></table></figure><p>⚠️<code>const int&amp;</code>常引用作为函数参数，既避免了参数的拷贝，又避免了函数内部对实参值的修改</p><h2>修饰函数返回值</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">f5</span><span class="params">()</span></span>;      <span class="comment">// 返回一个常数</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span>* <span class="title">f6</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向常量的指针变量，使用：const int *p = f6();</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="keyword">const</span> <span class="title">f7</span><span class="params">()</span></span>;     <span class="comment">// 返回一个指向变量的常指针，使用：int* const p = f7();</span></span><br></pre></td></tr></table></figure><h1>extern “C”</h1><p>作用：编译器将 <code>extern &quot;C&quot;</code> 声明的代码当作 C 语言代码处理（按照 C 语言方式编译和链接）</p><ul><li>可以避免 C++ 因符号修饰导致代码不能和C语言库中的符号进行链接的问题</li></ul><p><a href="https://cloud.tencent.com/developer/article/1496000">关于extern</a></p><p>修饰的变量或函数，表示在其他文件中定义</p><p>关键字extern用于扩展变量和函数的可见性。</p><p>由于函数默认存在extern,不需要再定义和声明的时候使用extern。</p><p>当变量使用extern时，它只是声明没有定义。</p><p>当变量用extern声明并且有初始化时，和变量的定义一样</p><h1>inline</h1><p>作用：减少函数调用时的消耗，是否对函数内联，决定权在于编译器</p><ul><li><p>一般不内联包含循环、递归、switch 等复杂操作的内联函数</p></li><li><p>在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数</p></li></ul><p>编译器处理步骤：</p><ol><li>将 inline 函数体复制到 inline 函数调用点处</li><li>为所用 inline 函数中的局部变量分配内存空间</li><li>将 inline 函数的输入参数和返回值映射到调用方法的局部变量空间中</li><li>如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）</li></ol><p>优点</p><ul><li><p>在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度</p></li><li><p>在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会</p></li><li><p>内联函数在运行时可调试，而宏定义不可以</p></li></ul><p>缺点</p><ul><li><p>代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。</p></li><li><p>inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接</p></li></ul><p>虚函数内联：当虚函数表现多态性的时候不能内联</p><h1>static</h1><p><a href="https://blog.csdn.net/cc198877/article/details/8844729">https://blog.csdn.net/cc198877/article/details/8844729</a></p><p>修饰局部对象：延长局部对象生命周期（直到程序结束）</p><p>修饰全局对象：限制全局对象的作用域（仅在本文件内访问）</p><p>修饰普通变量：</p><ul><li>声明时未赋初值，编译器根据类型会自动初始化</li><li>生命周期直到程序运行结束，不随函数运行结束而结束</li><li>只在当前文件可见（多人开发防止重名）</li></ul><p>修饰成员变量：</p><ul><li><p>只能在类外通过类名初始化<code>int A::a = 1;</code></p></li><li><p>只有一个拷贝（和类绑定），一个对象的修改会影响其他对象（可以理解为共享）</p><p>⚠️因为对象共享静态成员变量，因此<code>不能使用构造函数初始化</code>静态成员变量</p></li><li><p>一般通过<code>A::a</code>进行访问，也可以使用对象访问</p></li><li><p>可以作为成员函数的默认参数，但是普通的数据成员不行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> y;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> z=y)</span></span>&#123;&#125;  <span class="comment">//可以，但是int z=x不行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>修饰普通函数：只在当前文件可见（多人开发防止重名）</p><p>修饰成员函数：</p><ul><li><p>函数内部只能访问类的静态成员（变量/函数），但可以通过对象来引用非静态成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> x):s(x)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(A&amp; a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;a.s;<span class="comment">//通过引用对象来操作非静态成员</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;s;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">A <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    A::f(a);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>⚠️<code>非静态成员函数</code>可以<code>任意访问静态成员</code></p></li><li><p>一般通过<code>A::f()</code>进行访问，也可以使用对象访问</p></li></ul><h2>static成员函数this？</h2><p>无this，static修饰后和类绑定，而this和对象绑定</p><h2>static成员函数virtual？</h2><p>不可以，因为static编译期间就确定，virtual运行时才动态绑定</p><h1>this</h1><p>指针，指向<code>调用非静态成员函数</code>的对象</p><ol><li>先将对象的地址赋给this指针</li><li>this指针作为非静态成员函数的<code>隐含参数</code>传递（由编译器完成）</li><li>函数内部对成员变量操作时，都隐式使用this指针</li></ol><p>this类型：</p><ul><li>this指针被隐含地声明为: <code>ClassName* const this</code>，this指针本身不能变</li><li>当调用const成员函数时，this指针的类型为：<code>const ClassName* const</code>，表明指针本身和指向的对象均不能改变</li></ul><p>⚠️this是右值，不能取地址</p><p>需要显式使用this指针：</p><ol><li>为实现对象的链式引用</li><li>为避免对同一对象进行赋值操作</li><li>在实现一些数据结构时，如list</li></ol><h1>friend</h1><p><a href="https://blog.csdn.net/u012796139/article/details/46404401">https://blog.csdn.net/u012796139/article/details/46404401</a></p><p>友元函数：本身是普通的函数，在类外定义</p><ul><li>在类中通过friend修饰，类外通过对象访问类中的成员</li></ul><p>友元成员函数：本身是成员函数，在另一个类中指定为友元函数</p><p>友元类：在类中使用friend修饰另一个类为友元类</p><ul><li>在友元类中可以访问当前类中的成员</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">vfa</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>;</span><span class="comment">//可在A中访问B的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;<span class="comment">//可在类外的普通函数中访问B的私有成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::vfa</span><span class="params">()</span></span>;<span class="comment">//将A的虚函数指定为B的友元函数，该方法中可对B私有成员修改</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">A::f</span><span class="params">()</span></span>;<span class="comment">//将A的成员函数指定为B的友元函数，该方法中可对B私有成员修改</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2>delete this</h2><p>🔗<a href="https://blog.csdn.net/u010013164/article/details/38713083">https://blog.csdn.net/u010013164/article/details/38713083</a></p><p>🔗<a href="http://blog.sina.com.cn/s/blog_4b4cf2af0100ywgv.html#commonComment">http://blog.sina.com.cn/s/blog_4b4cf2af0100ywgv.html#commonComment</a></p><p>构造函数中delete this：</p><ul><li>A a；试图delete一个未经new得到的指针，崩溃</li><li>A* a = new A；合法</li></ul><p>析构函数中delete this：</p><ul><li>delete先调用析构，再释放内存</li><li>析构中又delete，因此无限递归调用，栈溢出</li></ul><p>在成员函数中delete this合法，但：</p><ol><li>保证this对象是通过 <code>new</code>分配的（不是 <code>new[]</code>、不是 placement new、不是栈上、不是全局、不是其他对象成员）</li><li>必须保证调用 <code>delete this</code> 的成员函数是最后一个调用 this 的成员函数</li><li>必须保证成员函数的 <code>delete this</code> 后面没有调用 this 了</li><li>必须保证 <code>delete this</code> 后没有人使用了</li></ol><h1>4种强制类型转换</h1><h2>C类型转换</h2><p><code>TYPE b = (TYPE) a</code>，可进行任意类型转换</p><ul><li>转换不明确，不能进行错误检查，易出错</li></ul><h2>static_cast</h2><p>静态类型转换</p><p>静态：在<code>编译期间就可以决定</code>，使用率最高</p><ul><li><p>用于各种隐式转换，比如非const转const，void*转指针等</p></li><li><p>不执行运行时类型检查（转换安全性不如 dynamic_cast）</p></li><li><p>通常用于转换数值数据类型（如 float -&gt; int）</p></li><li><p>可以在整个类层次结构中移动指针</p><ul><li>子类转化为父类安全（向上转换）</li><li>父类转化为子类虽然成功，但不安全（因为子类可能有不在父类的字段或方法）</li></ul></li></ul><h2>dynamic_cast</h2><p>用于多态类型的转换，<code>执行行运行时类型检查</code></p><ul><li>只适用于指针或引用<ul><li>对不明确的<code>指针</code>的转换将失败，返回 <code>nullptr</code></li><li>对不明确的<code>引用</code>的转换将失败，引发<code>bad_cast异常</code></li></ul></li><li>可以在整个类层次结构中移动指针，包括向上转换、向下转换</li></ul><h2>const_cast</h2><p>用于删除 const、volatile 和 __unaligned 特性</p><ul><li>目标类类型只能是指针或引用</li></ul><h2>reinterpret_cast</h2><p><code>数据的二进制形式重新解释</code>，但不改变其值，其本身并不安全，不建议使用</p><ul><li>滥用 reinterpret_cast 运算符可能很容易带来风险</li><li>reinterpret_cast 运算符不能丢掉 const、volatile 或 __unaligned 特性</li><li>reinterpret_cast 的一个实际用途是在哈希函数中<ul><li>通过让两个不同的值几乎不以相同的索引结尾的方式将值映射到索引</li></ul></li></ul><h1>重载/隐藏/重写覆盖</h1><p><a href="https://cloud.tencent.com/developer/article/1177174">https://cloud.tencent.com/developer/article/1177174</a></p><h1>STL</h1><p><a href="https://www.bilibili.com/video/BV1db411q7B8?p=3">侯捷STL</a></p><p>🔗<a href="https://blog.csdn.net/u012370255/article/details/40541499">https://blog.csdn.net/u012370255/article/details/40541499</a></p><table><thead><tr><th>容器</th><th>底层数据结构</th><th>时间复杂度</th><th>有无序</th><th>可不可重复</th><th>其他</th></tr></thead><tbody><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#array">array</a></td><td>定长数组</td><td>O(1)查询</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#vector">vector</a></td><td>变长数组</td><td>尾部插入/删除O(1)其余O(n)</td><td>无序</td><td>可重复</td><td>支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#deque">deque</a></td><td>双端队列</td><td>头尾插入/删除 O(1)其余O(n)</td><td>无序</td><td>可重复</td><td>一个中央控制器 + 多个缓冲区，支持首尾快速增删，支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#forward_list">forward_list</a></td><td>单向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#list">list</a></td><td>双向链表</td><td>插入、删除 O(1)</td><td>无序</td><td>可重复</td><td>不支持随机访问</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#stack">stack</a></td><td>deque / list</td><td>顶部插入、顶部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#queue">queue</a></td><td>deque / list</td><td>尾部插入、头部删除 O(1)</td><td>无序</td><td>可重复</td><td>deque 或 list 封闭头端开口，不用 vector 的原因应该是容量大小有限制，扩容耗时</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#priority_queue">priority_queue</a></td><td>vector + max-heap</td><td>插入、删除 O(log2n)</td><td>有序</td><td>可重复</td><td>vector容器+heap处理规则</td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#set">set</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multiset">multiset</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#map">map</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#multimap">multimap</a></td><td>红黑树</td><td>插入、删除、查找 O(log2n)</td><td>有序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_set">unordered_set</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multiset">unordered_multiset</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_map">unordered_map</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>不可重复</td><td></td></tr><tr><td><a href="https://github.com/huihut/interview/tree/master/STL#unordered_multimap">unordered_multimap</a></td><td>哈希表</td><td>插入、删除、查找 O(1) 最差 O(n)</td><td>无序</td><td>可重复</td><td></td></tr></tbody></table><p>🔗<a href="https://blog.csdn.net/Virtual_Func/article/details/49724135">https://blog.csdn.net/Virtual_Func/article/details/49724135</a></p><p>🔴无法存放引用类型</p><h2>Array（C11）</h2><p>数组：定长数组，初始化开辟空间后就不能改动</p><h2>Vector</h2><p>变长数组，堆中开辟连续内存</p><p>使用三个指针确定空间范围：首、尾、容量大小</p><h3>resize()和reserve()</h3><ul><li><code>resize</code>：增加容器的size和capacity</li><li><code>reserve</code>：方法仅进行扩容</li></ul><h2>模拟Vector</h2><p><a href="https://blog.csdn.net/shanghx_123/article/details/86662085">https://blog.csdn.net/shanghx_123/article/details/86662085</a></p><ol><li>私有成员为三个普通指针：start、finish、end</li><li>begin返回start，end返回finish</li><li>size返回finish-start，capacity返回end-start</li><li>重载[]运算符，返回start[pos]</li><li>实现erase：将删除位置pos之后的数据向前覆盖，返回pos指针</li><li>析构：delete[] start;再将三个指针置空</li><li>实现reserve：开辟新空间n，赋值所有数据，重新定位三个指针</li><li>实现resize：<ul><li>如果n小于size，调整finish=start+n</li><li>如果n大于capacity，调用reserve(n)</li><li>否则调整finish指针，新位置和旧位置之间使用参数指定的值覆盖</li></ul></li><li>实现insert：<ul><li>如果元素已达到容量，则2倍扩容，重置pos=start+size</li><li>将pos之后的元素后移一位，在pos位置插入新元素</li></ul></li></ol><h2>map和unordered_map</h2><p>使用场景：</p><p>除了有顺序要求和有单词操作时间要求的场景下用map，其他场景都使用unordered_map</p><h1>面试补充</h1><h2>if else 和 switch case</h2><p>分支较多时，效率上：switch高</p><ul><li>if else 需要挨个判断，时间换空间，分支太多代码可读性差</li><li>switch case 则直接跳转到对应case执行，空间换时间，代码可读性好</li></ul><p>类型上：if 更灵活</p><ul><li>if else 判断条件为逻辑表达式，只要最终是bool类型即可</li><li>swatch case 表达式类型受限：枚举/整型（int、 short、 char 、 byte）</li></ul><h2>递归、迭代、遍历和循环</h2><ul><li>循环(loop)：最基础的概念, 所有重复的行为</li><li>递归(recursion)：在函数内<code>调用自身</code>, 将复杂情况逐步转化成基本情况</li><li>(数学)迭代(iterate)：在多次循环中逐步接近结果</li><li>(编程)迭代(iterate)：按<code>顺序访问线性结构</code>中的每一项，迭代器（顺序、线性）</li><li>遍历(traversal)：<code>按规则访问非线性结构</code>中的每一项，树的遍历（前中后为规则，非线性）</li></ul><p>迭代：轮番交替，并替代</p><p>循环：只是单一重复执行，中间没有替代操作</p><h2>堆栈溢出</h2><p>可能的原因</p><ul><li>递归深度：函数每次被调用时都会将局部数据（在函数内部定义的变量、参数、数组、对象等）放入栈中</li><li>局部变量：存放在栈，大数据结构的局部变量</li></ul><h2>二维数组行列遍历</h2><p>二维数组是按行存储的，按行遍历的效率更高 <a href="https://blog.csdn.net/weixin_40497678/article/details/80733915">参考链接1</a>、 <a href="https://blog.csdn.net/Shuffle_Ts/article/details/89420651">参考链接2</a></p><h2>抽象类和接口</h2><p>🔗<a href="https://blog.csdn.net/hanxueyu666/article/details/75712917">https://blog.csdn.net/hanxueyu666/article/details/75712917</a></p><p>能否取代？同名方法？</p><h2>字符串拼接效率</h2><h2>Union</h2><p>数据覆盖时，考虑大端小端</p><p><a href="https://blog.csdn.net/xiao3404/article/details/22276485">https://blog.csdn.net/xiao3404/article/details/22276485</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> T</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">int</span> a;</span><br><span class="line">   <span class="keyword">char</span> b[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   T t;</span><br><span class="line">   t.a=<span class="number">0</span>;</span><br><span class="line">   t.b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">   t.b[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;v.l is %d\n&quot;</span>,t.a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出513，分析：</p><ol><li>t.a=0；将int的4字节（32位）全赋值为0</li><li>t.b[0]=1；注意<code>小端存储</code>，首个字节8位二进制覆盖为0000 0001</li><li>t.b[1]=2；第二个8位覆盖为0000 0010</li><li>剩余2个字节的高地址依旧全0</li><li>因此此时，0000 0000 + 0000 0000 + 0000 0010 + 0000 0001</li><li>16进制数为201，10进制对应513</li></ol>]]></content>
    
    
    <summary type="html">记录C++面试基础知识点</summary>
    
    
    
    
    <category term="C++" scheme="https://vae1997.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo配置记录</title>
    <link href="https://vae1997.github.io/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/"/>
    <id>https://vae1997.github.io/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</id>
    <published>2020-09-25T06:00:12.000Z</published>
    <updated>2020-09-25T07:58:15.500Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1>主题配置</h1><p>使用<a href="https://demo.jerryc.me/posts/21cfbf15/">Butterfly</a>主题</p><ol><li><code>npm i hexo-theme-butterfly</code></li><li>编辑blog/_config.yml文件：修改<code>theme: butterfly</code></li><li><code>npm install hexo-renderer-pug hexo-renderer-stylus --save</code></li></ol><p>主题文件夹路径：blog\node_modules\hexo-theme-butterfly</p><h1>加载emoji表情</h1><p>参考：<a href="https://hasaik.com/posts/9b280ea3.html">Hexo中使用emoji表情</a></p><p>在blog目录下执行安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br><span class="line">npm install markdown-it-emoji --save</span><br></pre></td></tr></table></figure><p>配置博客配置文件，添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">markdown:</span><br><span class="line">  render:</span><br><span class="line">    html: true</span><br><span class="line">    xhtmlOut: false</span><br><span class="line">    breaks: true</span><br><span class="line">    linkify: true</span><br><span class="line">    typographer: true</span><br><span class="line">    quotes: &#39;“”‘’&#39;</span><br><span class="line">  plugins:</span><br><span class="line">    - markdown-it-footnote</span><br><span class="line">    - markdown-it-sup</span><br><span class="line">    - markdown-it-sub</span><br><span class="line">    - markdown-it-abbr</span><br><span class="line">    - markdown-it-emoji</span><br><span class="line">  anchors:</span><br><span class="line">    level: 2</span><br><span class="line">    collisionSuffix: &#39;v&#39;</span><br><span class="line">    permalink: false</span><br><span class="line">    permalinkClass: header-anchor</span><br><span class="line">    permalinkSymbol: ☀</span><br></pre></td></tr></table></figure><h1>插入图片</h1><p>参考：<a href="https://www.jianshu.com/p/f72aaad7b852">HEXO插入图片</a></p><p>安装插件：<code>npm install hexo-asset-image --save</code></p><p>配置Hexo：将<code>post_asset_folder</code>字段置为<code>true</code></p><p>编辑文件：/node_modules/hexo-asset-image/index.js，修改为如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPosition</span>(<span class="params">str, m, i</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(m, i).join(m).length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="built_in">String</span>(hexo.version).split(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.extend.filter.register(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.config;</span><br><span class="line">  <span class="keyword">if</span>(config.post_asset_folder)&#123;</span><br><span class="line">        <span class="keyword">var</span> link = data.permalink;</span><br><span class="line">    <span class="keyword">if</span>(version.length &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">var</span> beginPos = getPosition(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">    <span class="keyword">var</span> endPos = link.lastIndexOf(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.substring(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.length; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.load(data[key], &#123;</span><br><span class="line">        ignoreWhitespace: <span class="literal">false</span>,</span><br><span class="line">        xmlMode: <span class="literal">false</span>,</span><br><span class="line">        lowerCaseTags: <span class="literal">false</span>,</span><br><span class="line">        decodeEntities: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ($(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">            <span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">            <span class="keyword">var</span> src = $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>).replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.test(src) &amp;&amp;</span><br><span class="line">               !<span class="regexp">/^\s*\//</span>.test(src)) &#123;</span><br><span class="line">              <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">              <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">              <span class="keyword">var</span> linkArray = link.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">var</span> srcArray = src.split(<span class="string">&#x27;/&#x27;</span>).filter(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">              &#125;);</span><br><span class="line">              <span class="keyword">if</span>(srcArray.length &gt; <span class="number">1</span>)</span><br><span class="line">                srcArray.shift();</span><br><span class="line">              src = srcArray.join(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">              $(<span class="built_in">this</span>).attr(<span class="string">&#x27;src&#x27;</span>, config.root + link + src);</span><br><span class="line">              <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.root + link + src);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">            <span class="built_in">console</span>.info&amp;&amp;<span class="built_in">console</span>.info($(<span class="built_in">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.html();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>使用：<code>![替换文本](图片路径)</code>，测试效果如下：</p><p><img src="/2020/09/25/Hexo%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87.png" alt="测试图片"></p>]]></content>
    
    
    <summary type="html">记录Hexo博客相关配置</summary>
    
    
    
    
    <category term="Hexo" scheme="https://vae1997.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>C++11特性总结记录</title>
    <link href="https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://vae1997.github.io/2020/09/24/C++11%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2020-09-24T11:36:34.760Z</published>
    <updated>2020-09-25T06:43:21.177Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>📺<a href="https://www.bilibili.com/video/BV1p4411v7Dh?from=search&amp;seid=11158986983875788976">B站侯捷C++11</a></p><h1>auto</h1><p>通过编译器自动获取变量类型，⚠️常在类型长/复杂(lambda)的情况下使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v;</span><br><span class="line"><span class="keyword">auto</span> pos = v.begin();<span class="comment">//迭代器类型vector&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> l = [](<span class="keyword">int</span> x) -&gt; <span class="keyword">bool</span> &#123;···&#125;;<span class="comment">//获取lambda的返回类型</span></span><br></pre></td></tr></table></figure><h1>=default &amp; =delete</h1><p>📖<a href="https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html">https://www.ibm.com/developerworks/cn/aix/library/1212_lufang_c11new/index.html</a></p><p>简单理解为：</p><ul><li>=default：需要用编译器默认生成的（Big-Three）特殊成员函数</li><li>=delete：禁止使用当前修饰的函数</li></ul><h2>=default</h2><ul><li>类中的特殊成员函数（构造、析构、拷贝、赋值）显式定义后，编译器默认生成的将失效</li><li>若仍需使用默认的函数，则必须显式定义，<code>增加编码工作量</code></li><li>此外，显式定义的函数<code>效率低于</code>编译器自动生成的</li><li>⚠️可在类外定义，但只能修饰类的特殊成员函数，且该函数没有默认参数</li></ul><h2>=delete</h2><ul><li>为禁止类对象之间的拷贝、赋值，或禁用不期望的转换和操作符</li><li>⚠️适用于普通函数，若修饰成员函数则只能在类中定义</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A()=<span class="keyword">default</span>; <span class="comment">//inline default</span></span><br><span class="line">    A(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;<span class="comment">//delete只能在类中定义</span></span><br><span class="line">    A&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> A&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span>=<span class="keyword">delete</span>;<span class="comment">//普通函数也可delete</span></span><br><span class="line">    <span class="keyword">virtual</span> ~A();</span><br><span class="line">&#125;;</span><br><span class="line">A::~A()=<span class="keyword">default</span>;<span class="comment">//Out-of-line default</span></span><br></pre></td></tr></table></figure><h1>decltype</h1><p>简单理解为：用于获取对象类型</p><ul><li>用于说明返回类型：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="comment">// decltype(x+y)add(T1 x, T2 y); add函数返回类型为x+y的返回类型</span></span><br><span class="line"><span class="comment">//但是x+y先于声明，编译无法通过，因此使用如下方法</span></span><br><span class="line">auto add(T1 x, T2 y) -&gt; decltype(x+y);//使用-&gt;，指定add函数的返回类型</span><br></pre></td></tr></table></figure><ul><li>用于模板中：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//obj为容器，则获取类型后可以进一步获取相关属性</span></span><br><span class="line"><span class="keyword">decltype</span>(obj)::iterator</span><br></pre></td></tr></table></figure><ul><li>获取lambda表达式的类型：</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义用于对象比较的lambda</span></span><br><span class="line"><span class="keyword">auto</span> cmp=[](<span class="keyword">const</span> Obj&amp; obj1, <span class="keyword">const</span> Obj&amp; obj2)&#123;<span class="keyword">return</span> ···&#125;;</span><br><span class="line"><span class="comment">//在set中根据cmp比较对象大小</span></span><br><span class="line">std::set&lt;Obj, decltype(cmp)&gt; coll(cmp);</span><br></pre></td></tr></table></figure><h1>initialization</h1><p>C++11之前初始化可以使用（）、{ }、=，C11提出一致使用{ }进行初始化</p><p>⚠️编译器看到{ }，实际生成的是initializer_list<T>，即<code>初始化列表</code></T></p><p>⚠️初始化列表背后关联<code>array&lt;T,n&gt;</code>容器（仅包含array的头部指针），并将容器中的值挨个传递到<code>构造函数</code></p><p>⚠️如果构造函数的参数本身就是initializer_list<T>，则整体直接传递，不再进行拆解</T></p><h2>initializer_list</h2><p>使用{ }设置默认初值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span> j&#123;&#125;;<span class="comment">//j为int，默认0</span></span><br><span class="line"><span class="keyword">int</span>* p;<span class="comment">//未定义的初值</span></span><br><span class="line"><span class="keyword">int</span>* q&#123;&#125;;<span class="comment">//q为int*，默认nullptr</span></span><br><span class="line"><span class="keyword">char</span> c&#123;<span class="number">99999</span>&#125;;<span class="comment">//原则上不可以，根据编译器而定error/warning</span></span><br></pre></td></tr></table></figure><p>initializer_list<T>作为函数参数，接收任意个T类型的参数</T></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; vals)</span></span>;</span><br><span class="line">print(&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;);<span class="comment">//必须使用&#123; &#125;传参</span></span><br></pre></td></tr></table></figure><h1>lambda</h1><p>可以简单当作是inline函数，格式如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Ⅰ] (Ⅱ) <span class="keyword">mutable</span> <span class="keyword">throw</span> -&gt; retType &#123;Ⅲ&#125;</span><br></pre></td></tr></table></figure><ul><li><p>[]：导入器，捕获外部变量，传值(默认)/传引用</p></li><li><p>()：参数，当需要传参，或指定mutable、throw、retType之一时，则必须有</p></li><li><p>mutable：决定[]中的值是否可以进行修改，可选</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> id=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [id]()<span class="keyword">mutable</span>&#123;<span class="comment">//id为值传递，指定mutable则内部可以修改id值</span></span><br><span class="line">    <span class="comment">//但注意此时，id作为0传递进来</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;id&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ++id;</span><br><span class="line">&#125;;</span><br><span class="line">id=<span class="number">42</span>;</span><br><span class="line">f1();<span class="comment">//调用lambda，值传递传入的id为0，但不影响外面的id值42</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;id]()<span class="keyword">mutable</span>&#123;···&#125;;<span class="comment">//传引用，则lambda内部的id和外部“共享”</span></span><br><span class="line"><span class="keyword">auto</span> f3 = [=,&amp;id]&#123;···&#125;;<span class="comment">//除id外的其余变量均为默认的值传递，没有mutable不能进行修改</span></span><br></pre></td></tr></table></figure></li><li><p>throw：抛出异常，可选</p></li><li><p>retType：返回类型，可选</p></li></ul><p>⚠️默认情况下，<code>lambda函数总是一个const函数</code>，mutable可以取消其常量性</p><h1>rvalue references</h1><p>📖<a href="https://www.cnblogs.com/qicosmos/p/3369940.html">https://www.cnblogs.com/qicosmos/p/3369940.html</a></p><p>📖<a href="https://www.cnblogs.com/qicosmos/p/3376241.html">https://www.cnblogs.com/qicosmos/p/3376241.html</a></p><p>📖<a href="https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html">https://www.ibm.com/developerworks/cn/aix/library/1307_lisl_c11/index.html</a></p><p>📖<a href="https://segmentfault.com/a/1190000016041544">https://segmentfault.com/a/1190000016041544</a> (<strong>更为详细全面</strong>)</p><ul><li><p>减少不必要的对象拷贝；使泛函定义更简洁</p></li><li><p>实现移动语义（Move Sementics）和完美转发（Perfect Forwarding）</p></li></ul><h2>lvalue &amp; rvalue</h2><ul><li><p>左值：表达式结束后依然存在的<code>持久化对象</code></p></li><li><p>右值：常表现为<code>临时对象</code>，只在当前语句中有效</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = get_a();<span class="comment">//a为左值，非引用返回的get_a()返回的临时变量为右值（纯右值）</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="built_in">std</span>::move(a);<span class="comment">//通过move返回的右值（将亡值）</span></span><br></pre></td></tr></table></figure></li><li><p>区分方法：若可对表达式<code>用 &amp; 符取址</code>，则为左值，否则为右值</p></li><li><p>右值也可以被修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//T()生成临时对象（右值），并将对象内部的变量通过set方法进行修改</span></span><br><span class="line">T().<span class="built_in">set</span>().get();</span><br></pre></td></tr></table></figure></li></ul><h2>lvalue references &amp; rvalue references</h2><ul><li><p>左值赋值左值引用（变量别名），右值赋值右值引用（临时变量的别名，生命周期延长）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; refa = a;<span class="comment">//左值引用refa，只能被左值a赋值，refa为左值</span></span><br><span class="line"><span class="comment">//！int&amp; b = 1; 左值引用b不能被右值1赋值</span></span><br><span class="line"><span class="comment">//！int&amp;&amp; b = a; 右值引用b不能被左值a赋值</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; b = <span class="number">1</span>;<span class="comment">//右值引用b，只能被右值1赋值，但注意此时b本身为左值</span></span><br></pre></td></tr></table></figure></li><li><p>const lvalue references</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; a = <span class="number">1</span>;<span class="comment">//const左值引用可以接收右值</span></span><br></pre></td></tr></table></figure></li></ul><h2>Move Sementics</h2><ul><li><p>对于右值的拷贝和赋值会调用<code>移动构造函数</code>和<code>移动赋值操作符</code></p></li><li><p>若没有定义，则<code>拷贝构造函数</code>和<code>拷贝赋值操作符</code>会被调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拷贝构造，若没有移动构造，当参数使用move或传递右值时，由于拷贝构造参数为const T&amp;，因此才会接受右值进行调用</span></span><br><span class="line">MyString(<span class="keyword">const</span> MyString&amp; str): _len(str._len) &#123;</span><br><span class="line">    _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">   _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动构造，当vector/deque扩容时，移动构造使用noexcept确保成功扩容</span></span><br><span class="line"><span class="comment">//str需要修改，因此不加const，但需要noexcept（表明一定不会发生异常）</span></span><br><span class="line">MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span> : _len(str._len) &#123;</span><br><span class="line">    _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">    str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">    str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//拷贝赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; str) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>]; <span class="comment">//新开辟空间</span></span><br><span class="line">        <span class="built_in">memcpy</span>(_data, str._data, _len); <span class="comment">//拷贝操作 </span></span><br><span class="line">        _data[_len] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移动赋值</span></span><br><span class="line">MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str)&#123;</span><br><span class="line">        <span class="keyword">if</span>(_data) <span class="keyword">delete</span> _data;</span><br><span class="line">        _len = str._len;</span><br><span class="line">        _data = str._data; <span class="comment">//直接将传入的str赋值</span></span><br><span class="line">        str._len = <span class="number">0</span>; <span class="comment">//传入的str长度置0</span></span><br><span class="line">        str._data = <span class="literal">NULL</span>; <span class="comment">//打断！将传入的str置空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>普通的函数和操作符也可以利用右值引用操作符实现转移语义</p></li></ul><h2>std::move</h2><ul><li>希望将左值转为右值：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">fun(<span class="built_in">std</span>::move(a));<span class="comment">//右值，调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用move后，原对象并非立即析构</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> b=<span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> c = <span class="built_in">std</span>::move(b);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;B:&quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;b&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//B: 0x61fe10，move后b对象依旧在，只是内容为空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br><span class="line"><span class="built_in">std</span>::move(c);<span class="comment">//只是调用move而不进行移动构造或移动赋值，则原对象没有影响</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;C:&quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;c&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//C:123 0x61fdf0</span></span><br></pre></td></tr></table></figure><h2>universal reference</h2><p>通用引用T&amp;&amp;不一定为右值引用，取决于<code>初始化</code>，以及是否发生<code>类型推导</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;<span class="comment">//T类型需要推导，T&amp;&amp;为通用引用</span></span><br><span class="line">fun(<span class="number">10</span>);<span class="comment">//param被右值10初始化</span></span><br><span class="line"><span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">fun(x);<span class="comment">//param被左值x初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> T&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//const T&amp;&amp;不需要推导，为右值引用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param)</span></span>&#123;···&#125;;<span class="comment">//右值引用</span></span><br></pre></td></tr></table></figure><p>引用折叠：只有右值引用推导为右值引用时，得到的还是右值引用；否则将变为左值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>&#123;···&#125;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ra=a;</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; aa = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//a,ra,aa均为左值，传入f()，T&amp;&amp;则为左值引用</span></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">f(<span class="built_in">string</span>(<span class="string">&quot;hello&quot;</span>)); <span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br><span class="line">f(<span class="built_in">std</span>::move(str));<span class="comment">//参数是右值，T&amp;&amp;为右值引用 </span></span><br></pre></td></tr></table></figure><h2>Perfect Forwarding</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp; i)</span> </span>&#123;···&#125; <span class="comment">//①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;···&#125; <span class="comment">//②重载①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;fun(i);&#125;<span class="comment">//经过传递，临时对象i成为命名对象，内部调用①</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forward_value</span><span class="params">(<span class="keyword">int</span>&amp;&amp; i)</span> </span>&#123;<span class="comment">//int&amp;&amp;类型确定，因此只能传递右值</span></span><br><span class="line">    fun(<span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(i));<span class="comment">//std::forward实现右值的完美转发</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; </span><br><span class="line">fun(a);<span class="comment">//左值，调用①</span></span><br><span class="line">fun(<span class="number">1</span>);<span class="comment">//右值，调用②</span></span><br><span class="line">forward(<span class="number">2</span>);<span class="comment">//2传入forward内部后调用①，不完美的转发！</span></span><br><span class="line">forward_value(<span class="number">3</span>);<span class="comment">//3传入内部后，std::forward确保调用②</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述情况虽然使用forward可以将右值进行完美传递，但类型还是有局限性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用引用+forward进行完美转发</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入右值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const左值时</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp;&amp; p)</span></span>&#123;···&#125;<span class="comment">//传入const右值时</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perfect_forward</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T&gt;(t));<span class="comment">//使用forward但此时T类型不确定，则f()接收的是通用引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>smart pointer</h1><p>侯捷的C++11视频缺失，但在<a href="https://www.bilibili.com/video/BV14s411E772?p=17">📺</a> 中有所提及<br>📖<a href="https://simonfang1.github.io/blog/2018/08/23/smart-pointer/">https://simonfang1.github.io/blog/2018/08/23/smart-pointer/</a><br>📖<a href="http://www.cplusplus.com/reference/memory/auto_ptr/">http://www.cplusplus.com/reference/memory/auto_ptr/</a><br>📖<a href="https://interview.huihut.com/#/?id=%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88">https://interview.huihut.com/#/?id=智能指针</a><br>📖<a href="https://www.jianshu.com/p/e4919f1c3a28">https://www.jianshu.com/p/e4919f1c3a28</a></p><h2>auto_ptr（C11弃用）</h2><ul><li><p>auto_ptr对象间赋值拷贝后所有权将被转移，且原来的指针将被<code>置空</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//auto_ptr以值传递方式作为参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fun</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;T&gt; tp)</span></span>&#123;···&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;T&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> T)</span></span>; </span><br><span class="line">Fun(p);<span class="comment">//p传入时发生拷贝，此时p已经为nullptr</span></span><br><span class="line"><span class="comment">//! p-&gt;xxx;</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li><p>auto_ptr对象<code>仅使用delete</code>析构，无法管理数组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//! std::auto_ptr&lt;T&gt; p(new T[5]);</span></span><br></pre></td></tr></table></figure></li><li><p>不能和标准容器一起使用</p></li></ul><h2>unique_ptr（代替auto_ptr）</h2><ul><li><p>不支持赋值拷贝，但可以使用<code>move</code>显式转移所有权</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;</span><br><span class="line"><span class="comment">//! std::unique_ptr&lt;T&gt; p2 = p1;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; p2 = <span class="built_in">std</span>::move(p1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure></li><li><p>析构时可以delete，也可delete[]，因此可以管理数组</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">// delete p1</span></span><br><span class="line">std::unique_ptr&lt;T[]&gt; p2(new T[5]);//delete[] p2</span><br></pre></td></tr></table></figure></li><li><p><code>release()</code>仅释放所有权，而<code>reset()</code>同时会释放资源</p></li></ul><h2>shared_ptr（基于<code>引用计数</code>实现）</h2><ul><li><p>多个shared_ptr指向同一对象时，共享一个引用计数器并记录shared_ptr实例数量</p></li><li><p>当最后一个指向对象的shared_ptr销毁时，会自动销毁其所指对象</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;<span class="comment">//直接创建</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p2 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);<span class="comment">//make_shared高效创建</span></span><br></pre></td></tr></table></figure></li><li><p><code>use_count()</code>方法得到强引用计数值</p></li><li><p>默认使用delete析构，析构数组需显式指定</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式指定delete[]析构</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> T[<span class="number">5</span>],[](T* p)&#123;<span class="keyword">delete</span>[] p;&#125;)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>避免不同的share_ptr指向同一资源</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;<span class="comment">//p1计数1，p1析构后销毁p</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;<span class="comment">//p2计数1，p2析构时p已经被销毁</span></span><br></pre></td></tr></table></figure></li><li><p><code>循环引用问题</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">A():m_sptrB(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~A()&#123;&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">B():m_sptrA(<span class="literal">nullptr</span>)&#123;&#125;;</span><br><span class="line">~B()&#123;&#125;</span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的share_ptr</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA计数1</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB计数1</span></span><br><span class="line">pA-&gt;m_sptrB = pB;<span class="comment">//m_sptrB引用pB，pB计数2，pA析构后计数1</span></span><br><span class="line">pB-&gt;m_sptrA = pA;<span class="comment">//m_sptrA引用pA，pA计数2，pB析构后计数1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多线程情况🔗<a href="https://www.jianshu.com/p/c75a0d33655c">https://www.jianshu.com/p/c75a0d33655c</a></p><ul><li>共享指针本身的<code>引用计数</code>操作是<code>原子的</code>，不会有内存泄漏</li><li>对共享指针内部封装的<code>原始指针</code>进行操作时，则<code>需要加锁</code></li><li>当同时读写同一个共享指针时，不能确定<code>编译器操作引用计数和原始指针的先后顺序</code></li></ul><p>解决方法：运用weak_ptr检测指针是否被释放，有两种方法：</p><ol><li>使用<strong>weak_ptr.lock</strong>函数得到一个shared_ptr指针，如果已经释放返回空</li><li>直接使用weak_ptr.expired()来判断一个指针是否被释放</li></ol></li></ul><h2>weak_ptr（解决循环引用问题）</h2><ul><li><p>指向shared_ptr管理的对象，但不会增减<code>强引用</code>计数器</p></li><li><p>调用<code>expired()</code>比调用<code>use_count()</code>方法速度更快，以确定是否指向有效资源</p></li><li><p>调用<code>lock()</code>将weak_ptr转型为share_ptr</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> T)</span></span>;<span class="comment">//直接创建share_ptr，强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::weak_ptr&lt;T&gt; <span class="title">wp1</span><span class="params">(sp1)</span></span>;<span class="comment">//使用share_ptr创建weak_ptr，弱引用计数1，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::weak_ptr&lt;T&gt; wp2 = wp1;<span class="comment">//使用weak_ptr创建weak_ptr，弱引用计数2，强引用计数1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; sp2 = wp2.lock();<span class="comment">//将weak_ptr转型为share_ptr</span></span><br></pre></td></tr></table></figure></li><li><p>解决循环引用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">weak_ptr&lt;B&gt; m_sptrB;<span class="comment">//A中包含B类型的weak_ptr</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PrintpB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_sptrB.expired())<span class="comment">//弱引用B有效，则lock为强引用</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; m_sptrB.lock( )-&gt;m_b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">weak_ptr&lt;A&gt; m_sptrA;<span class="comment">//B中包含A类型的weak_ptr</span></span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;<span class="comment">//A类型的share_ptr，pA强引用计数1</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;B&gt; <span class="title">pB</span><span class="params">(<span class="keyword">new</span> B)</span></span>;<span class="comment">//B类型的share_ptr，pB强引用计数1</span></span><br><span class="line">pA-&gt;m_sptrB = pB;<span class="comment">//弱引用m_sptrB引用pB，pB强引用计数1，弱引用计数1，pA析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">pB-&gt;m_sptrA = pA;<span class="comment">//弱引用m_sptrA引用pA，pA强引用计数1，弱引用计数1，pB析构-&gt;强计数0-&gt;释放对象-&gt;弱引用无效</span></span><br><span class="line">pA-&gt;PrintpB(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1>面试补充</h1><h2>shared_ptr初始化unique_ptr?</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; sp=make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; u=make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// unique_ptr&lt;int&gt; up=move(sp);！！！编译错误</span></span><br><span class="line"><span class="comment">//不存在用户定义的从 &quot;std::shared_ptr&lt;int&gt;&quot; 到 </span></span><br><span class="line"><span class="comment">//&quot;std::unique_ptr&lt;int, std::default_delete&lt;int&gt;&gt;&quot; 的适当转换</span></span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; up=move(u);</span><br></pre></td></tr></table></figure><h2>手撕智能指针</h2><p>🔗<a href="https://blog.csdn.net/yanchenzhi/article/details/107591037">https://blog.csdn.net/yanchenzhi/article/details/107591037</a></p><h3>unique_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针，智能指针内部包含的普通指针</span></span><br><span class="line">    <span class="comment">//禁止拷贝构造</span></span><br><span class="line">    UniquePtr(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line">    <span class="comment">//禁止赋值</span></span><br><span class="line">    UniquePtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&lt;T&gt;&amp; p)=<span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造方法，使用普通指针初始化，默认值nullptr</span></span><br><span class="line">    UniquePtr(T* p=<span class="literal">nullptr</span>):m_p(p)&#123;&#125;;</span><br><span class="line">    ~UniquePtr()<span class="comment">//析构函数，delete指针释放资源</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m_p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            m_p=<span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3>shared_ptr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* m_p;<span class="comment">//裸指针</span></span><br><span class="line">    <span class="keyword">int</span>* count;<span class="comment">//int指针指向共享的计数值</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造，计数0(nullptr)，普通指针根据具体类型T*置为0，nullptr</span></span><br><span class="line">    SharedPtr():count(<span class="number">0</span>),m_p((T*)<span class="number">0</span>)&#123;&#125;;</span><br><span class="line">    <span class="comment">//使用普通指针构造，时刻注意count是指针，因此new int</span></span><br><span class="line">    SharedPtr(T* p):count(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)),m_p(p)&#123;&#125;</span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="comment">//1.参数p同样为shared_ptr，因此需要取p.m_p裸指针赋值</span></span><br><span class="line">    <span class="comment">//2.拷贝后，参数p的引用计数++，count先指向参数的count</span></span><br><span class="line">    <span class="comment">//可以直接在初始化形参列表中：count(&amp;(++ *p.count))</span></span><br><span class="line">    <span class="comment">//先p.count取得参数的int计数指针</span></span><br><span class="line">    <span class="comment">//再*操作取得计数的值，并++</span></span><br><span class="line">    <span class="comment">//最后&amp;操作取得参数计数指针的地址，并赋值给count</span></span><br><span class="line">    SharedPtr(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p):count(p.count),m_p(p.m_p)</span><br><span class="line">    &#123;</span><br><span class="line">        ++(*count);<span class="comment">//*取count值后++</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载赋值=运算符</span></span><br><span class="line">    <span class="comment">//1.赋值m_p</span></span><br><span class="line">    <span class="comment">//2.赋值count</span></span><br><span class="line">    <span class="comment">//由于是将参数所在的指针赋给当前指针，因此当前指针的引用计数需要--，而参数指针的计数++</span></span><br><span class="line">    <span class="comment">//因此还需判断当前指针计数，为零则需析构</span></span><br><span class="line">    SharedPtr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SharedPtr&lt;T&gt;&amp; p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果自赋值，直接返回本身*this</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span> == &amp;p) <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        <span class="comment">//参数指针的引用计数++，p.count获取参数的int指针，*取引用计数的值，最后++</span></span><br><span class="line">        ++(*(p.count));</span><br><span class="line">        <span class="comment">//是否析构</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;<span class="comment">//此时析构并不置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行赋值操作</span></span><br><span class="line">        count = p.count;</span><br><span class="line">        m_p = p.m_p;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载*运算符</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*()&#123;<span class="keyword">return</span> *m_p;&#125;</span><br><span class="line">    <span class="comment">//重载-&gt;运算符</span></span><br><span class="line">    T* <span class="keyword">operator</span>-&gt;()&#123;<span class="keyword">return</span> m_p;&#125;</span><br><span class="line">    <span class="comment">//析构，计数为0时才析构，否则计数值--即可</span></span><br><span class="line">    ~SharedPtr()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//m_p为空则不需要操作</span></span><br><span class="line">        <span class="comment">//否则先--count，如果不为零也不需要操作</span></span><br><span class="line">        <span class="comment">//否则析构，释放资源</span></span><br><span class="line">        <span class="keyword">if</span>(m_p &amp;&amp; --(*count) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_p;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回引用计数值</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> *count;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录C++11中相关特性</summary>
    
    
    
    
    <category term="C++" scheme="https://vae1997.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github搭建博客踩坑记录</title>
    <link href="https://vae1997.github.io/2020/09/24/Hexo+Github/"/>
    <id>https://vae1997.github.io/2020/09/24/Hexo+Github/</id>
    <published>2020-09-24T07:48:18.315Z</published>
    <updated>2020-09-25T06:45:52.546Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考链接:<a href="https://cloud.tencent.com/developer/article/1520557">这可能是迄今为止最全的hexo博客搭建教程</a></p><h1>操作步骤</h1><ol><li><p>安装git和nodejs，并在github创建仓库</p></li><li><p>以管理员权限打开cmd，并执行<code>npm install -g hexo-cli</code>安装hexo客户端</p></li><li><p>在需要创建博客的目录下执行<code>hexo init blog</code></p></li><li><p><code>cd blog</code>并执行<code>npm install</code></p></li><li><p>编辑blog/_config.yml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https:&#x2F;&#x2F;github.com&#x2F;Vae1997&#x2F;Vae1997.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>执行<code>npm install hexo-deployer-git --save</code>，确保可以找到git命令</p></li><li><p>此时执行<code>hexo g -d</code>后即可访问https://vae1997.github.io/</p></li><li><p>可执行如下命令避免每次提交时都需要输入用户名和密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Vae1997&quot;</span><br><span class="line">git config --global user.email &quot;844821239@qq.com&quot;</span><br></pre></td></tr></table></figure></li></ol><h1>踩坑记录</h1><h2>误提交大于100M的文件</h2><p>🔴执行hexo d后出现：this exceeds GitHub’s file size limit of 100.00 MB</p><p>需退回上一次的提交：参考<a href="https://ztygcs.github.io/posts/%E5%A4%A7%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%AF%BC%E8%87%B4github%E6%8A%A5%E9%94%99/">大文件上传致Github报错</a></p><ol><li><code>cd blog/.deploy_git</code></li><li><code>git log</code>查看上次提交</li><li>复制第一个commit后的代码，执行<code>git reset xxxxx</code></li><li>再次查看提交记录，已经回滚到上一次</li></ol>]]></content>
    
    
    <summary type="html">记录Hexo博客搭建过程</summary>
    
    
    
    
    <category term="Hexo" scheme="https://vae1997.github.io/tags/Hexo/"/>
    
    <category term="搭建" scheme="https://vae1997.github.io/tags/%E6%90%AD%E5%BB%BA/"/>
    
    <category term="Git" scheme="https://vae1997.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
